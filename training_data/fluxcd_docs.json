{
  "technology": "fluxcd",
  "base_url": "https://fluxcd.io/flux/",
  "pages": [
    {
      "url": "https://fluxcd.io/flux/components/source/api/",
      "title": "API Reference | Flux",
      "content": "Docs\nToolkit Components\nSource Controller\nAPI Reference\nAPI Reference\nSource API reference v1\nThe GitOps Toolkit Custom Resource Definitions documentation.\nLast modified 2023-03-23:\nGA: adapt to SC, NC and KC APIs graduating to v1 (3d32a85)",
      "code_examples": [],
      "headings": [
        {
          "level": 1,
          "text": "API Reference",
          "id": ""
        },
        {
          "level": 5,
          "text": "Source API reference v1",
          "id": ""
        }
      ],
      "timestamp": 1750732706.1397939
    },
    {
      "url": "https://fluxcd.io/flux/components/source/api/v1/",
      "title": "Source API reference v1 | Flux",
      "content": "Docs\nToolkit Components\nSource Controller\nAPI Reference\nSource API reference v1\nSource API reference v1\nThe GitOps Toolkit Custom Resource Definitions documentation.\nPackages:\nsource.toolkit.fluxcd.io/v1\nsource.toolkit.fluxcd.io/v1\nPackage v1 contains API Schema definitions for the source v1 API group\nResource Types:\nBucket\nGitRepository\nHelmChart\nHelmRepository\nOCIRepository\nBucket\nBucket is the Schema for the buckets API.\nField\nDescription\napiVersion\nstring\nsource.toolkit.fluxcd.io/v1\nkind\nstring\nBucket\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nBucketSpec\nprovider\nstring\n(Optional)\nProvider of the object storage bucket.\nDefaults to ‘generic’, which expects an S3 (API) compatible object\nstorage.\nbucketName\nstring\nBucketName is the name of the object storage bucket.\nendpoint\nstring\nEndpoint is the object storage address the BucketName is located at.\nsts\nBucketSTSSpec\n(Optional)\nSTS specifies the required configuration to use a Security Token\nService for fetching temporary credentials to authenticate in a\nBucket provider.\nThis field is only supported for the\naws\nand\ngeneric\nproviders.\ninsecure\nbool\n(Optional)\nInsecure allows connecting to a non-TLS HTTP Endpoint.\nregion\nstring\n(Optional)\nRegion of the Endpoint where the BucketName is located in.\nprefix\nstring\n(Optional)\nPrefix to use for server-side filtering of files in the Bucket.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing authentication credentials\nfor the Bucket.\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef can be given the name of a Secret containing\neither or both of\na PEM-encoded client certificate (\ntls.crt\n) and private\nkey (\ntls.key\n);\na PEM-encoded CA certificate (\nca.crt\n)\nand whichever are supplied, will be used for connecting to the\nbucket. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type\nOpaque\nor\nkubernetes.io/tls\n.\nThis field is only supported for the\ngeneric\nprovider.\nproxySecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the Bucket server.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the Bucket Endpoint is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for fetch operations, defaults to 60s.\nignore\nstring\n(Optional)\nIgnore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nBucket.\nstatus\nBucketStatus\nGitRepository\nGitRepository is the Schema for the gitrepositories API.\nField\nDescription\napiVersion\nstring\nsource.toolkit.fluxcd.io/v1\nkind\nstring\nGitRepository\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nGitRepositorySpec\nurl\nstring\nURL specifies the Git repository URL, it can be an HTTP/S or SSH address.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing authentication credentials for\nthe GitRepository.\nFor HTTPS repositories the Secret must contain ‘username’ and ‘password’\nfields for basic auth or ‘bearerToken’ field for token auth.\nFor SSH repositories the Secret must contain ‘identity’\nand ‘known_hosts’ fields.\nprovider\nstring\n(Optional)\nProvider used for authentication, can be ‘azure’, ‘github’, ‘generic’.\nWhen not specified, defaults to ‘generic’.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the GitRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for Git operations like cloning, defaults to 60s.\nref\nGitRepositoryRef\n(Optional)\nReference specifies the Git reference to resolve and monitor for\nchanges, defaults to the ‘master’ branch.\nverify\nGitRepositoryVerification\n(Optional)\nVerification specifies the configuration to verify the Git commit\nsignature(s).\nproxySecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the Git server.\nignore\nstring\n(Optional)\nIgnore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nGitRepository.\nrecurseSubmodules\nbool\n(Optional)\nRecurseSubmodules enables the initialization of all submodules within\nthe GitRepository as cloned from the URL, using their default settings.\ninclude\n[]GitRepositoryInclude\n(Optional)\nInclude specifies a list of GitRepository resources which Artifacts\nshould be included in the Artifact produced for this GitRepository.\nsparseCheckout\n[]string\n(Optional)\nSparseCheckout specifies a list of directories to checkout when cloning\nthe repository. If specified, only these directories are included in the\nArtifact produced for this GitRepository.\nstatus\nGitRepositoryStatus\nHelmChart\nHelmChart is the Schema for the helmcharts API.\nField\nDescription\napiVersion\nstring\nsource.toolkit.fluxcd.io/v1\nkind\nstring\nHelmChart\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nHelmChartSpec\nchart\nstring\nChart is the name or path the Helm chart is available at in the\nSourceRef.\nversion\nstring\n(Optional)\nVersion is the chart version semver expression, ignored for charts from\nGitRepository and Bucket sources. Defaults to latest when omitted.\nsourceRef\nLocalHelmChartSourceReference\nSourceRef is the reference to the Source the chart is available at.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the HelmChart SourceRef is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\nreconcileStrategy\nstring\n(Optional)\nReconcileStrategy determines what enables the creation of a new artifact.\nValid values are (‘ChartVersion’, ‘Revision’).\nSee the documentation of the values for an explanation on their behavior.\nDefaults to ChartVersion when omitted.\nvaluesFiles\n[]string\n(Optional)\nValuesFiles is an alternative list of values files to use as the chart\nvalues (values.yaml is not included by default), expected to be a\nrelative path in the SourceRef.\nValues files are merged in the order of this list with the last file\noverriding the first. Ignored when omitted.\nignoreMissingValuesFiles\nbool\n(Optional)\nIgnoreMissingValuesFiles controls whether to silently ignore missing values\nfiles rather than failing.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nsource.\nverify\nOCIRepositoryVerification\n(Optional)\nVerify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic.\nThis field is only supported when using HelmRepository source with spec.type ‘oci’.\nChart dependencies, which are not bundled in the umbrella chart artifact, are not verified.\nstatus\nHelmChartStatus\nHelmRepository\nHelmRepository is the Schema for the helmrepositories API.\nField\nDescription\napiVersion\nstring\nsource.toolkit.fluxcd.io/v1\nkind\nstring\nHelmRepository\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nHelmRepositorySpec\nurl\nstring\nURL of the Helm repository, a valid URL contains at least a protocol and\nhost.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing authentication credentials\nfor the HelmRepository.\nFor HTTP/S basic auth the secret must contain ‘username’ and ‘password’\nfields.\nSupport for TLS auth using the ‘certFile’ and ‘keyFile’, and/or ‘caFile’\nkeys is deprecated. Please use\n.spec.certSecretRef\ninstead.\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef can be given the name of a Secret containing\neither or both of\na PEM-encoded client certificate (\ntls.crt\n) and private\nkey (\ntls.key\n);\na PEM-encoded CA certificate (\nca.crt\n)\nand whichever are supplied, will be used for connecting to the\nregistry. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type\nOpaque\nor\nkubernetes.io/tls\n.\nIt takes precedence over the values specified in the Secret referred\nto by\n.spec.secretRef\n.\npassCredentials\nbool\n(Optional)\nPassCredentials allows the credentials from the SecretRef to be passed\non to a host that does not match the host as defined in URL.\nThis may be required if the host of the advertised chart URLs in the\nindex differ from the defined URL.\nEnabling this should be done with caution, as it can potentially result\nin credentials getting stolen in a MITM-attack.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which the HelmRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ninsecure\nbool\n(Optional)\nInsecure allows connecting to a non-TLS HTTP container registry.\nThis field is only taken into account if the .spec.type field is set to ‘oci’.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is used for the index fetch operation for an HTTPS helm repository,\nand for remote OCI Repository operations like pulling for an OCI helm\nchart by the associated HelmChart.\nIts default value is 60s.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nHelmRepository.\naccessFrom\ngithub.com/fluxcd/pkg/apis/acl.AccessFrom\n(Optional)\nAccessFrom specifies an Access Control List for allowing cross-namespace\nreferences to this object.\nNOTE: Not implemented, provisional as of\nhttps://github.com/fluxcd/flux2/pull/2092\ntype\nstring\n(Optional)\nType of the HelmRepository.\nWhen this field is set to “oci”, the URL field value must be prefixed with “oci://”.\nprovider\nstring\n(Optional)\nProvider used for authentication, can be ‘aws’, ‘azure’, ‘gcp’ or ‘generic’.\nThis field is optional, and only taken into account if the .spec.type field is set to ‘oci’.\nWhen not specified, defaults to ‘generic’.\nstatus\nHelmRepositoryStatus\nOCIRepository\nOCIRepository is the Schema for the ocirepositories API\nField\nDescription\napiVersion\nstring\nsource.toolkit.fluxcd.io/v1\nkind\nstring\nOCIRepository\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nOCIRepositorySpec\nurl\nstring\nURL is a reference to an OCI artifact repository hosted\non a remote container registry.\nref\nOCIRepositoryRef\n(Optional)\nThe OCI reference to pull and monitor for changes,\ndefaults to the latest tag.\nlayerSelector\nOCILayerSelector\n(Optional)\nLayerSelector specifies which layer should be extracted from the OCI artifact.\nWhen not specified, the first layer found in the artifact is selected.\nprovider\nstring\n(Optional)\nThe provider used for authentication, can be ‘aws’, ‘azure’, ‘gcp’ or ‘generic’.\nWhen not specified, defaults to ‘generic’.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef contains the secret name containing the registry login\ncredentials to resolve image metadata.\nThe secret must be of type kubernetes.io/dockerconfigjson.\nverify\nOCIRepositoryVerification\n(Optional)\nVerify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic.\nserviceAccountName\nstring\n(Optional)\nServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate\nthe image pull if the service account has attached pull secrets. For more information:\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef can be given the name of a Secret containing\neither or both of\na PEM-encoded client certificate (\ntls.crt\n) and private\nkey (\ntls.key\n);\na PEM-encoded CA certificate (\nca.crt\n)\nand whichever are supplied, will be used for connecting to the\nregistry. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type\nOpaque\nor\nkubernetes.io/tls\n.\nproxySecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the container registry.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the OCIRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nThe timeout for remote OCI Repository operations like pulling, defaults to 60s.\nignore\nstring\n(Optional)\nIgnore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are.\ninsecure\nbool\n(Optional)\nInsecure allows connecting to a non-TLS HTTP container registry.\nsuspend\nbool\n(Optional)\nThis flag tells the controller to suspend the reconciliation of this source.\nstatus\nOCIRepositoryStatus\nArtifact\n(\nAppears on:\nBucketStatus\n,\nGitRepositoryStatus\n,\nHelmChartStatus\n,\nHelmRepositoryStatus\n,\nOCIRepositoryStatus\n)\nArtifact represents the output of a Source reconciliation.\nField\nDescription\npath\nstring\nPath is the relative file path of the Artifact. It can be used to locate\nthe file in the root of the Artifact storage on the local file system of\nthe controller managing the Source.\nurl\nstring\nURL is the HTTP address of the Artifact as exposed by the controller\nmanaging the Source. It can be used to retrieve the Artifact for\nconsumption, e.g. by another controller applying the Artifact contents.\nrevision\nstring\nRevision is a human-readable identifier traceable in the origin source\nsystem. It can be a Git commit SHA, Git tag, a Helm chart version, etc.\ndigest\nstring\n(Optional)\nDigest is the digest of the file in the form of ‘\n:\n’.\nlastUpdateTime\nKubernetes meta/v1.Time\nLastUpdateTime is the timestamp corresponding to the last update of the\nArtifact.\nsize\nint64\n(Optional)\nSize is the number of bytes in the file.\nmetadata\nmap[string]string\n(Optional)\nMetadata holds upstream information such as OCI annotations.\nBucketSTSSpec\n(\nAppears on:\nBucketSpec\n)\nBucketSTSSpec specifies the required configuration to use a Security Token\nService for fetching temporary credentials to authenticate in a Bucket\nprovider.\nField\nDescription\nprovider\nstring\nProvider of the Security Token Service.\nendpoint\nstring\nEndpoint is the HTTP/S endpoint of the Security Token Service from\nwhere temporary credentials will be fetched.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing authentication credentials\nfor the STS endpoint. This Secret must contain the fields\nusername\nand\npassword\nand is supported only for the\nldap\nprovider.\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef can be given the name of a Secret containing\neither or both of\na PEM-encoded client certificate (\ntls.crt\n) and private\nkey (\ntls.key\n);\na PEM-encoded CA certificate (\nca.crt\n)\nand whichever are supplied, will be used for connecting to the\nSTS endpoint. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type\nOpaque\nor\nkubernetes.io/tls\n.\nThis field is only supported for the\nldap\nprovider.\nBucketSpec\n(\nAppears on:\nBucket\n)\nBucketSpec specifies the required configuration to produce an Artifact for\nan object storage bucket.\nField\nDescription\nprovider\nstring\n(Optional)\nProvider of the object storage bucket.\nDefaults to ‘generic’, which expects an S3 (API) compatible object\nstorage.\nbucketName\nstring\nBucketName is the name of the object storage bucket.\nendpoint\nstring\nEndpoint is the object storage address the BucketName is located at.\nsts\nBucketSTSSpec\n(Optional)\nSTS specifies the required configuration to use a Security Token\nService for fetching temporary credentials to authenticate in a\nBucket provider.\nThis field is only supported for the\naws\nand\ngeneric\nproviders.\ninsecure\nbool\n(Optional)\nInsecure allows connecting to a non-TLS HTTP Endpoint.\nregion\nstring\n(Optional)\nRegion of the Endpoint where the BucketName is located in.\nprefix\nstring\n(Optional)\nPrefix to use for server-side filtering of files in the Bucket.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing authentication credentials\nfor the Bucket.\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef can be given the name of a Secret containing\neither or both of\na PEM-encoded client certificate (\ntls.crt\n) and private\nkey (\ntls.key\n);\na PEM-encoded CA certificate (\nca.crt\n)\nand whichever are supplied, will be used for connecting to the\nbucket. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type\nOpaque\nor\nkubernetes.io/tls\n.\nThis field is only supported for the\ngeneric\nprovider.\nproxySecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the Bucket server.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the Bucket Endpoint is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for fetch operations, defaults to 60s.\nignore\nstring\n(Optional)\nIgnore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nBucket.\nBucketStatus\n(\nAppears on:\nBucket\n)\nBucketStatus records the observed state of a Bucket.\nField\nDescription\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last observed generation of the Bucket object.\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nConditions holds the conditions for the Bucket.\nurl\nstring\n(Optional)\nURL is the dynamic fetch link for the latest Artifact.\nIt is provided on a “best effort” basis, and using the precise\nBucketStatus.Artifact data is recommended.\nartifact\nArtifact\n(Optional)\nArtifact represents the last successful Bucket reconciliation.\nobservedIgnore\nstring\n(Optional)\nObservedIgnore is the observed exclusion patterns used for constructing\nthe source artifact.\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nGitRepositoryInclude\n(\nAppears on:\nGitRepositorySpec\n,\nGitRepositoryStatus\n)\nGitRepositoryInclude specifies a local reference to a GitRepository which\nArtifact (sub-)contents must be included, and where they should be placed.\nField\nDescription\nrepository\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\nGitRepositoryRef specifies the GitRepository which Artifact contents\nmust be included.\nfromPath\nstring\n(Optional)\nFromPath specifies the path to copy contents from, defaults to the root\nof the Artifact.\ntoPath\nstring\n(Optional)\nToPath specifies the path to copy contents to, defaults to the name of\nthe GitRepositoryRef.\nGitRepositoryRef\n(\nAppears on:\nGitRepositorySpec\n)\nGitRepositoryRef specifies the Git reference to resolve and checkout.\nField\nDescription\nbranch\nstring\n(Optional)\nBranch to check out, defaults to ‘master’ if no other field is defined.\ntag\nstring\n(Optional)\nTag to check out, takes precedence over Branch.\nsemver\nstring\n(Optional)\nSemVer tag expression to check out, takes precedence over Tag.\nname\nstring\n(Optional)\nName of the reference to check out; takes precedence over Branch, Tag and SemVer.\nIt must be a valid Git reference:\nhttps://git-scm.com/docs/git-check-ref-format#_description\nExamples: “refs/heads/main”, “refs/tags/v0.1.0”, “refs/pull/420/head”, “refs/merge-requests/1/head”\ncommit\nstring\n(Optional)\nCommit SHA to check out, takes precedence over all reference fields.\nThis can be combined with Branch to shallow clone the branch, in which\nthe commit is expected to exist.\nGitRepositorySpec\n(\nAppears on:\nGitRepository\n)\nGitRepositorySpec specifies the required configuration to produce an\nArtifact for a Git repository.\nField\nDescription\nurl\nstring\nURL specifies the Git repository URL, it can be an HTTP/S or SSH address.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing authentication credentials for\nthe GitRepository.\nFor HTTPS repositories the Secret must contain ‘username’ and ‘password’\nfields for basic auth or ‘bearerToken’ field for token auth.\nFor SSH repositories the Secret must contain ‘identity’\nand ‘known_hosts’ fields.\nprovider\nstring\n(Optional)\nProvider used for authentication, can be ‘azure’, ‘github’, ‘generic’.\nWhen not specified, defaults to ‘generic’.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the GitRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for Git operations like cloning, defaults to 60s.\nref\nGitRepositoryRef\n(Optional)\nReference specifies the Git reference to resolve and monitor for\nchanges, defaults to the ‘master’ branch.\nverify\nGitRepositoryVerification\n(Optional)\nVerification specifies the configuration to verify the Git commit\nsignature(s).\nproxySecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the Git server.\nignore\nstring\n(Optional)\nIgnore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nGitRepository.\nrecurseSubmodules\nbool\n(Optional)\nRecurseSubmodules enables the initialization of all submodules within\nthe GitRepository as cloned from the URL, using their default settings.\ninclude\n[]GitRepositoryInclude\n(Optional)\nInclude specifies a list of GitRepository resources which Artifacts\nshould be included in the Artifact produced for this GitRepository.\nsparseCheckout\n[]string\n(Optional)\nSparseCheckout specifies a list of directories to checkout when cloning\nthe repository. If specified, only these directories are included in the\nArtifact produced for this GitRepository.\nGitRepositoryStatus\n(\nAppears on:\nGitRepository\n)\nGitRepositoryStatus records the observed state of a Git repository.\nField\nDescription\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last observed generation of the GitRepository\nobject.\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nConditions holds the conditions for the GitRepository.\nartifact\nArtifact\n(Optional)\nArtifact represents the last successful GitRepository reconciliation.\nincludedArtifacts\n[]Artifact\n(Optional)\nIncludedArtifacts contains a list of the last successfully included\nArtifacts as instructed by GitRepositorySpec.Include.\nobservedIgnore\nstring\n(Optional)\nObservedIgnore is the observed exclusion patterns used for constructing\nthe source artifact.\nobservedRecurseSubmodules\nbool\n(Optional)\nObservedRecurseSubmodules is the observed resource submodules\nconfiguration used to produce the current Artifact.\nobservedInclude\n[]GitRepositoryInclude\n(Optional)\nObservedInclude is the observed list of GitRepository resources used to\nproduce the current Artifact.\nobservedSparseCheckout\n[]string\n(Optional)\nObservedSparseCheckout is the observed list of directories used to\nproduce the current Artifact.\nsourceVerificationMode\nGitVerificationMode\n(Optional)\nSourceVerificationMode is the last used verification mode indicating\nwhich Git object(s) have been verified.\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nGitRepositoryVerification\n(\nAppears on:\nGitRepositorySpec\n)\nGitRepositoryVerification specifies the Git commit signature verification\nstrategy.\nField\nDescription\nmode\nGitVerificationMode\n(Optional)\nMode specifies which Git object(s) should be verified.\nThe variants “head” and “HEAD” both imply the same thing, i.e. verify\nthe commit that the HEAD of the Git repository points to. The variant\n“head” solely exists to ensure backwards compatibility.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\nSecretRef specifies the Secret containing the public keys of trusted Git\nauthors.\nGitVerificationMode\n(\nstring\nalias)\n(\nAppears on:\nGitRepositoryStatus\n,\nGitRepositoryVerification\n)\nGitVerificationMode specifies the verification mode for a Git repository.\nHelmChartSpec\n(\nAppears on:\nHelmChart\n)\nHelmChartSpec specifies the desired state of a Helm chart.\nField\nDescription\nchart\nstring\nChart is the name or path the Helm chart is available at in the\nSourceRef.\nversion\nstring\n(Optional)\nVersion is the chart version semver expression, ignored for charts from\nGitRepository and Bucket sources. Defaults to latest when omitted.\nsourceRef\nLocalHelmChartSourceReference\nSourceRef is the reference to the Source the chart is available at.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the HelmChart SourceRef is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\nreconcileStrategy\nstring\n(Optional)\nReconcileStrategy determines what enables the creation of a new artifact.\nValid values are (‘ChartVersion’, ‘Revision’).\nSee the documentation of the values for an explanation on their behavior.\nDefaults to ChartVersion when omitted.\nvaluesFiles\n[]string\n(Optional)\nValuesFiles is an alternative list of values files to use as the chart\nvalues (values.yaml is not included by default), expected to be a\nrelative path in the SourceRef.\nValues files are merged in the order of this list with the last file\noverriding the first. Ignored when omitted.\nignoreMissingValuesFiles\nbool\n(Optional)\nIgnoreMissingValuesFiles controls whether to silently ignore missing values\nfiles rather than failing.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nsource.\nverify\nOCIRepositoryVerification\n(Optional)\nVerify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic.\nThis field is only supported when using HelmRepository source with spec.type ‘oci’.\nChart dependencies, which are not bundled in the umbrella chart artifact, are not verified.\nHelmChartStatus\n(\nAppears on:\nHelmChart\n)\nHelmChartStatus records the observed state of the HelmChart.\nField\nDescription\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last observed generation of the HelmChart\nobject.\nobservedSourceArtifactRevision\nstring\n(Optional)\nObservedSourceArtifactRevision is the last observed Artifact.Revision\nof the HelmChartSpec.SourceRef.\nobservedChartName\nstring\n(Optional)\nObservedChartName is the last observed chart name as specified by the\nresolved chart reference.\nobservedValuesFiles\n[]string\n(Optional)\nObservedValuesFiles are the observed value files of the last successful\nreconciliation.\nIt matches the chart in the last successfully reconciled artifact.\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nConditions holds the conditions for the HelmChart.\nurl\nstring\n(Optional)\nURL is the dynamic fetch link for the latest Artifact.\nIt is provided on a “best effort” basis, and using the precise\nBucketStatus.Artifact data is recommended.\nartifact\nArtifact\n(Optional)\nArtifact represents the output of the last successful reconciliation.\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nHelmRepositorySpec\n(\nAppears on:\nHelmRepository\n)\nHelmRepositorySpec specifies the required configuration to produce an\nArtifact for a Helm repository index YAML.\nField\nDescription\nurl\nstring\nURL of the Helm repository, a valid URL contains at least a protocol and\nhost.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing authentication credentials\nfor the HelmRepository.\nFor HTTP/S basic auth the secret must contain ‘username’ and ‘password’\nfields.\nSupport for TLS auth using the ‘certFile’ and ‘keyFile’, and/or ‘caFile’\nkeys is deprecated. Please use\n.spec.certSecretRef\ninstead.\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef can be given the name of a Secret containing\neither or both of\na PEM-encoded client certificate (\ntls.crt\n) and private\nkey (\ntls.key\n);\na PEM-encoded CA certificate (\nca.crt\n)\nand whichever are supplied, will be used for connecting to the\nregistry. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type\nOpaque\nor\nkubernetes.io/tls\n.\nIt takes precedence over the values specified in the Secret referred\nto by\n.spec.secretRef\n.\npassCredentials\nbool\n(Optional)\nPassCredentials allows the credentials from the SecretRef to be passed\non to a host that does not match the host as defined in URL.\nThis may be required if the host of the advertised chart URLs in the\nindex differ from the defined URL.\nEnabling this should be done with caution, as it can potentially result\nin credentials getting stolen in a MITM-attack.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which the HelmRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ninsecure\nbool\n(Optional)\nInsecure allows connecting to a non-TLS HTTP container registry.\nThis field is only taken into account if the .spec.type field is set to ‘oci’.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is used for the index fetch operation for an HTTPS helm repository,\nand for remote OCI Repository operations like pulling for an OCI helm\nchart by the associated HelmChart.\nIts default value is 60s.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend the reconciliation of this\nHelmRepository.\naccessFrom\ngithub.com/fluxcd/pkg/apis/acl.AccessFrom\n(Optional)\nAccessFrom specifies an Access Control List for allowing cross-namespace\nreferences to this object.\nNOTE: Not implemented, provisional as of\nhttps://github.com/fluxcd/flux2/pull/2092\ntype\nstring\n(Optional)\nType of the HelmRepository.\nWhen this field is set to “oci”, the URL field value must be prefixed with “oci://”.\nprovider\nstring\n(Optional)\nProvider used for authentication, can be ‘aws’, ‘azure’, ‘gcp’ or ‘generic’.\nThis field is optional, and only taken into account if the .spec.type field is set to ‘oci’.\nWhen not specified, defaults to ‘generic’.\nHelmRepositoryStatus\n(\nAppears on:\nHelmRepository\n)\nHelmRepositoryStatus records the observed state of the HelmRepository.\nField\nDescription\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last observed generation of the HelmRepository\nobject.\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nConditions holds the conditions for the HelmRepository.\nurl\nstring\n(Optional)\nURL is the dynamic fetch link for the latest Artifact.\nIt is provided on a “best effort” basis, and using the precise\nHelmRepositoryStatus.Artifact data is recommended.\nartifact\nArtifact\n(Optional)\nArtifact represents the last successful HelmRepository reconciliation.\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nLocalHelmChartSourceReference\n(\nAppears on:\nHelmChartSpec\n)\nLocalHelmChartSourceReference contains enough information to let you locate\nthe typed referenced object at namespace level.\nField\nDescription\napiVersion\nstring\n(Optional)\nAPIVersion of the referent.\nkind\nstring\nKind of the referent, valid values are (‘HelmRepository’, ‘GitRepository’,\n‘Bucket’).\nname\nstring\nName of the referent.\nOCILayerSelector\n(\nAppears on:\nOCIRepositorySpec\n,\nOCIRepositoryStatus\n)\nOCILayerSelector specifies which layer should be extracted from an OCI Artifact\nField\nDescription\nmediaType\nstring\n(Optional)\nMediaType specifies the OCI media type of the layer\nwhich should be extracted from the OCI Artifact. The\nfirst layer matching this type is selected.\noperation\nstring\n(Optional)\nOperation specifies how the selected layer should be processed.\nBy default, the layer compressed content is extracted to storage.\nWhen the operation is set to ‘copy’, the layer compressed content\nis persisted to storage as it is.\nOCIRepositoryRef\n(\nAppears on:\nOCIRepositorySpec\n)\nOCIRepositoryRef defines the image reference for the OCIRepository’s URL\nField\nDescription\ndigest\nstring\n(Optional)\nDigest is the image digest to pull, takes precedence over SemVer.\nThe value should be in the format ‘sha256:\n’.\nsemver\nstring\n(Optional)\nSemVer is the range of tags to pull selecting the latest within\nthe range, takes precedence over Tag.\nsemverFilter\nstring\n(Optional)\nSemverFilter is a regex pattern to filter the tags within the SemVer range.\ntag\nstring\n(Optional)\nTag is the image tag to pull, defaults to latest.\nOCIRepositorySpec\n(\nAppears on:\nOCIRepository\n)\nOCIRepositorySpec defines the desired state of OCIRepository\nField\nDescription\nurl\nstring\nURL is a reference to an OCI artifact repository hosted\non a remote container registry.\nref\nOCIRepositoryRef\n(Optional)\nThe OCI reference to pull and monitor for changes,\ndefaults to the latest tag.\nlayerSelector\nOCILayerSelector\n(Optional)\nLayerSelector specifies which layer should be extracted from the OCI artifact.\nWhen not specified, the first layer found in the artifact is selected.\nprovider\nstring\n(Optional)\nThe provider used for authentication, can be ‘aws’, ‘azure’, ‘gcp’ or ‘generic’.\nWhen not specified, defaults to ‘generic’.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef contains the secret name containing the registry login\ncredentials to resolve image metadata.\nThe secret must be of type kubernetes.io/dockerconfigjson.\nverify\nOCIRepositoryVerification\n(Optional)\nVerify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic.\nserviceAccountName\nstring\n(Optional)\nServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate\nthe image pull if the service account has attached pull secrets. For more information:\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef can be given the name of a Secret containing\neither or both of\na PEM-encoded client certificate (\ntls.crt\n) and private\nkey (\ntls.key\n);\na PEM-encoded CA certificate (\nca.crt\n)\nand whichever are supplied, will be used for connecting to the\nregistry. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type\nOpaque\nor\nkubernetes.io/tls\n.\nproxySecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the container registry.\ninterval\nKubernetes meta/v1.Duration\nInterval at which the OCIRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nThe timeout for remote OCI Repository operations like pulling, defaults to 60s.\nignore\nstring\n(Optional)\nIgnore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are.\ninsecure\nbool\n(Optional)\nInsecure allows connecting to a non-TLS HTTP container registry.\nsuspend\nbool\n(Optional)\nThis flag tells the controller to suspend the reconciliation of this source.\nOCIRepositoryStatus\n(\nAppears on:\nOCIRepository\n)\nOCIRepositoryStatus defines the observed state of OCIRepository\nField\nDescription\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last observed generation.\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nConditions holds the conditions for the OCIRepository.\nurl\nstring\n(Optional)\nURL is the download link for the artifact output of the last OCI Repository sync.\nartifact\nArtifact\n(Optional)\nArtifact represents the output of the last successful OCI Repository sync.\nobservedIgnore\nstring\n(Optional)\nObservedIgnore is the observed exclusion patterns used for constructing\nthe source artifact.\nobservedLayerSelector\nOCILayerSelector\n(Optional)\nObservedLayerSelector is the observed layer selector used for constructing\nthe source artifact.\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nOCIRepositoryVerification\n(\nAppears on:\nHelmChartSpec\n,\nOCIRepositorySpec\n)\nOCIRepositoryVerification verifies the authenticity of an OCI Artifact\nField\nDescription\nprovider\nstring\nProvider specifies the technology used to sign the OCI Artifact.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Kubernetes Secret containing the\ntrusted public keys.\nmatchOIDCIdentity\n[]OIDCIdentityMatch\n(Optional)\nMatchOIDCIdentity specifies the identity matching criteria to use\nwhile verifying an OCI artifact which was signed using Cosign keyless\nsigning. The artifact’s identity is deemed to be verified if any of the\nspecified matchers match against the identity.\nOIDCIdentityMatch\n(\nAppears on:\nOCIRepositoryVerification\n)\nOIDCIdentityMatch specifies options for verifying the certificate identity,\ni.e. the issuer and the subject of the certificate.\nField\nDescription\nissuer\nstring\nIssuer specifies the regex pattern to match against to verify\nthe OIDC issuer in the Fulcio certificate. The pattern must be a\nvalid Go regular expression.\nsubject\nstring\nSubject specifies the regex pattern to match against to verify\nthe identity subject in the Fulcio certificate. The pattern must\nbe a valid Go regular expression.\nSource\nSource interface must be supported by all API types.\nSource is the interface that provides generic access to the Artifact and\ninterval. It must be supported by all kinds of the source.toolkit.fluxcd.io\nAPI group.\nThis page was automatically generated with\ngen-crd-api-reference-docs",
      "code_examples": [
        {
          "language": "",
          "code": "source.toolkit.fluxcd.io/v1",
          "element": "<code>source.toolkit.fluxcd.io/v1</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "kubernetes.io/tls",
          "element": "<code>kubernetes.io/tls</code>"
        },
        {
          "language": "",
          "code": "proxySecretRef",
          "element": "<code>proxySecretRef</code>"
        },
        {
          "language": "",
          "code": "source.toolkit.fluxcd.io/v1",
          "element": "<code>source.toolkit.fluxcd.io/v1</code>"
        },
        {
          "language": "",
          "code": "GitRepository",
          "element": "<code>GitRepository</code>"
        },
        {
          "language": "",
          "code": "proxySecretRef",
          "element": "<code>proxySecretRef</code>"
        },
        {
          "language": "",
          "code": "recurseSubmodules",
          "element": "<code>recurseSubmodules</code>"
        },
        {
          "language": "",
          "code": "sparseCheckout",
          "element": "<code>sparseCheckout</code>"
        },
        {
          "language": "",
          "code": "source.toolkit.fluxcd.io/v1",
          "element": "<code>source.toolkit.fluxcd.io/v1</code>"
        },
        {
          "language": "",
          "code": "reconcileStrategy",
          "element": "<code>reconcileStrategy</code>"
        },
        {
          "language": "",
          "code": "valuesFiles",
          "element": "<code>valuesFiles</code>"
        },
        {
          "language": "",
          "code": "ignoreMissingValuesFiles",
          "element": "<code>ignoreMissingValuesFiles</code>"
        },
        {
          "language": "",
          "code": "source.toolkit.fluxcd.io/v1",
          "element": "<code>source.toolkit.fluxcd.io/v1</code>"
        },
        {
          "language": "",
          "code": "HelmRepository",
          "element": "<code>HelmRepository</code>"
        },
        {
          "language": "",
          "code": ".spec.certSecretRef",
          "element": "<code>.spec.certSecretRef</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "kubernetes.io/tls",
          "element": "<code>kubernetes.io/tls</code>"
        },
        {
          "language": "",
          "code": ".spec.secretRef",
          "element": "<code>.spec.secretRef</code>"
        },
        {
          "language": "",
          "code": "passCredentials",
          "element": "<code>passCredentials</code>"
        },
        {
          "language": "",
          "code": "source.toolkit.fluxcd.io/v1",
          "element": "<code>source.toolkit.fluxcd.io/v1</code>"
        },
        {
          "language": "",
          "code": "OCIRepository",
          "element": "<code>OCIRepository</code>"
        },
        {
          "language": "",
          "code": "layerSelector",
          "element": "<code>layerSelector</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "kubernetes.io/tls",
          "element": "<code>kubernetes.io/tls</code>"
        },
        {
          "language": "",
          "code": "proxySecretRef",
          "element": "<code>proxySecretRef</code>"
        },
        {
          "language": "",
          "code": "lastUpdateTime",
          "element": "<code>lastUpdateTime</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "kubernetes.io/tls",
          "element": "<code>kubernetes.io/tls</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "kubernetes.io/tls",
          "element": "<code>kubernetes.io/tls</code>"
        },
        {
          "language": "",
          "code": "proxySecretRef",
          "element": "<code>proxySecretRef</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "observedIgnore",
          "element": "<code>observedIgnore</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "proxySecretRef",
          "element": "<code>proxySecretRef</code>"
        },
        {
          "language": "",
          "code": "recurseSubmodules",
          "element": "<code>recurseSubmodules</code>"
        },
        {
          "language": "",
          "code": "sparseCheckout",
          "element": "<code>sparseCheckout</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "includedArtifacts",
          "element": "<code>includedArtifacts</code>"
        },
        {
          "language": "",
          "code": "observedIgnore",
          "element": "<code>observedIgnore</code>"
        },
        {
          "language": "",
          "code": "observedRecurseSubmodules",
          "element": "<code>observedRecurseSubmodules</code>"
        },
        {
          "language": "",
          "code": "observedInclude",
          "element": "<code>observedInclude</code>"
        },
        {
          "language": "",
          "code": "observedSparseCheckout",
          "element": "<code>observedSparseCheckout</code>"
        },
        {
          "language": "",
          "code": "sourceVerificationMode",
          "element": "<code>sourceVerificationMode</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "reconcileStrategy",
          "element": "<code>reconcileStrategy</code>"
        },
        {
          "language": "",
          "code": "valuesFiles",
          "element": "<code>valuesFiles</code>"
        },
        {
          "language": "",
          "code": "ignoreMissingValuesFiles",
          "element": "<code>ignoreMissingValuesFiles</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "observedSourceArtifactRevision",
          "element": "<code>observedSourceArtifactRevision</code>"
        },
        {
          "language": "",
          "code": "observedChartName",
          "element": "<code>observedChartName</code>"
        },
        {
          "language": "",
          "code": "observedValuesFiles",
          "element": "<code>observedValuesFiles</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": ".spec.certSecretRef",
          "element": "<code>.spec.certSecretRef</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "kubernetes.io/tls",
          "element": "<code>kubernetes.io/tls</code>"
        },
        {
          "language": "",
          "code": ".spec.secretRef",
          "element": "<code>.spec.secretRef</code>"
        },
        {
          "language": "",
          "code": "passCredentials",
          "element": "<code>passCredentials</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "semverFilter",
          "element": "<code>semverFilter</code>"
        },
        {
          "language": "",
          "code": "layerSelector",
          "element": "<code>layerSelector</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "kubernetes.io/tls",
          "element": "<code>kubernetes.io/tls</code>"
        },
        {
          "language": "",
          "code": "proxySecretRef",
          "element": "<code>proxySecretRef</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "observedIgnore",
          "element": "<code>observedIgnore</code>"
        },
        {
          "language": "",
          "code": "observedLayerSelector",
          "element": "<code>observedLayerSelector</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "matchOIDCIdentity",
          "element": "<code>matchOIDCIdentity</code>"
        },
        {
          "language": "",
          "code": "gen-crd-api-reference-docs",
          "element": "<code>gen-crd-api-reference-docs</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Source API reference v1",
          "id": ""
        },
        {
          "level": 2,
          "text": "source.toolkit.fluxcd.io/v1",
          "id": "source.toolkit.fluxcd.io/v1"
        },
        {
          "level": 3,
          "text": "Bucket",
          "id": "source.toolkit.fluxcd.io/v1.Bucket"
        },
        {
          "level": 3,
          "text": "GitRepository",
          "id": "source.toolkit.fluxcd.io/v1.GitRepository"
        },
        {
          "level": 3,
          "text": "HelmChart",
          "id": "source.toolkit.fluxcd.io/v1.HelmChart"
        },
        {
          "level": 3,
          "text": "HelmRepository",
          "id": "source.toolkit.fluxcd.io/v1.HelmRepository"
        },
        {
          "level": 3,
          "text": "OCIRepository",
          "id": "source.toolkit.fluxcd.io/v1.OCIRepository"
        },
        {
          "level": 3,
          "text": "Artifact",
          "id": "source.toolkit.fluxcd.io/v1.Artifact"
        },
        {
          "level": 3,
          "text": "BucketSTSSpec",
          "id": "source.toolkit.fluxcd.io/v1.BucketSTSSpec"
        },
        {
          "level": 3,
          "text": "BucketSpec",
          "id": "source.toolkit.fluxcd.io/v1.BucketSpec"
        },
        {
          "level": 3,
          "text": "BucketStatus",
          "id": "source.toolkit.fluxcd.io/v1.BucketStatus"
        },
        {
          "level": 3,
          "text": "GitRepositoryInclude",
          "id": "source.toolkit.fluxcd.io/v1.GitRepositoryInclude"
        },
        {
          "level": 3,
          "text": "GitRepositoryRef",
          "id": "source.toolkit.fluxcd.io/v1.GitRepositoryRef"
        },
        {
          "level": 3,
          "text": "GitRepositorySpec",
          "id": "source.toolkit.fluxcd.io/v1.GitRepositorySpec"
        },
        {
          "level": 3,
          "text": "GitRepositoryStatus",
          "id": "source.toolkit.fluxcd.io/v1.GitRepositoryStatus"
        },
        {
          "level": 3,
          "text": "GitRepositoryVerification",
          "id": "source.toolkit.fluxcd.io/v1.GitRepositoryVerification"
        },
        {
          "level": 3,
          "text": "GitVerificationMode\n(stringalias)",
          "id": "source.toolkit.fluxcd.io/v1.GitVerificationMode"
        },
        {
          "level": 3,
          "text": "HelmChartSpec",
          "id": "source.toolkit.fluxcd.io/v1.HelmChartSpec"
        },
        {
          "level": 3,
          "text": "HelmChartStatus",
          "id": "source.toolkit.fluxcd.io/v1.HelmChartStatus"
        },
        {
          "level": 3,
          "text": "HelmRepositorySpec",
          "id": "source.toolkit.fluxcd.io/v1.HelmRepositorySpec"
        },
        {
          "level": 3,
          "text": "HelmRepositoryStatus",
          "id": "source.toolkit.fluxcd.io/v1.HelmRepositoryStatus"
        },
        {
          "level": 3,
          "text": "LocalHelmChartSourceReference",
          "id": "source.toolkit.fluxcd.io/v1.LocalHelmChartSourceReference"
        },
        {
          "level": 3,
          "text": "OCILayerSelector",
          "id": "source.toolkit.fluxcd.io/v1.OCILayerSelector"
        },
        {
          "level": 3,
          "text": "OCIRepositoryRef",
          "id": "source.toolkit.fluxcd.io/v1.OCIRepositoryRef"
        },
        {
          "level": 3,
          "text": "OCIRepositorySpec",
          "id": "source.toolkit.fluxcd.io/v1.OCIRepositorySpec"
        },
        {
          "level": 3,
          "text": "OCIRepositoryStatus",
          "id": "source.toolkit.fluxcd.io/v1.OCIRepositoryStatus"
        },
        {
          "level": 3,
          "text": "OCIRepositoryVerification",
          "id": "source.toolkit.fluxcd.io/v1.OCIRepositoryVerification"
        },
        {
          "level": 3,
          "text": "OIDCIdentityMatch",
          "id": "source.toolkit.fluxcd.io/v1.OIDCIdentityMatch"
        },
        {
          "level": 3,
          "text": "Source",
          "id": "source.toolkit.fluxcd.io/v1.Source"
        }
      ],
      "timestamp": 1750732709.463337
    },
    {
      "url": "https://fluxcd.io/flux/components/kustomize/api/",
      "title": "API Reference | Flux",
      "content": "Docs\nToolkit Components\nKustomize Controller\nAPI Reference\nAPI Reference\nKustomize API reference v1\nThe GitOps Toolkit Custom Resource Definitions documentation.\nLast modified 2023-03-23:\nGA: adapt to SC, NC and KC APIs graduating to v1 (3d32a85)",
      "code_examples": [],
      "headings": [
        {
          "level": 1,
          "text": "API Reference",
          "id": ""
        },
        {
          "level": 5,
          "text": "Kustomize API reference v1",
          "id": ""
        }
      ],
      "timestamp": 1750732712.311362
    },
    {
      "url": "https://fluxcd.io/flux/components/kustomize/api/v1/",
      "title": "Kustomize API reference v1 | Flux",
      "content": "Docs\nToolkit Components\nKustomize Controller\nAPI Reference\nKustomize API reference v1\nKustomize API reference v1\nThe GitOps Toolkit Custom Resource Definitions documentation.\nPackages:\nkustomize.toolkit.fluxcd.io/v1\nkustomize.toolkit.fluxcd.io/v1\nPackage v1 contains API Schema definitions for the kustomize.toolkit.fluxcd.io\nv1 API group.\nResource Types:\nKustomization\nKustomization\nKustomization is the Schema for the kustomizations API.\nField\nDescription\napiVersion\nstring\nkustomize.toolkit.fluxcd.io/v1\nkind\nstring\nKustomization\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nKustomizationSpec\ncommonMetadata\nCommonMetadata\n(Optional)\nCommonMetadata specifies the common labels and annotations that are\napplied to all resources. Any existing label or annotation will be\noverridden if its key matches a common one.\ndependsOn\n[]github.com/fluxcd/pkg/apis/meta.NamespacedObjectReference\n(Optional)\nDependsOn may contain a meta.NamespacedObjectReference slice\nwith references to Kustomization resources that must be ready before this\nKustomization can be reconciled.\ndecryption\nDecryption\n(Optional)\nDecrypt Kubernetes secrets before applying them on the cluster.\ninterval\nKubernetes meta/v1.Duration\nThe interval at which to reconcile the Kustomization.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\nretryInterval\nKubernetes meta/v1.Duration\n(Optional)\nThe interval at which to retry a previously failed reconciliation.\nWhen not specified, the controller uses the KustomizationSpec.Interval\nvalue to retry failures.\nkubeConfig\ngithub.com/fluxcd/pkg/apis/meta.KubeConfigReference\n(Optional)\nThe KubeConfig for reconciling the Kustomization on a remote cluster.\nWhen used in combination with KustomizationSpec.ServiceAccountName,\nforces the controller to act on behalf of that Service Account at the\ntarget cluster.\nIf the –default-service-account flag is set, its value will be used as\na controller level fallback for when KustomizationSpec.ServiceAccountName\nis empty.\npath\nstring\n(Optional)\nPath to the directory containing the kustomization.yaml file, or the\nset of plain YAMLs a kustomization.yaml should be generated for.\nDefaults to ‘None’, which translates to the root path of the SourceRef.\npostBuild\nPostBuild\n(Optional)\nPostBuild describes which actions to perform on the YAML manifest\ngenerated by building the kustomize overlay.\nprune\nbool\nPrune enables garbage collection.\ndeletionPolicy\nstring\n(Optional)\nDeletionPolicy can be used to control garbage collection when this\nKustomization is deleted. Valid values are (‘MirrorPrune’, ‘Delete’,\n‘WaitForTermination’, ‘Orphan’). ‘MirrorPrune’ mirrors the Prune field\n(orphan if false, delete if true). Defaults to ‘MirrorPrune’.\nhealthChecks\n[]github.com/fluxcd/pkg/apis/meta.NamespacedObjectKindReference\n(Optional)\nA list of resources to be included in the health assessment.\nnamePrefix\nstring\n(Optional)\nNamePrefix will prefix the names of all managed resources.\nnameSuffix\nstring\n(Optional)\nNameSuffix will suffix the names of all managed resources.\npatches\n[]github.com/fluxcd/pkg/apis/kustomize.Patch\n(Optional)\nStrategic merge and JSON patches, defined as inline YAML objects,\ncapable of targeting objects based on kind, label and annotation selectors.\nimages\n[]github.com/fluxcd/pkg/apis/kustomize.Image\n(Optional)\nImages is a list of (image name, new name, new tag or digest)\nfor changing image names, tags or digests. This can also be achieved with a\npatch, but this operator is simpler to specify.\nserviceAccountName\nstring\n(Optional)\nThe name of the Kubernetes service account to impersonate\nwhen reconciling this Kustomization.\nsourceRef\nCrossNamespaceSourceReference\nReference of the source where the kustomization file is.\nsuspend\nbool\n(Optional)\nThis flag tells the controller to suspend subsequent kustomize executions,\nit does not apply to already started executions. Defaults to false.\ntargetNamespace\nstring\n(Optional)\nTargetNamespace sets or overrides the namespace in the\nkustomization.yaml file.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for validation, apply and health checking operations.\nDefaults to ‘Interval’ duration.\nforce\nbool\n(Optional)\nForce instructs the controller to recreate resources\nwhen patching fails due to an immutable field change.\nwait\nbool\n(Optional)\nWait instructs the controller to check the health of all the reconciled\nresources. When enabled, the HealthChecks are ignored. Defaults to false.\ncomponents\n[]string\n(Optional)\nComponents specifies relative paths to specifications of other Components.\nhealthCheckExprs\n[]github.com/fluxcd/pkg/apis/kustomize.CustomHealthCheck\n(Optional)\nHealthCheckExprs is a list of healthcheck expressions for evaluating the\nhealth of custom resources using Common Expression Language (CEL).\nThe expressions are evaluated only when Wait or HealthChecks are specified.\nstatus\nKustomizationStatus\nCommonMetadata\n(\nAppears on:\nKustomizationSpec\n)\nCommonMetadata defines the common labels and annotations.\nField\nDescription\nannotations\nmap[string]string\n(Optional)\nAnnotations to be added to the object’s metadata.\nlabels\nmap[string]string\n(Optional)\nLabels to be added to the object’s metadata.\nCrossNamespaceSourceReference\n(\nAppears on:\nKustomizationSpec\n)\nCrossNamespaceSourceReference contains enough information to let you locate the\ntyped Kubernetes resource object at cluster level.\nField\nDescription\napiVersion\nstring\n(Optional)\nAPI version of the referent.\nkind\nstring\nKind of the referent.\nname\nstring\nName of the referent.\nnamespace\nstring\n(Optional)\nNamespace of the referent, defaults to the namespace of the Kubernetes\nresource object that contains the reference.\nDecryption\n(\nAppears on:\nKustomizationSpec\n)\nDecryption defines how decryption is handled for Kubernetes manifests.\nField\nDescription\nprovider\nstring\nProvider is the name of the decryption engine.\nserviceAccountName\nstring\n(Optional)\nServiceAccountName is the name of the service account used to\nauthenticate with KMS services from cloud providers. If a\nstatic credential for a given cloud provider is defined\ninside the Secret referenced by SecretRef, that static\ncredential takes priority.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nThe secret name containing the private OpenPGP keys used for decryption.\nA static credential for a cloud provider defined inside the Secret\ntakes priority to secret-less authentication with the ServiceAccountName\nfield.\nKustomizationSpec\n(\nAppears on:\nKustomization\n)\nKustomizationSpec defines the configuration to calculate the desired state\nfrom a Source using Kustomize.\nField\nDescription\ncommonMetadata\nCommonMetadata\n(Optional)\nCommonMetadata specifies the common labels and annotations that are\napplied to all resources. Any existing label or annotation will be\noverridden if its key matches a common one.\ndependsOn\n[]github.com/fluxcd/pkg/apis/meta.NamespacedObjectReference\n(Optional)\nDependsOn may contain a meta.NamespacedObjectReference slice\nwith references to Kustomization resources that must be ready before this\nKustomization can be reconciled.\ndecryption\nDecryption\n(Optional)\nDecrypt Kubernetes secrets before applying them on the cluster.\ninterval\nKubernetes meta/v1.Duration\nThe interval at which to reconcile the Kustomization.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.\nretryInterval\nKubernetes meta/v1.Duration\n(Optional)\nThe interval at which to retry a previously failed reconciliation.\nWhen not specified, the controller uses the KustomizationSpec.Interval\nvalue to retry failures.\nkubeConfig\ngithub.com/fluxcd/pkg/apis/meta.KubeConfigReference\n(Optional)\nThe KubeConfig for reconciling the Kustomization on a remote cluster.\nWhen used in combination with KustomizationSpec.ServiceAccountName,\nforces the controller to act on behalf of that Service Account at the\ntarget cluster.\nIf the –default-service-account flag is set, its value will be used as\na controller level fallback for when KustomizationSpec.ServiceAccountName\nis empty.\npath\nstring\n(Optional)\nPath to the directory containing the kustomization.yaml file, or the\nset of plain YAMLs a kustomization.yaml should be generated for.\nDefaults to ‘None’, which translates to the root path of the SourceRef.\npostBuild\nPostBuild\n(Optional)\nPostBuild describes which actions to perform on the YAML manifest\ngenerated by building the kustomize overlay.\nprune\nbool\nPrune enables garbage collection.\ndeletionPolicy\nstring\n(Optional)\nDeletionPolicy can be used to control garbage collection when this\nKustomization is deleted. Valid values are (‘MirrorPrune’, ‘Delete’,\n‘WaitForTermination’, ‘Orphan’). ‘MirrorPrune’ mirrors the Prune field\n(orphan if false, delete if true). Defaults to ‘MirrorPrune’.\nhealthChecks\n[]github.com/fluxcd/pkg/apis/meta.NamespacedObjectKindReference\n(Optional)\nA list of resources to be included in the health assessment.\nnamePrefix\nstring\n(Optional)\nNamePrefix will prefix the names of all managed resources.\nnameSuffix\nstring\n(Optional)\nNameSuffix will suffix the names of all managed resources.\npatches\n[]github.com/fluxcd/pkg/apis/kustomize.Patch\n(Optional)\nStrategic merge and JSON patches, defined as inline YAML objects,\ncapable of targeting objects based on kind, label and annotation selectors.\nimages\n[]github.com/fluxcd/pkg/apis/kustomize.Image\n(Optional)\nImages is a list of (image name, new name, new tag or digest)\nfor changing image names, tags or digests. This can also be achieved with a\npatch, but this operator is simpler to specify.\nserviceAccountName\nstring\n(Optional)\nThe name of the Kubernetes service account to impersonate\nwhen reconciling this Kustomization.\nsourceRef\nCrossNamespaceSourceReference\nReference of the source where the kustomization file is.\nsuspend\nbool\n(Optional)\nThis flag tells the controller to suspend subsequent kustomize executions,\nit does not apply to already started executions. Defaults to false.\ntargetNamespace\nstring\n(Optional)\nTargetNamespace sets or overrides the namespace in the\nkustomization.yaml file.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for validation, apply and health checking operations.\nDefaults to ‘Interval’ duration.\nforce\nbool\n(Optional)\nForce instructs the controller to recreate resources\nwhen patching fails due to an immutable field change.\nwait\nbool\n(Optional)\nWait instructs the controller to check the health of all the reconciled\nresources. When enabled, the HealthChecks are ignored. Defaults to false.\ncomponents\n[]string\n(Optional)\nComponents specifies relative paths to specifications of other Components.\nhealthCheckExprs\n[]github.com/fluxcd/pkg/apis/kustomize.CustomHealthCheck\n(Optional)\nHealthCheckExprs is a list of healthcheck expressions for evaluating the\nhealth of custom resources using Common Expression Language (CEL).\nThe expressions are evaluated only when Wait or HealthChecks are specified.\nKustomizationStatus\n(\nAppears on:\nKustomization\n)\nKustomizationStatus defines the observed state of a kustomization.\nField\nDescription\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last reconciled generation.\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nlastAppliedRevision\nstring\n(Optional)\nThe last successfully applied revision.\nEquals the Revision of the applied Artifact from the referenced Source.\nlastAppliedOriginRevision\nstring\n(Optional)\nThe last successfully applied origin revision.\nEquals the origin revision of the applied Artifact from the referenced Source.\nUsually present on the Metadata of the applied Artifact and depends on the\nSource type, e.g. for OCI it’s the value associated with the key\n“org.opencontainers.image.revision”.\nlastAttemptedRevision\nstring\n(Optional)\nLastAttemptedRevision is the revision of the last reconciliation attempt.\ninventory\nResourceInventory\n(Optional)\nInventory contains the list of Kubernetes resource object references that\nhave been successfully applied.\nPostBuild\n(\nAppears on:\nKustomizationSpec\n)\nPostBuild describes which actions to perform on the YAML manifest\ngenerated by building the kustomize overlay.\nField\nDescription\nsubstitute\nmap[string]string\n(Optional)\nSubstitute holds a map of key/value pairs.\nThe variables defined in your YAML manifests that match any of the keys\ndefined in the map will be substituted with the set value.\nIncludes support for bash string replacement functions\ne.g. ${var:=default}, ${var:position} and ${var/substring/replacement}.\nsubstituteFrom\n[]SubstituteReference\n(Optional)\nSubstituteFrom holds references to ConfigMaps and Secrets containing\nthe variables and their values to be substituted in the YAML manifests.\nThe ConfigMap and the Secret data keys represent the var names, and they\nmust match the vars declared in the manifests for the substitution to\nhappen.\nResourceInventory\n(\nAppears on:\nKustomizationStatus\n)\nResourceInventory contains a list of Kubernetes resource object references\nthat have been applied by a Kustomization.\nField\nDescription\nentries\n[]ResourceRef\nEntries of Kubernetes resource object references.\nResourceRef\n(\nAppears on:\nResourceInventory\n)\nResourceRef contains the information necessary to locate a resource within a cluster.\nField\nDescription\nid\nstring\nID is the string representation of the Kubernetes resource object’s metadata,\nin the format ‘\n_\n’.\nv\nstring\nVersion is the API version of the Kubernetes resource object’s kind.\nSubstituteReference\n(\nAppears on:\nPostBuild\n)\nSubstituteReference contains a reference to a resource containing\nthe variables name and value.\nField\nDescription\nkind\nstring\nKind of the values referent, valid values are (‘Secret’, ‘ConfigMap’).\nname\nstring\nName of the values referent. Should reside in the same namespace as the\nreferring resource.\noptional\nbool\n(Optional)\nOptional indicates whether the referenced resource must exist, or whether to\ntolerate its absence. If true and the referenced resource is absent, proceed\nas if the resource was present but empty, without any variables defined.\nThis page was automatically generated with\ngen-crd-api-reference-docs",
      "code_examples": [
        {
          "language": "",
          "code": "kustomize.toolkit.fluxcd.io/v1",
          "element": "<code>kustomize.toolkit.fluxcd.io/v1</code>"
        },
        {
          "language": "",
          "code": "Kustomization",
          "element": "<code>Kustomization</code>"
        },
        {
          "language": "",
          "code": "commonMetadata",
          "element": "<code>commonMetadata</code>"
        },
        {
          "language": "",
          "code": "retryInterval",
          "element": "<code>retryInterval</code>"
        },
        {
          "language": "",
          "code": "deletionPolicy",
          "element": "<code>deletionPolicy</code>"
        },
        {
          "language": "",
          "code": "healthChecks",
          "element": "<code>healthChecks</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "targetNamespace",
          "element": "<code>targetNamespace</code>"
        },
        {
          "language": "",
          "code": "healthCheckExprs",
          "element": "<code>healthCheckExprs</code>"
        },
        {
          "language": "",
          "code": "annotations",
          "element": "<code>annotations</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "commonMetadata",
          "element": "<code>commonMetadata</code>"
        },
        {
          "language": "",
          "code": "retryInterval",
          "element": "<code>retryInterval</code>"
        },
        {
          "language": "",
          "code": "deletionPolicy",
          "element": "<code>deletionPolicy</code>"
        },
        {
          "language": "",
          "code": "healthChecks",
          "element": "<code>healthChecks</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "targetNamespace",
          "element": "<code>targetNamespace</code>"
        },
        {
          "language": "",
          "code": "healthCheckExprs",
          "element": "<code>healthCheckExprs</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "lastAppliedRevision",
          "element": "<code>lastAppliedRevision</code>"
        },
        {
          "language": "",
          "code": "lastAppliedOriginRevision",
          "element": "<code>lastAppliedOriginRevision</code>"
        },
        {
          "language": "",
          "code": "lastAttemptedRevision",
          "element": "<code>lastAttemptedRevision</code>"
        },
        {
          "language": "",
          "code": "substituteFrom",
          "element": "<code>substituteFrom</code>"
        },
        {
          "language": "",
          "code": "gen-crd-api-reference-docs",
          "element": "<code>gen-crd-api-reference-docs</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Kustomize API reference v1",
          "id": ""
        },
        {
          "level": 2,
          "text": "kustomize.toolkit.fluxcd.io/v1",
          "id": "kustomize.toolkit.fluxcd.io/v1"
        },
        {
          "level": 3,
          "text": "Kustomization",
          "id": "kustomize.toolkit.fluxcd.io/v1.Kustomization"
        },
        {
          "level": 3,
          "text": "CommonMetadata",
          "id": "kustomize.toolkit.fluxcd.io/v1.CommonMetadata"
        },
        {
          "level": 3,
          "text": "CrossNamespaceSourceReference",
          "id": "kustomize.toolkit.fluxcd.io/v1.CrossNamespaceSourceReference"
        },
        {
          "level": 3,
          "text": "Decryption",
          "id": "kustomize.toolkit.fluxcd.io/v1.Decryption"
        },
        {
          "level": 3,
          "text": "KustomizationSpec",
          "id": "kustomize.toolkit.fluxcd.io/v1.KustomizationSpec"
        },
        {
          "level": 3,
          "text": "KustomizationStatus",
          "id": "kustomize.toolkit.fluxcd.io/v1.KustomizationStatus"
        },
        {
          "level": 3,
          "text": "PostBuild",
          "id": "kustomize.toolkit.fluxcd.io/v1.PostBuild"
        },
        {
          "level": 3,
          "text": "ResourceInventory",
          "id": "kustomize.toolkit.fluxcd.io/v1.ResourceInventory"
        },
        {
          "level": 3,
          "text": "ResourceRef",
          "id": "kustomize.toolkit.fluxcd.io/v1.ResourceRef"
        },
        {
          "level": 3,
          "text": "SubstituteReference",
          "id": "kustomize.toolkit.fluxcd.io/v1.SubstituteReference"
        }
      ],
      "timestamp": 1750732715.3311439
    },
    {
      "url": "https://fluxcd.io/flux/components/helm/api/",
      "title": "API Reference | Flux",
      "content": "Docs\nToolkit Components\nHelm Controller\nAPI Reference\nAPI Reference\nHelm API reference v2\nThe GitOps Toolkit Custom Resource Definitions documentation.\nLast modified 2023-07-04:\nGeneralize import-flux2-assets.sh script (070bfee)",
      "code_examples": [],
      "headings": [
        {
          "level": 1,
          "text": "API Reference",
          "id": ""
        },
        {
          "level": 5,
          "text": "Helm API reference v2",
          "id": ""
        }
      ],
      "timestamp": 1750732717.804312
    },
    {
      "url": "https://fluxcd.io/flux/components/helm/api/v2/",
      "title": "Helm API reference v2 | Flux",
      "content": "Docs\nToolkit Components\nHelm Controller\nAPI Reference\nHelm API reference v2\nHelm API reference v2\nThe GitOps Toolkit Custom Resource Definitions documentation.\nPackages:\nhelm.toolkit.fluxcd.io/v2\nhelm.toolkit.fluxcd.io/v2\nPackage v2 contains API Schema definitions for the helm v2 API group\nResource Types:\nHelmRelease\nHelmRelease\nHelmRelease is the Schema for the helmreleases API\nField\nDescription\napiVersion\nstring\nhelm.toolkit.fluxcd.io/v2\nkind\nstring\nHelmRelease\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nHelmReleaseSpec\nchart\nHelmChartTemplate\n(Optional)\nChart defines the template of the v1.HelmChart that should be created\nfor this HelmRelease.\nchartRef\nCrossNamespaceSourceReference\n(Optional)\nChartRef holds a reference to a source controller resource containing the\nHelm chart artifact.\ninterval\nKubernetes meta/v1.Duration\nInterval at which to reconcile the Helm release.\nkubeConfig\ngithub.com/fluxcd/pkg/apis/meta.KubeConfigReference\n(Optional)\nKubeConfig for reconciling the HelmRelease on a remote cluster.\nWhen used in combination with HelmReleaseSpec.ServiceAccountName,\nforces the controller to act on behalf of that Service Account at the\ntarget cluster.\nIf the –default-service-account flag is set, its value will be used as\na controller level fallback for when HelmReleaseSpec.ServiceAccountName\nis empty.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend reconciliation for this HelmRelease,\nit does not apply to already started reconciliations. Defaults to false.\nreleaseName\nstring\n(Optional)\nReleaseName used for the Helm release. Defaults to a composition of\n‘[TargetNamespace-]Name’.\ntargetNamespace\nstring\n(Optional)\nTargetNamespace to target when performing operations for the HelmRelease.\nDefaults to the namespace of the HelmRelease.\nstorageNamespace\nstring\n(Optional)\nStorageNamespace used for the Helm storage.\nDefaults to the namespace of the HelmRelease.\ndependsOn\n[]github.com/fluxcd/pkg/apis/meta.NamespacedObjectReference\n(Optional)\nDependsOn may contain a meta.NamespacedObjectReference slice with\nreferences to HelmRelease resources that must be ready before this HelmRelease\ncan be reconciled.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is the time to wait for any individual Kubernetes operation (like Jobs\nfor hooks) during the performance of a Helm action. Defaults to ‘5m0s’.\nmaxHistory\nint\n(Optional)\nMaxHistory is the number of revisions saved by Helm for this HelmRelease.\nUse ‘0’ for an unlimited number of revisions; defaults to ‘5’.\nserviceAccountName\nstring\n(Optional)\nThe name of the Kubernetes service account to impersonate\nwhen reconciling this HelmRelease.\npersistentClient\nbool\n(Optional)\nPersistentClient tells the controller to use a persistent Kubernetes\nclient for this release. When enabled, the client will be reused for the\nduration of the reconciliation, instead of being created and destroyed\nfor each (step of a) Helm action.\nThis can improve performance, but may cause issues with some Helm charts\nthat for example do create Custom Resource Definitions during installation\noutside Helm’s CRD lifecycle hooks, which are then not observed to be\navailable by e.g. post-install hooks.\nIf not set, it defaults to true.\ndriftDetection\nDriftDetection\n(Optional)\nDriftDetection holds the configuration for detecting and handling\ndifferences between the manifest in the Helm storage and the resources\ncurrently existing in the cluster.\ninstall\nInstall\n(Optional)\nInstall holds the configuration for Helm install actions for this HelmRelease.\nupgrade\nUpgrade\n(Optional)\nUpgrade holds the configuration for Helm upgrade actions for this HelmRelease.\ntest\nTest\n(Optional)\nTest holds the configuration for Helm test actions for this HelmRelease.\nrollback\nRollback\n(Optional)\nRollback holds the configuration for Helm rollback actions for this HelmRelease.\nuninstall\nUninstall\n(Optional)\nUninstall holds the configuration for Helm uninstall actions for this HelmRelease.\nvaluesFrom\n[]github.com/fluxcd/pkg/apis/meta.ValuesReference\nValuesFrom holds references to resources containing Helm values for this HelmRelease,\nand information about how they should be merged.\nvalues\nKubernetes pkg/apis/apiextensions/v1.JSON\n(Optional)\nValues holds the values for this Helm release.\npostRenderers\n[]PostRenderer\n(Optional)\nPostRenderers holds an array of Helm PostRenderers, which will be applied in order\nof their definition.\nstatus\nHelmReleaseStatus\nCRDsPolicy\n(\nstring\nalias)\n(\nAppears on:\nInstall\n,\nUpgrade\n)\nCRDsPolicy defines the install/upgrade approach to use for CRDs when\ninstalling or upgrading a HelmRelease.\nCrossNamespaceObjectReference\n(\nAppears on:\nHelmChartTemplateSpec\n)\nCrossNamespaceObjectReference contains enough information to let you locate\nthe typed referenced object at cluster level.\nField\nDescription\napiVersion\nstring\n(Optional)\nAPIVersion of the referent.\nkind\nstring\nKind of the referent.\nname\nstring\nName of the referent.\nnamespace\nstring\n(Optional)\nNamespace of the referent.\nCrossNamespaceSourceReference\n(\nAppears on:\nHelmReleaseSpec\n)\nCrossNamespaceSourceReference contains enough information to let you locate\nthe typed referenced object at cluster level.\nField\nDescription\napiVersion\nstring\n(Optional)\nAPIVersion of the referent.\nkind\nstring\nKind of the referent.\nname\nstring\nName of the referent.\nnamespace\nstring\n(Optional)\nNamespace of the referent, defaults to the namespace of the Kubernetes\nresource object that contains the reference.\nDriftDetection\n(\nAppears on:\nHelmReleaseSpec\n)\nDriftDetection defines the strategy for performing differential analysis and\nprovides a way to define rules for ignoring specific changes during this\nprocess.\nField\nDescription\nmode\nDriftDetectionMode\n(Optional)\nMode defines how differences should be handled between the Helm manifest\nand the manifest currently applied to the cluster.\nIf not explicitly set, it defaults to DiffModeDisabled.\nignore\n[]IgnoreRule\n(Optional)\nIgnore contains a list of rules for specifying which changes to ignore\nduring diffing.\nDriftDetectionMode\n(\nstring\nalias)\n(\nAppears on:\nDriftDetection\n)\nDriftDetectionMode represents the modes in which a controller can detect and\nhandle differences between the manifest in the Helm storage and the resources\ncurrently existing in the cluster.\nFilter\n(\nAppears on:\nTest\n)\nFilter holds the configuration for individual Helm test filters.\nField\nDescription\nname\nstring\nName is the name of the test.\nexclude\nbool\n(Optional)\nExclude specifies whether the named test should be excluded.\nHelmChartTemplate\n(\nAppears on:\nHelmReleaseSpec\n)\nHelmChartTemplate defines the template from which the controller will\ngenerate a v1.HelmChart object in the same namespace as the referenced\nv1.Source.\nField\nDescription\nmetadata\nHelmChartTemplateObjectMeta\n(Optional)\nObjectMeta holds the template for metadata like labels and annotations.\nspec\nHelmChartTemplateSpec\nSpec holds the template for the v1.HelmChartSpec for this HelmRelease.\nchart\nstring\nThe name or path the Helm chart is available at in the SourceRef.\nversion\nstring\n(Optional)\nVersion semver expression, ignored for charts from v1.GitRepository and\nv1beta2.Bucket sources. Defaults to latest when omitted.\nsourceRef\nCrossNamespaceObjectReference\nThe name and namespace of the v1.Source the chart is available at.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which to check the v1.Source for updates. Defaults to\n‘HelmReleaseSpec.Interval’.\nreconcileStrategy\nstring\n(Optional)\nDetermines what enables the creation of a new artifact. Valid values are\n(‘ChartVersion’, ‘Revision’).\nSee the documentation of the values for an explanation on their behavior.\nDefaults to ChartVersion when omitted.\nvaluesFiles\n[]string\n(Optional)\nAlternative list of values files to use as the chart values (values.yaml\nis not included by default), expected to be a relative path in the SourceRef.\nValues files are merged in the order of this list with the last file overriding\nthe first. Ignored when omitted.\nignoreMissingValuesFiles\nbool\n(Optional)\nIgnoreMissingValuesFiles controls whether to silently ignore missing values files rather than failing.\nverify\nHelmChartTemplateVerification\n(Optional)\nVerify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic.\nThis field is only supported for OCI sources.\nChart dependencies, which are not bundled in the umbrella chart artifact,\nare not verified.\nHelmChartTemplateObjectMeta\n(\nAppears on:\nHelmChartTemplate\n)\nHelmChartTemplateObjectMeta defines the template for the ObjectMeta of a\nv1.HelmChart.\nField\nDescription\nlabels\nmap[string]string\n(Optional)\nMap of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info:\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\nannotations\nmap[string]string\n(Optional)\nAnnotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info:\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/\nHelmChartTemplateSpec\n(\nAppears on:\nHelmChartTemplate\n)\nHelmChartTemplateSpec defines the template from which the controller will\ngenerate a v1.HelmChartSpec object.\nField\nDescription\nchart\nstring\nThe name or path the Helm chart is available at in the SourceRef.\nversion\nstring\n(Optional)\nVersion semver expression, ignored for charts from v1.GitRepository and\nv1beta2.Bucket sources. Defaults to latest when omitted.\nsourceRef\nCrossNamespaceObjectReference\nThe name and namespace of the v1.Source the chart is available at.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which to check the v1.Source for updates. Defaults to\n‘HelmReleaseSpec.Interval’.\nreconcileStrategy\nstring\n(Optional)\nDetermines what enables the creation of a new artifact. Valid values are\n(‘ChartVersion’, ‘Revision’).\nSee the documentation of the values for an explanation on their behavior.\nDefaults to ChartVersion when omitted.\nvaluesFiles\n[]string\n(Optional)\nAlternative list of values files to use as the chart values (values.yaml\nis not included by default), expected to be a relative path in the SourceRef.\nValues files are merged in the order of this list with the last file overriding\nthe first. Ignored when omitted.\nignoreMissingValuesFiles\nbool\n(Optional)\nIgnoreMissingValuesFiles controls whether to silently ignore missing values files rather than failing.\nverify\nHelmChartTemplateVerification\n(Optional)\nVerify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic.\nThis field is only supported for OCI sources.\nChart dependencies, which are not bundled in the umbrella chart artifact,\nare not verified.\nHelmChartTemplateVerification\n(\nAppears on:\nHelmChartTemplateSpec\n)\nHelmChartTemplateVerification verifies the authenticity of an OCI Helm chart.\nField\nDescription\nprovider\nstring\nProvider specifies the technology used to sign the OCI Helm chart.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Kubernetes Secret containing the\ntrusted public keys.\nHelmReleaseSpec\n(\nAppears on:\nHelmRelease\n)\nHelmReleaseSpec defines the desired state of a Helm release.\nField\nDescription\nchart\nHelmChartTemplate\n(Optional)\nChart defines the template of the v1.HelmChart that should be created\nfor this HelmRelease.\nchartRef\nCrossNamespaceSourceReference\n(Optional)\nChartRef holds a reference to a source controller resource containing the\nHelm chart artifact.\ninterval\nKubernetes meta/v1.Duration\nInterval at which to reconcile the Helm release.\nkubeConfig\ngithub.com/fluxcd/pkg/apis/meta.KubeConfigReference\n(Optional)\nKubeConfig for reconciling the HelmRelease on a remote cluster.\nWhen used in combination with HelmReleaseSpec.ServiceAccountName,\nforces the controller to act on behalf of that Service Account at the\ntarget cluster.\nIf the –default-service-account flag is set, its value will be used as\na controller level fallback for when HelmReleaseSpec.ServiceAccountName\nis empty.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend reconciliation for this HelmRelease,\nit does not apply to already started reconciliations. Defaults to false.\nreleaseName\nstring\n(Optional)\nReleaseName used for the Helm release. Defaults to a composition of\n‘[TargetNamespace-]Name’.\ntargetNamespace\nstring\n(Optional)\nTargetNamespace to target when performing operations for the HelmRelease.\nDefaults to the namespace of the HelmRelease.\nstorageNamespace\nstring\n(Optional)\nStorageNamespace used for the Helm storage.\nDefaults to the namespace of the HelmRelease.\ndependsOn\n[]github.com/fluxcd/pkg/apis/meta.NamespacedObjectReference\n(Optional)\nDependsOn may contain a meta.NamespacedObjectReference slice with\nreferences to HelmRelease resources that must be ready before this HelmRelease\ncan be reconciled.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is the time to wait for any individual Kubernetes operation (like Jobs\nfor hooks) during the performance of a Helm action. Defaults to ‘5m0s’.\nmaxHistory\nint\n(Optional)\nMaxHistory is the number of revisions saved by Helm for this HelmRelease.\nUse ‘0’ for an unlimited number of revisions; defaults to ‘5’.\nserviceAccountName\nstring\n(Optional)\nThe name of the Kubernetes service account to impersonate\nwhen reconciling this HelmRelease.\npersistentClient\nbool\n(Optional)\nPersistentClient tells the controller to use a persistent Kubernetes\nclient for this release. When enabled, the client will be reused for the\nduration of the reconciliation, instead of being created and destroyed\nfor each (step of a) Helm action.\nThis can improve performance, but may cause issues with some Helm charts\nthat for example do create Custom Resource Definitions during installation\noutside Helm’s CRD lifecycle hooks, which are then not observed to be\navailable by e.g. post-install hooks.\nIf not set, it defaults to true.\ndriftDetection\nDriftDetection\n(Optional)\nDriftDetection holds the configuration for detecting and handling\ndifferences between the manifest in the Helm storage and the resources\ncurrently existing in the cluster.\ninstall\nInstall\n(Optional)\nInstall holds the configuration for Helm install actions for this HelmRelease.\nupgrade\nUpgrade\n(Optional)\nUpgrade holds the configuration for Helm upgrade actions for this HelmRelease.\ntest\nTest\n(Optional)\nTest holds the configuration for Helm test actions for this HelmRelease.\nrollback\nRollback\n(Optional)\nRollback holds the configuration for Helm rollback actions for this HelmRelease.\nuninstall\nUninstall\n(Optional)\nUninstall holds the configuration for Helm uninstall actions for this HelmRelease.\nvaluesFrom\n[]github.com/fluxcd/pkg/apis/meta.ValuesReference\nValuesFrom holds references to resources containing Helm values for this HelmRelease,\nand information about how they should be merged.\nvalues\nKubernetes pkg/apis/apiextensions/v1.JSON\n(Optional)\nValues holds the values for this Helm release.\npostRenderers\n[]PostRenderer\n(Optional)\nPostRenderers holds an array of Helm PostRenderers, which will be applied in order\nof their definition.\nHelmReleaseStatus\n(\nAppears on:\nHelmRelease\n)\nHelmReleaseStatus defines the observed state of a HelmRelease.\nField\nDescription\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last observed generation.\nobservedPostRenderersDigest\nstring\n(Optional)\nObservedPostRenderersDigest is the digest for the post-renderers of\nthe last successful reconciliation attempt.\nlastAttemptedGeneration\nint64\n(Optional)\nLastAttemptedGeneration is the last generation the controller attempted\nto reconcile.\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nConditions holds the conditions for the HelmRelease.\nhelmChart\nstring\n(Optional)\nHelmChart is the namespaced name of the HelmChart resource created by\nthe controller for the HelmRelease.\nstorageNamespace\nstring\n(Optional)\nStorageNamespace is the namespace of the Helm release storage for the\ncurrent release.\nhistory\nSnapshots\n(Optional)\nHistory holds the history of Helm releases performed for this HelmRelease\nup to the last successfully completed release.\nlastAttemptedReleaseAction\nReleaseAction\n(Optional)\nLastAttemptedReleaseAction is the last release action performed for this\nHelmRelease. It is used to determine the active remediation strategy.\nfailures\nint64\n(Optional)\nFailures is the reconciliation failure count against the latest desired\nstate. It is reset after a successful reconciliation.\ninstallFailures\nint64\n(Optional)\nInstallFailures is the install failure count against the latest desired\nstate. It is reset after a successful reconciliation.\nupgradeFailures\nint64\n(Optional)\nUpgradeFailures is the upgrade failure count against the latest desired\nstate. It is reset after a successful reconciliation.\nlastAttemptedRevision\nstring\n(Optional)\nLastAttemptedRevision is the Source revision of the last reconciliation\nattempt. For OCIRepository sources, the 12 first characters of the digest are\nappended to the chart version e.g. “1.2.3+1234567890ab”.\nlastAttemptedRevisionDigest\nstring\n(Optional)\nLastAttemptedRevisionDigest is the digest of the last reconciliation attempt.\nThis is only set for OCIRepository sources.\nlastAttemptedValuesChecksum\nstring\n(Optional)\nLastAttemptedValuesChecksum is the SHA1 checksum for the values of the last\nreconciliation attempt.\nDeprecated: Use LastAttemptedConfigDigest instead.\nlastReleaseRevision\nint\n(Optional)\nLastReleaseRevision is the revision of the last successful Helm release.\nDeprecated: Use History instead.\nlastAttemptedConfigDigest\nstring\n(Optional)\nLastAttemptedConfigDigest is the digest for the config (better known as\n“values”) of the last reconciliation attempt.\nlastHandledForceAt\nstring\n(Optional)\nLastHandledForceAt holds the value of the most recent force request\nvalue, so a change of the annotation value can be detected.\nlastHandledResetAt\nstring\n(Optional)\nLastHandledResetAt holds the value of the most recent reset request\nvalue, so a change of the annotation value can be detected.\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nIgnoreRule\n(\nAppears on:\nDriftDetection\n)\nIgnoreRule defines a rule to selectively disregard specific changes during\nthe drift detection process.\nField\nDescription\npaths\n[]string\nPaths is a list of JSON Pointer (RFC 6901) paths to be excluded from\nconsideration in a Kubernetes object.\ntarget\ngithub.com/fluxcd/pkg/apis/kustomize.Selector\n(Optional)\nTarget is a selector for specifying Kubernetes objects to which this\nrule applies.\nIf Target is not set, the Paths will be ignored for all Kubernetes\nobjects within the manifest of the Helm release.\nInstall\n(\nAppears on:\nHelmReleaseSpec\n)\nInstall holds the configuration for Helm install actions performed for this\nHelmRelease.\nField\nDescription\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is the time to wait for any individual Kubernetes operation (like\nJobs for hooks) during the performance of a Helm install action. Defaults to\n‘HelmReleaseSpec.Timeout’.\nremediation\nInstallRemediation\n(Optional)\nRemediation holds the remediation configuration for when the Helm install\naction for the HelmRelease fails. The default is to not perform any action.\ndisableTakeOwnership\nbool\n(Optional)\nDisableTakeOwnership disables taking ownership of existing resources\nduring the Helm install action. Defaults to false.\ndisableWait\nbool\n(Optional)\nDisableWait disables the waiting for resources to be ready after a Helm\ninstall has been performed.\ndisableWaitForJobs\nbool\n(Optional)\nDisableWaitForJobs disables waiting for jobs to complete after a Helm\ninstall has been performed.\ndisableHooks\nbool\n(Optional)\nDisableHooks prevents hooks from running during the Helm install action.\ndisableOpenAPIValidation\nbool\n(Optional)\nDisableOpenAPIValidation prevents the Helm install action from validating\nrendered templates against the Kubernetes OpenAPI Schema.\ndisableSchemaValidation\nbool\n(Optional)\nDisableSchemaValidation prevents the Helm install action from validating\nthe values against the JSON Schema.\nreplace\nbool\n(Optional)\nReplace tells the Helm install action to re-use the ‘ReleaseName’, but only\nif that name is a deleted release which remains in the history.\nskipCRDs\nbool\n(Optional)\nSkipCRDs tells the Helm install action to not install any CRDs. By default,\nCRDs are installed if not already present.\nDeprecated use CRD policy (\ncrds\n) attribute with value\nSkip\ninstead.\ncrds\nCRDsPolicy\n(Optional)\nCRDs upgrade CRDs from the Helm Chart’s crds directory according\nto the CRD upgrade policy provided here. Valid values are\nSkip\n,\nCreate\nor\nCreateReplace\n. Default is\nCreate\nand if omitted\nCRDs are installed but not updated.\nSkip: do neither install nor replace (update) any CRDs.\nCreate: new CRDs are created, existing CRDs are neither updated nor deleted.\nCreateReplace: new CRDs are created, existing CRDs are updated (replaced)\nbut not deleted.\nBy default, CRDs are applied (installed) during Helm install action.\nWith this option users can opt in to CRD replace existing CRDs on Helm\ninstall actions, which is not (yet) natively supported by Helm.\nhttps://helm.sh/docs/chart_best_practices/custom_resource_definitions\n.\ncreateNamespace\nbool\n(Optional)\nCreateNamespace tells the Helm install action to create the\nHelmReleaseSpec.TargetNamespace if it does not exist yet.\nOn uninstall, the namespace will not be garbage collected.\nInstallRemediation\n(\nAppears on:\nInstall\n)\nInstallRemediation holds the configuration for Helm install remediation.\nField\nDescription\nretries\nint\n(Optional)\nRetries is the number of retries that should be attempted on failures before\nbailing. Remediation, using an uninstall, is performed between each attempt.\nDefaults to ‘0’, a negative integer equals to unlimited retries.\nignoreTestFailures\nbool\n(Optional)\nIgnoreTestFailures tells the controller to skip remediation when the Helm\ntests are run after an install action but fail. Defaults to\n‘Test.IgnoreFailures’.\nremediateLastFailure\nbool\n(Optional)\nRemediateLastFailure tells the controller to remediate the last failure, when\nno retries remain. Defaults to ‘false’.\nKustomize\n(\nAppears on:\nPostRenderer\n)\nKustomize Helm PostRenderer specification.\nField\nDescription\npatches\n[]github.com/fluxcd/pkg/apis/kustomize.Patch\n(Optional)\nStrategic merge and JSON patches, defined as inline YAML objects,\ncapable of targeting objects based on kind, label and annotation selectors.\nimages\n[]github.com/fluxcd/pkg/apis/kustomize.Image\n(Optional)\nImages is a list of (image name, new name, new tag or digest)\nfor changing image names, tags or digests. This can also be achieved with a\npatch, but this operator is simpler to specify.\nPostRenderer\n(\nAppears on:\nHelmReleaseSpec\n)\nPostRenderer contains a Helm PostRenderer specification.\nField\nDescription\nkustomize\nKustomize\n(Optional)\nKustomization to apply as PostRenderer.\nReleaseAction\n(\nstring\nalias)\n(\nAppears on:\nHelmReleaseStatus\n)\nReleaseAction is the action to perform a Helm release.\nRemediation\nRemediation defines a consistent interface for InstallRemediation and\nUpgradeRemediation.\nRemediationStrategy\n(\nstring\nalias)\n(\nAppears on:\nUpgradeRemediation\n)\nRemediationStrategy returns the strategy to use to remediate a failed install\nor upgrade.\nRollback\n(\nAppears on:\nHelmReleaseSpec\n)\nRollback holds the configuration for Helm rollback actions for this\nHelmRelease.\nField\nDescription\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is the time to wait for any individual Kubernetes operation (like\nJobs for hooks) during the performance of a Helm rollback action. Defaults to\n‘HelmReleaseSpec.Timeout’.\ndisableWait\nbool\n(Optional)\nDisableWait disables the waiting for resources to be ready after a Helm\nrollback has been performed.\ndisableWaitForJobs\nbool\n(Optional)\nDisableWaitForJobs disables waiting for jobs to complete after a Helm\nrollback has been performed.\ndisableHooks\nbool\n(Optional)\nDisableHooks prevents hooks from running during the Helm rollback action.\nrecreate\nbool\n(Optional)\nRecreate performs pod restarts for the resource if applicable.\nforce\nbool\n(Optional)\nForce forces resource updates through a replacement strategy.\ncleanupOnFail\nbool\n(Optional)\nCleanupOnFail allows deletion of new resources created during the Helm\nrollback action when it fails.\nSnapshot\nSnapshot captures a point-in-time copy of the status information for a Helm release,\nas managed by the controller.\nField\nDescription\napiVersion\nstring\n(Optional)\nAPIVersion is the API version of the Snapshot.\nProvisional: when the calculation method of the Digest field is changed,\nthis field will be used to distinguish between the old and new methods.\ndigest\nstring\nDigest is the checksum of the release object in storage.\nIt has the format of\n<algo>:<checksum>\n.\nname\nstring\nName is the name of the release.\nnamespace\nstring\nNamespace is the namespace the release is deployed to.\nversion\nint\nVersion is the version of the release object in storage.\nstatus\nstring\nStatus is the current state of the release.\nchartName\nstring\nChartName is the chart name of the release object in storage.\nchartVersion\nstring\nChartVersion is the chart version of the release object in\nstorage.\nappVersion\nstring\n(Optional)\nAppVersion is the chart app version of the release object in storage.\nconfigDigest\nstring\nConfigDigest is the checksum of the config (better known as\n“values”) of the release object in storage.\nIt has the format of\n<algo>:<checksum>\n.\nfirstDeployed\nKubernetes meta/v1.Time\nFirstDeployed is when the release was first deployed.\nlastDeployed\nKubernetes meta/v1.Time\nLastDeployed is when the release was last deployed.\ndeleted\nKubernetes meta/v1.Time\n(Optional)\nDeleted is when the release was deleted.\ntestHooks\nTestHookStatus\n(Optional)\nTestHooks is the list of test hooks for the release as observed to be\nrun by the controller.\nociDigest\nstring\n(Optional)\nOCIDigest is the digest of the OCI artifact associated with the release.\nSnapshots\n(\n[]*./api/v2.Snapshot\nalias)\n(\nAppears on:\nHelmReleaseStatus\n)\nSnapshots is a list of Snapshot objects.\nTest\n(\nAppears on:\nHelmReleaseSpec\n)\nTest holds the configuration for Helm test actions for this HelmRelease.\nField\nDescription\nenable\nbool\n(Optional)\nEnable enables Helm test actions for this HelmRelease after an Helm install\nor upgrade action has been performed.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is the time to wait for any individual Kubernetes operation during\nthe performance of a Helm test action. Defaults to ‘HelmReleaseSpec.Timeout’.\nignoreFailures\nbool\n(Optional)\nIgnoreFailures tells the controller to skip remediation when the Helm tests\nare run but fail. Can be overwritten for tests run after install or upgrade\nactions in ‘Install.IgnoreTestFailures’ and ‘Upgrade.IgnoreTestFailures’.\nfilters\nFilter\nFilters is a list of tests to run or exclude from running.\nTestHookStatus\n(\nAppears on:\nSnapshot\n)\nTestHookStatus holds the status information for a test hook as observed\nto be run by the controller.\nField\nDescription\nlastStarted\nKubernetes meta/v1.Time\n(Optional)\nLastStarted is the time the test hook was last started.\nlastCompleted\nKubernetes meta/v1.Time\n(Optional)\nLastCompleted is the time the test hook last completed.\nphase\nstring\n(Optional)\nPhase the test hook was observed to be in.\nUninstall\n(\nAppears on:\nHelmReleaseSpec\n)\nUninstall holds the configuration for Helm uninstall actions for this\nHelmRelease.\nField\nDescription\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is the time to wait for any individual Kubernetes operation (like\nJobs for hooks) during the performance of a Helm uninstall action. Defaults\nto ‘HelmReleaseSpec.Timeout’.\ndisableHooks\nbool\n(Optional)\nDisableHooks prevents hooks from running during the Helm rollback action.\nkeepHistory\nbool\n(Optional)\nKeepHistory tells Helm to remove all associated resources and mark the\nrelease as deleted, but retain the release history.\ndisableWait\nbool\n(Optional)\nDisableWait disables waiting for all the resources to be deleted after\na Helm uninstall is performed.\ndeletionPropagation\nstring\n(Optional)\nDeletionPropagation specifies the deletion propagation policy when\na Helm uninstall is performed.\nUpgrade\n(\nAppears on:\nHelmReleaseSpec\n)\nUpgrade holds the configuration for Helm upgrade actions for this\nHelmRelease.\nField\nDescription\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout is the time to wait for any individual Kubernetes operation (like\nJobs for hooks) during the performance of a Helm upgrade action. Defaults to\n‘HelmReleaseSpec.Timeout’.\nremediation\nUpgradeRemediation\n(Optional)\nRemediation holds the remediation configuration for when the Helm upgrade\naction for the HelmRelease fails. The default is to not perform any action.\ndisableTakeOwnership\nbool\n(Optional)\nDisableTakeOwnership disables taking ownership of existing resources\nduring the Helm upgrade action. Defaults to false.\ndisableWait\nbool\n(Optional)\nDisableWait disables the waiting for resources to be ready after a Helm\nupgrade has been performed.\ndisableWaitForJobs\nbool\n(Optional)\nDisableWaitForJobs disables waiting for jobs to complete after a Helm\nupgrade has been performed.\ndisableHooks\nbool\n(Optional)\nDisableHooks prevents hooks from running during the Helm upgrade action.\ndisableOpenAPIValidation\nbool\n(Optional)\nDisableOpenAPIValidation prevents the Helm upgrade action from validating\nrendered templates against the Kubernetes OpenAPI Schema.\ndisableSchemaValidation\nbool\n(Optional)\nDisableSchemaValidation prevents the Helm upgrade action from validating\nthe values against the JSON Schema.\nforce\nbool\n(Optional)\nForce forces resource updates through a replacement strategy.\npreserveValues\nbool\n(Optional)\nPreserveValues will make Helm reuse the last release’s values and merge in\noverrides from ‘Values’. Setting this flag makes the HelmRelease\nnon-declarative.\ncleanupOnFail\nbool\n(Optional)\nCleanupOnFail allows deletion of new resources created during the Helm\nupgrade action when it fails.\ncrds\nCRDsPolicy\n(Optional)\nCRDs upgrade CRDs from the Helm Chart’s crds directory according\nto the CRD upgrade policy provided here. Valid values are\nSkip\n,\nCreate\nor\nCreateReplace\n. Default is\nSkip\nand if omitted\nCRDs are neither installed nor upgraded.\nSkip: do neither install nor replace (update) any CRDs.\nCreate: new CRDs are created, existing CRDs are neither updated nor deleted.\nCreateReplace: new CRDs are created, existing CRDs are updated (replaced)\nbut not deleted.\nBy default, CRDs are not applied during Helm upgrade action. With this\noption users can opt-in to CRD upgrade, which is not (yet) natively supported by Helm.\nhttps://helm.sh/docs/chart_best_practices/custom_resource_definitions\n.\nUpgradeRemediation\n(\nAppears on:\nUpgrade\n)\nUpgradeRemediation holds the configuration for Helm upgrade remediation.\nField\nDescription\nretries\nint\n(Optional)\nRetries is the number of retries that should be attempted on failures before\nbailing. Remediation, using ‘Strategy’, is performed between each attempt.\nDefaults to ‘0’, a negative integer equals to unlimited retries.\nignoreTestFailures\nbool\n(Optional)\nIgnoreTestFailures tells the controller to skip remediation when the Helm\ntests are run after an upgrade action but fail.\nDefaults to ‘Test.IgnoreFailures’.\nremediateLastFailure\nbool\n(Optional)\nRemediateLastFailure tells the controller to remediate the last failure, when\nno retries remain. Defaults to ‘false’ unless ‘Retries’ is greater than 0.\nstrategy\nRemediationStrategy\n(Optional)\nStrategy to use for failure remediation. Defaults to ‘rollback’.\nThis page was automatically generated with\ngen-crd-api-reference-docs",
      "code_examples": [
        {
          "language": "",
          "code": "helm.toolkit.fluxcd.io/v2",
          "element": "<code>helm.toolkit.fluxcd.io/v2</code>"
        },
        {
          "language": "",
          "code": "HelmRelease",
          "element": "<code>HelmRelease</code>"
        },
        {
          "language": "",
          "code": "releaseName",
          "element": "<code>releaseName</code>"
        },
        {
          "language": "",
          "code": "targetNamespace",
          "element": "<code>targetNamespace</code>"
        },
        {
          "language": "",
          "code": "storageNamespace",
          "element": "<code>storageNamespace</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "persistentClient",
          "element": "<code>persistentClient</code>"
        },
        {
          "language": "",
          "code": "driftDetection",
          "element": "<code>driftDetection</code>"
        },
        {
          "language": "",
          "code": "postRenderers",
          "element": "<code>postRenderers</code>"
        },
        {
          "language": "",
          "code": "reconcileStrategy",
          "element": "<code>reconcileStrategy</code>"
        },
        {
          "language": "",
          "code": "valuesFiles",
          "element": "<code>valuesFiles</code>"
        },
        {
          "language": "",
          "code": "ignoreMissingValuesFiles",
          "element": "<code>ignoreMissingValuesFiles</code>"
        },
        {
          "language": "",
          "code": "annotations",
          "element": "<code>annotations</code>"
        },
        {
          "language": "",
          "code": "reconcileStrategy",
          "element": "<code>reconcileStrategy</code>"
        },
        {
          "language": "",
          "code": "valuesFiles",
          "element": "<code>valuesFiles</code>"
        },
        {
          "language": "",
          "code": "ignoreMissingValuesFiles",
          "element": "<code>ignoreMissingValuesFiles</code>"
        },
        {
          "language": "",
          "code": "releaseName",
          "element": "<code>releaseName</code>"
        },
        {
          "language": "",
          "code": "targetNamespace",
          "element": "<code>targetNamespace</code>"
        },
        {
          "language": "",
          "code": "storageNamespace",
          "element": "<code>storageNamespace</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "persistentClient",
          "element": "<code>persistentClient</code>"
        },
        {
          "language": "",
          "code": "driftDetection",
          "element": "<code>driftDetection</code>"
        },
        {
          "language": "",
          "code": "postRenderers",
          "element": "<code>postRenderers</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "observedPostRenderersDigest",
          "element": "<code>observedPostRenderersDigest</code>"
        },
        {
          "language": "",
          "code": "lastAttemptedGeneration",
          "element": "<code>lastAttemptedGeneration</code>"
        },
        {
          "language": "",
          "code": "storageNamespace",
          "element": "<code>storageNamespace</code>"
        },
        {
          "language": "",
          "code": "lastAttemptedReleaseAction",
          "element": "<code>lastAttemptedReleaseAction</code>"
        },
        {
          "language": "",
          "code": "installFailures",
          "element": "<code>installFailures</code>"
        },
        {
          "language": "",
          "code": "upgradeFailures",
          "element": "<code>upgradeFailures</code>"
        },
        {
          "language": "",
          "code": "lastAttemptedRevision",
          "element": "<code>lastAttemptedRevision</code>"
        },
        {
          "language": "",
          "code": "lastAttemptedRevisionDigest",
          "element": "<code>lastAttemptedRevisionDigest</code>"
        },
        {
          "language": "",
          "code": "lastAttemptedValuesChecksum",
          "element": "<code>lastAttemptedValuesChecksum</code>"
        },
        {
          "language": "",
          "code": "lastReleaseRevision",
          "element": "<code>lastReleaseRevision</code>"
        },
        {
          "language": "",
          "code": "lastAttemptedConfigDigest",
          "element": "<code>lastAttemptedConfigDigest</code>"
        },
        {
          "language": "",
          "code": "lastHandledForceAt",
          "element": "<code>lastHandledForceAt</code>"
        },
        {
          "language": "",
          "code": "lastHandledResetAt",
          "element": "<code>lastHandledResetAt</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "remediation",
          "element": "<code>remediation</code>"
        },
        {
          "language": "",
          "code": "disableTakeOwnership",
          "element": "<code>disableTakeOwnership</code>"
        },
        {
          "language": "",
          "code": "disableWait",
          "element": "<code>disableWait</code>"
        },
        {
          "language": "",
          "code": "disableWaitForJobs",
          "element": "<code>disableWaitForJobs</code>"
        },
        {
          "language": "",
          "code": "disableHooks",
          "element": "<code>disableHooks</code>"
        },
        {
          "language": "",
          "code": "disableOpenAPIValidation",
          "element": "<code>disableOpenAPIValidation</code>"
        },
        {
          "language": "",
          "code": "disableSchemaValidation",
          "element": "<code>disableSchemaValidation</code>"
        },
        {
          "language": "",
          "code": "CreateReplace",
          "element": "<code>CreateReplace</code>"
        },
        {
          "language": "",
          "code": "createNamespace",
          "element": "<code>createNamespace</code>"
        },
        {
          "language": "",
          "code": "ignoreTestFailures",
          "element": "<code>ignoreTestFailures</code>"
        },
        {
          "language": "",
          "code": "remediateLastFailure",
          "element": "<code>remediateLastFailure</code>"
        },
        {
          "language": "",
          "code": "disableWait",
          "element": "<code>disableWait</code>"
        },
        {
          "language": "",
          "code": "disableWaitForJobs",
          "element": "<code>disableWaitForJobs</code>"
        },
        {
          "language": "",
          "code": "disableHooks",
          "element": "<code>disableHooks</code>"
        },
        {
          "language": "",
          "code": "cleanupOnFail",
          "element": "<code>cleanupOnFail</code>"
        },
        {
          "language": "",
          "code": "<algo>:<checksum>",
          "element": "<code>&lt;algo&gt;:&lt;checksum&gt;</code>"
        },
        {
          "language": "",
          "code": "chartVersion",
          "element": "<code>chartVersion</code>"
        },
        {
          "language": "",
          "code": "configDigest",
          "element": "<code>configDigest</code>"
        },
        {
          "language": "",
          "code": "<algo>:<checksum>",
          "element": "<code>&lt;algo&gt;:&lt;checksum&gt;</code>"
        },
        {
          "language": "",
          "code": "firstDeployed",
          "element": "<code>firstDeployed</code>"
        },
        {
          "language": "",
          "code": "lastDeployed",
          "element": "<code>lastDeployed</code>"
        },
        {
          "language": "",
          "code": "[]*./api/v2.Snapshot",
          "element": "<code>[]*./api/v2.Snapshot</code>"
        },
        {
          "language": "",
          "code": "ignoreFailures",
          "element": "<code>ignoreFailures</code>"
        },
        {
          "language": "",
          "code": "lastStarted",
          "element": "<code>lastStarted</code>"
        },
        {
          "language": "",
          "code": "lastCompleted",
          "element": "<code>lastCompleted</code>"
        },
        {
          "language": "",
          "code": "disableHooks",
          "element": "<code>disableHooks</code>"
        },
        {
          "language": "",
          "code": "keepHistory",
          "element": "<code>keepHistory</code>"
        },
        {
          "language": "",
          "code": "disableWait",
          "element": "<code>disableWait</code>"
        },
        {
          "language": "",
          "code": "deletionPropagation",
          "element": "<code>deletionPropagation</code>"
        },
        {
          "language": "",
          "code": "remediation",
          "element": "<code>remediation</code>"
        },
        {
          "language": "",
          "code": "disableTakeOwnership",
          "element": "<code>disableTakeOwnership</code>"
        },
        {
          "language": "",
          "code": "disableWait",
          "element": "<code>disableWait</code>"
        },
        {
          "language": "",
          "code": "disableWaitForJobs",
          "element": "<code>disableWaitForJobs</code>"
        },
        {
          "language": "",
          "code": "disableHooks",
          "element": "<code>disableHooks</code>"
        },
        {
          "language": "",
          "code": "disableOpenAPIValidation",
          "element": "<code>disableOpenAPIValidation</code>"
        },
        {
          "language": "",
          "code": "disableSchemaValidation",
          "element": "<code>disableSchemaValidation</code>"
        },
        {
          "language": "",
          "code": "preserveValues",
          "element": "<code>preserveValues</code>"
        },
        {
          "language": "",
          "code": "cleanupOnFail",
          "element": "<code>cleanupOnFail</code>"
        },
        {
          "language": "",
          "code": "CreateReplace",
          "element": "<code>CreateReplace</code>"
        },
        {
          "language": "",
          "code": "ignoreTestFailures",
          "element": "<code>ignoreTestFailures</code>"
        },
        {
          "language": "",
          "code": "remediateLastFailure",
          "element": "<code>remediateLastFailure</code>"
        },
        {
          "language": "",
          "code": "gen-crd-api-reference-docs",
          "element": "<code>gen-crd-api-reference-docs</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Helm API reference v2",
          "id": ""
        },
        {
          "level": 2,
          "text": "helm.toolkit.fluxcd.io/v2",
          "id": "helm.toolkit.fluxcd.io/v2"
        },
        {
          "level": 3,
          "text": "HelmRelease",
          "id": "helm.toolkit.fluxcd.io/v2.HelmRelease"
        },
        {
          "level": 3,
          "text": "CRDsPolicy\n(stringalias)",
          "id": "helm.toolkit.fluxcd.io/v2.CRDsPolicy"
        },
        {
          "level": 3,
          "text": "CrossNamespaceObjectReference",
          "id": "helm.toolkit.fluxcd.io/v2.CrossNamespaceObjectReference"
        },
        {
          "level": 3,
          "text": "CrossNamespaceSourceReference",
          "id": "helm.toolkit.fluxcd.io/v2.CrossNamespaceSourceReference"
        },
        {
          "level": 3,
          "text": "DriftDetection",
          "id": "helm.toolkit.fluxcd.io/v2.DriftDetection"
        },
        {
          "level": 3,
          "text": "DriftDetectionMode\n(stringalias)",
          "id": "helm.toolkit.fluxcd.io/v2.DriftDetectionMode"
        },
        {
          "level": 3,
          "text": "Filter",
          "id": "helm.toolkit.fluxcd.io/v2.Filter"
        },
        {
          "level": 3,
          "text": "HelmChartTemplate",
          "id": "helm.toolkit.fluxcd.io/v2.HelmChartTemplate"
        },
        {
          "level": 3,
          "text": "HelmChartTemplateObjectMeta",
          "id": "helm.toolkit.fluxcd.io/v2.HelmChartTemplateObjectMeta"
        },
        {
          "level": 3,
          "text": "HelmChartTemplateSpec",
          "id": "helm.toolkit.fluxcd.io/v2.HelmChartTemplateSpec"
        },
        {
          "level": 3,
          "text": "HelmChartTemplateVerification",
          "id": "helm.toolkit.fluxcd.io/v2.HelmChartTemplateVerification"
        },
        {
          "level": 3,
          "text": "HelmReleaseSpec",
          "id": "helm.toolkit.fluxcd.io/v2.HelmReleaseSpec"
        },
        {
          "level": 3,
          "text": "HelmReleaseStatus",
          "id": "helm.toolkit.fluxcd.io/v2.HelmReleaseStatus"
        },
        {
          "level": 3,
          "text": "IgnoreRule",
          "id": "helm.toolkit.fluxcd.io/v2.IgnoreRule"
        },
        {
          "level": 3,
          "text": "Install",
          "id": "helm.toolkit.fluxcd.io/v2.Install"
        },
        {
          "level": 3,
          "text": "InstallRemediation",
          "id": "helm.toolkit.fluxcd.io/v2.InstallRemediation"
        },
        {
          "level": 3,
          "text": "Kustomize",
          "id": "helm.toolkit.fluxcd.io/v2.Kustomize"
        },
        {
          "level": 3,
          "text": "PostRenderer",
          "id": "helm.toolkit.fluxcd.io/v2.PostRenderer"
        },
        {
          "level": 3,
          "text": "ReleaseAction\n(stringalias)",
          "id": "helm.toolkit.fluxcd.io/v2.ReleaseAction"
        },
        {
          "level": 3,
          "text": "Remediation",
          "id": "helm.toolkit.fluxcd.io/v2.Remediation"
        },
        {
          "level": 3,
          "text": "RemediationStrategy\n(stringalias)",
          "id": "helm.toolkit.fluxcd.io/v2.RemediationStrategy"
        },
        {
          "level": 3,
          "text": "Rollback",
          "id": "helm.toolkit.fluxcd.io/v2.Rollback"
        },
        {
          "level": 3,
          "text": "Snapshot",
          "id": "helm.toolkit.fluxcd.io/v2.Snapshot"
        },
        {
          "level": 3,
          "text": "Snapshots\n([]*./api/v2.Snapshotalias)",
          "id": "helm.toolkit.fluxcd.io/v2.Snapshots"
        },
        {
          "level": 3,
          "text": "Test",
          "id": "helm.toolkit.fluxcd.io/v2.Test"
        },
        {
          "level": 3,
          "text": "TestHookStatus",
          "id": "helm.toolkit.fluxcd.io/v2.TestHookStatus"
        },
        {
          "level": 3,
          "text": "Uninstall",
          "id": "helm.toolkit.fluxcd.io/v2.Uninstall"
        },
        {
          "level": 3,
          "text": "Upgrade",
          "id": "helm.toolkit.fluxcd.io/v2.Upgrade"
        },
        {
          "level": 3,
          "text": "UpgradeRemediation",
          "id": "helm.toolkit.fluxcd.io/v2.UpgradeRemediation"
        }
      ],
      "timestamp": 1750732720.837884
    },
    {
      "url": "https://fluxcd.io/flux/components/notification/api/",
      "title": "API Reference | Flux",
      "content": "Docs\nToolkit Components\nNotification Controller\nAPI Reference\nAPI Reference\nNotification API reference v1\nThe GitOps Toolkit Custom Resource Definitions documentation.\nNotification API reference v1beta3\nThe GitOps Toolkit Custom Resource Definitions documentation.\nLast modified 2023-03-23:\nGA: adapt to SC, NC and KC APIs graduating to v1 (3d32a85)",
      "code_examples": [],
      "headings": [
        {
          "level": 1,
          "text": "API Reference",
          "id": ""
        },
        {
          "level": 5,
          "text": "Notification API reference v1",
          "id": ""
        },
        {
          "level": 5,
          "text": "Notification API reference v1beta3",
          "id": ""
        }
      ],
      "timestamp": 1750732723.891598
    },
    {
      "url": "https://fluxcd.io/flux/components/notification/api/v1/",
      "title": "Notification API reference v1 | Flux",
      "content": "Docs\nToolkit Components\nNotification Controller\nAPI Reference\nNotification API reference v1\nNotification API reference v1\nThe GitOps Toolkit Custom Resource Definitions documentation.\nPackages:\nnotification.toolkit.fluxcd.io/v1\nnotification.toolkit.fluxcd.io/v1\nPackage v1 contains API Schema definitions for the notification v1 API group.\nResource Types:\nReceiver\nReceiver\nReceiver is the Schema for the receivers API.\nField\nDescription\napiVersion\nstring\nnotification.toolkit.fluxcd.io/v1\nkind\nstring\nReceiver\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nReceiverSpec\ntype\nstring\nType of webhook sender, used to determine\nthe validation procedure and payload deserialization.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which to reconcile the Receiver with its Secret references.\nevents\n[]string\n(Optional)\nEvents specifies the list of event types to handle,\ne.g. ‘push’ for GitHub or ‘Push Hook’ for GitLab.\nresources\n[]CrossNamespaceObjectReference\nA list of resources to be notified about changes.\nresourceFilter\nstring\n(Optional)\nResourceFilter is a CEL expression expected to return a boolean that is\nevaluated for each resource referenced in the Resources field when a\nwebhook is received. If the expression returns false then the controller\nwill not request a reconciliation for the resource.\nWhen the expression is specified the controller will parse it and mark\nthe object as terminally failed if the expression is invalid or does not\nreturn a boolean.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\nSecretRef specifies the Secret containing the token used\nto validate the payload authenticity.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend subsequent\nevents handling for this receiver.\nstatus\nReceiverStatus\nCrossNamespaceObjectReference\n(\nAppears on:\nReceiverSpec\n)\nCrossNamespaceObjectReference contains enough information to let you locate the\ntyped referenced object at cluster level\nField\nDescription\napiVersion\nstring\n(Optional)\nAPI version of the referent\nkind\nstring\nKind of the referent\nname\nstring\nName of the referent\nIf multiple resources are targeted\n*\nmay be set.\nnamespace\nstring\n(Optional)\nNamespace of the referent\nmatchLabels\nmap[string]string\n(Optional)\nMatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is “key”, the\noperator is “In”, and the values array contains only “value”. The requirements are ANDed.\nMatchLabels requires the name to be set to\n*\n.\nReceiverSpec\n(\nAppears on:\nReceiver\n)\nReceiverSpec defines the desired state of the Receiver.\nField\nDescription\ntype\nstring\nType of webhook sender, used to determine\nthe validation procedure and payload deserialization.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which to reconcile the Receiver with its Secret references.\nevents\n[]string\n(Optional)\nEvents specifies the list of event types to handle,\ne.g. ‘push’ for GitHub or ‘Push Hook’ for GitLab.\nresources\n[]CrossNamespaceObjectReference\nA list of resources to be notified about changes.\nresourceFilter\nstring\n(Optional)\nResourceFilter is a CEL expression expected to return a boolean that is\nevaluated for each resource referenced in the Resources field when a\nwebhook is received. If the expression returns false then the controller\nwill not request a reconciliation for the resource.\nWhen the expression is specified the controller will parse it and mark\nthe object as terminally failed if the expression is invalid or does not\nreturn a boolean.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\nSecretRef specifies the Secret containing the token used\nto validate the payload authenticity.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend subsequent\nevents handling for this receiver.\nReceiverStatus\n(\nAppears on:\nReceiver\n)\nReceiverStatus defines the observed state of the Receiver.\nField\nDescription\nReconcileRequestStatus\ngithub.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus\n(Members of\nReconcileRequestStatus\nare embedded into this type.)\nconditions\n[]Kubernetes meta/v1.Condition\n(Optional)\nConditions holds the conditions for the Receiver.\nwebhookPath\nstring\n(Optional)\nWebhookPath is the generated incoming webhook address in the format\nof ‘/hook/sha256sum(token+name+namespace)’.\nobservedGeneration\nint64\n(Optional)\nObservedGeneration is the last observed generation of the Receiver object.\nThis page was automatically generated with\ngen-crd-api-reference-docs",
      "code_examples": [
        {
          "language": "",
          "code": "notification.toolkit.fluxcd.io/v1",
          "element": "<code>notification.toolkit.fluxcd.io/v1</code>"
        },
        {
          "language": "",
          "code": "resourceFilter",
          "element": "<code>resourceFilter</code>"
        },
        {
          "language": "",
          "code": "matchLabels",
          "element": "<code>matchLabels</code>"
        },
        {
          "language": "",
          "code": "resourceFilter",
          "element": "<code>resourceFilter</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "ReconcileRequestStatus",
          "element": "<code>ReconcileRequestStatus</code>"
        },
        {
          "language": "",
          "code": "webhookPath",
          "element": "<code>webhookPath</code>"
        },
        {
          "language": "",
          "code": "observedGeneration",
          "element": "<code>observedGeneration</code>"
        },
        {
          "language": "",
          "code": "gen-crd-api-reference-docs",
          "element": "<code>gen-crd-api-reference-docs</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Notification API reference v1",
          "id": ""
        },
        {
          "level": 2,
          "text": "notification.toolkit.fluxcd.io/v1",
          "id": "notification.toolkit.fluxcd.io/v1"
        },
        {
          "level": 3,
          "text": "Receiver",
          "id": "notification.toolkit.fluxcd.io/v1.Receiver"
        },
        {
          "level": 3,
          "text": "CrossNamespaceObjectReference",
          "id": "notification.toolkit.fluxcd.io/v1.CrossNamespaceObjectReference"
        },
        {
          "level": 3,
          "text": "ReceiverSpec",
          "id": "notification.toolkit.fluxcd.io/v1.ReceiverSpec"
        },
        {
          "level": 3,
          "text": "ReceiverStatus",
          "id": "notification.toolkit.fluxcd.io/v1.ReceiverStatus"
        }
      ],
      "timestamp": 1750732726.9424262
    },
    {
      "url": "https://fluxcd.io/flux/components/notification/api/v1beta3/",
      "title": "Notification API reference v1beta3 | Flux",
      "content": "Docs\nToolkit Components\nNotification Controller\nAPI Reference\nNotification API reference v1beta3\nNotification API reference v1beta3\nThe GitOps Toolkit Custom Resource Definitions documentation.\nPackages:\nnotification.toolkit.fluxcd.io/v1beta3\nnotification.toolkit.fluxcd.io/v1beta3\nPackage v1beta3 contains API Schema definitions for the notification v1beta3 API group.\nResource Types:\nAlert\nProvider\nAlert\nAlert is the Schema for the alerts API\nField\nDescription\napiVersion\nstring\nnotification.toolkit.fluxcd.io/v1beta3\nkind\nstring\nAlert\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nAlertSpec\nproviderRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\nProviderRef specifies which Provider this Alert should use.\neventSeverity\nstring\n(Optional)\nEventSeverity specifies how to filter events based on severity.\nIf set to ‘info’ no events will be filtered.\neventSources\n[]github.com/fluxcd/notification-controller/api/v1.CrossNamespaceObjectReference\nEventSources specifies how to filter events based\non the involved object kind, name and namespace.\ninclusionList\n[]string\n(Optional)\nInclusionList specifies a list of Golang regular expressions\nto be used for including messages.\neventMetadata\nmap[string]string\n(Optional)\nEventMetadata is an optional field for adding metadata to events dispatched by the\ncontroller. This can be used for enhancing the context of the event. If a field\nwould override one already present on the original event as generated by the emitter,\nthen the override doesn’t happen, i.e. the original value is preserved, and an info\nlog is printed.\nexclusionList\n[]string\n(Optional)\nExclusionList specifies a list of Golang regular expressions\nto be used for excluding messages.\nsummary\nstring\n(Optional)\nSummary holds a short description of the impact and affected cluster.\nDeprecated: Use EventMetadata instead.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend subsequent\nevents handling for this Alert.\nProvider\nProvider is the Schema for the providers API\nField\nDescription\napiVersion\nstring\nnotification.toolkit.fluxcd.io/v1beta3\nkind\nstring\nProvider\nmetadata\nKubernetes meta/v1.ObjectMeta\nRefer to the Kubernetes API documentation for the fields of the\nmetadata\nfield.\nspec\nProviderSpec\ntype\nstring\nType specifies which Provider implementation to use.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which to reconcile the Provider with its Secret references.\nDeprecated and not used in v1beta3.\nchannel\nstring\n(Optional)\nChannel specifies the destination channel where events should be posted.\nusername\nstring\n(Optional)\nUsername specifies the name under which events are posted.\naddress\nstring\n(Optional)\nAddress specifies the endpoint, in a generic sense, to where alerts are sent.\nWhat kind of endpoint depends on the specific Provider type being used.\nFor the generic Provider, for example, this is an HTTP/S address.\nFor other Provider types this could be a project ID or a namespace.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for sending alerts to the Provider.\nproxy\nstring\n(Optional)\nProxy the HTTP/S address of the proxy server.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing the authentication\ncredentials for this Provider.\nserviceAccountName\nstring\n(Optional)\nServiceAccountName is the name of the service account used to\nauthenticate with services from cloud providers. An error is thrown if a\nstatic credential is also defined inside the Secret referenced by the\nSecretRef.\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef specifies the Secret containing\na PEM-encoded CA certificate (in the\nca.crt\nkey).\nNote: Support for the\ncaFile\nkey has\nbeen deprecated.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend subsequent\nevents handling for this Provider.\ncommitStatusExpr\nstring\n(Optional)\nCommitStatusExpr is a CEL expression that evaluates to a string value\nthat can be used to generate a custom commit status message for use\nwith eligible Provider types (github, gitlab, gitea, bitbucketserver,\nbitbucket, azuredevops). Supported variables are: event, provider,\nand alert.\nAlertSpec\n(\nAppears on:\nAlert\n)\nAlertSpec defines an alerting rule for events involving a list of objects.\nField\nDescription\nproviderRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\nProviderRef specifies which Provider this Alert should use.\neventSeverity\nstring\n(Optional)\nEventSeverity specifies how to filter events based on severity.\nIf set to ‘info’ no events will be filtered.\neventSources\n[]github.com/fluxcd/notification-controller/api/v1.CrossNamespaceObjectReference\nEventSources specifies how to filter events based\non the involved object kind, name and namespace.\ninclusionList\n[]string\n(Optional)\nInclusionList specifies a list of Golang regular expressions\nto be used for including messages.\neventMetadata\nmap[string]string\n(Optional)\nEventMetadata is an optional field for adding metadata to events dispatched by the\ncontroller. This can be used for enhancing the context of the event. If a field\nwould override one already present on the original event as generated by the emitter,\nthen the override doesn’t happen, i.e. the original value is preserved, and an info\nlog is printed.\nexclusionList\n[]string\n(Optional)\nExclusionList specifies a list of Golang regular expressions\nto be used for excluding messages.\nsummary\nstring\n(Optional)\nSummary holds a short description of the impact and affected cluster.\nDeprecated: Use EventMetadata instead.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend subsequent\nevents handling for this Alert.\nProviderSpec\n(\nAppears on:\nProvider\n)\nProviderSpec defines the desired state of the Provider.\nField\nDescription\ntype\nstring\nType specifies which Provider implementation to use.\ninterval\nKubernetes meta/v1.Duration\n(Optional)\nInterval at which to reconcile the Provider with its Secret references.\nDeprecated and not used in v1beta3.\nchannel\nstring\n(Optional)\nChannel specifies the destination channel where events should be posted.\nusername\nstring\n(Optional)\nUsername specifies the name under which events are posted.\naddress\nstring\n(Optional)\nAddress specifies the endpoint, in a generic sense, to where alerts are sent.\nWhat kind of endpoint depends on the specific Provider type being used.\nFor the generic Provider, for example, this is an HTTP/S address.\nFor other Provider types this could be a project ID or a namespace.\ntimeout\nKubernetes meta/v1.Duration\n(Optional)\nTimeout for sending alerts to the Provider.\nproxy\nstring\n(Optional)\nProxy the HTTP/S address of the proxy server.\nsecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nSecretRef specifies the Secret containing the authentication\ncredentials for this Provider.\nserviceAccountName\nstring\n(Optional)\nServiceAccountName is the name of the service account used to\nauthenticate with services from cloud providers. An error is thrown if a\nstatic credential is also defined inside the Secret referenced by the\nSecretRef.\ncertSecretRef\ngithub.com/fluxcd/pkg/apis/meta.LocalObjectReference\n(Optional)\nCertSecretRef specifies the Secret containing\na PEM-encoded CA certificate (in the\nca.crt\nkey).\nNote: Support for the\ncaFile\nkey has\nbeen deprecated.\nsuspend\nbool\n(Optional)\nSuspend tells the controller to suspend subsequent\nevents handling for this Provider.\ncommitStatusExpr\nstring\n(Optional)\nCommitStatusExpr is a CEL expression that evaluates to a string value\nthat can be used to generate a custom commit status message for use\nwith eligible Provider types (github, gitlab, gitea, bitbucketserver,\nbitbucket, azuredevops). Supported variables are: event, provider,\nand alert.\nThis page was automatically generated with\ngen-crd-api-reference-docs",
      "code_examples": [
        {
          "language": "",
          "code": "notification.toolkit.fluxcd.io/v1beta3",
          "element": "<code>notification.toolkit.fluxcd.io/v1beta3</code>"
        },
        {
          "language": "",
          "code": "providerRef",
          "element": "<code>providerRef</code>"
        },
        {
          "language": "",
          "code": "eventSeverity",
          "element": "<code>eventSeverity</code>"
        },
        {
          "language": "",
          "code": "eventSources",
          "element": "<code>eventSources</code>"
        },
        {
          "language": "",
          "code": "inclusionList",
          "element": "<code>inclusionList</code>"
        },
        {
          "language": "",
          "code": "eventMetadata",
          "element": "<code>eventMetadata</code>"
        },
        {
          "language": "",
          "code": "exclusionList",
          "element": "<code>exclusionList</code>"
        },
        {
          "language": "",
          "code": "notification.toolkit.fluxcd.io/v1beta3",
          "element": "<code>notification.toolkit.fluxcd.io/v1beta3</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "commitStatusExpr",
          "element": "<code>commitStatusExpr</code>"
        },
        {
          "language": "",
          "code": "providerRef",
          "element": "<code>providerRef</code>"
        },
        {
          "language": "",
          "code": "eventSeverity",
          "element": "<code>eventSeverity</code>"
        },
        {
          "language": "",
          "code": "eventSources",
          "element": "<code>eventSources</code>"
        },
        {
          "language": "",
          "code": "inclusionList",
          "element": "<code>inclusionList</code>"
        },
        {
          "language": "",
          "code": "eventMetadata",
          "element": "<code>eventMetadata</code>"
        },
        {
          "language": "",
          "code": "exclusionList",
          "element": "<code>exclusionList</code>"
        },
        {
          "language": "",
          "code": "serviceAccountName",
          "element": "<code>serviceAccountName</code>"
        },
        {
          "language": "",
          "code": "certSecretRef",
          "element": "<code>certSecretRef</code>"
        },
        {
          "language": "",
          "code": "commitStatusExpr",
          "element": "<code>commitStatusExpr</code>"
        },
        {
          "language": "",
          "code": "gen-crd-api-reference-docs",
          "element": "<code>gen-crd-api-reference-docs</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Notification API reference v1beta3",
          "id": ""
        },
        {
          "level": 2,
          "text": "notification.toolkit.fluxcd.io/v1beta3",
          "id": "notification.toolkit.fluxcd.io/v1beta3"
        },
        {
          "level": 3,
          "text": "Alert",
          "id": "notification.toolkit.fluxcd.io/v1beta3.Alert"
        },
        {
          "level": 3,
          "text": "Provider",
          "id": "notification.toolkit.fluxcd.io/v1beta3.Provider"
        },
        {
          "level": 3,
          "text": "AlertSpec",
          "id": "notification.toolkit.fluxcd.io/v1beta3.AlertSpec"
        },
        {
          "level": 3,
          "text": "ProviderSpec",
          "id": "notification.toolkit.fluxcd.io/v1beta3.ProviderSpec"
        }
      ],
      "timestamp": 1750732730.160251
    },
    {
      "url": "https://fluxcd.io/flux/security/best-practices/",
      "title": "Security Best Practices | Flux",
      "content": "Docs\nSecurity\nBest Practices\nSecurity Best Practices\nBest practices for securing Flux deployments.\nIntroduction\nThe Flux project strives to keep its components secure by design and by default.\nThis document aims to list all security-sensitive options or considerations that\nmust be taken into account when deploying Flux. And also serve as a guide for\nsecurity professionals auditing such deployments.\nNot all recommendations are required for a secure deployment. Some may impact the\nconvenience, performance or resources utilization of Flux. Therefore, use this in\ncombination with your own Security Posture and Risk Appetite.\nSome recommendations may overlap with Kubernetes security recommendations, to keep\nthis short and more easily maintainable, please refer to\nKubernetes CIS Benchmark\nfor non Flux-specific guidance.\nFor help implementing these recommendations, seek\nenterprise support\n.\nSecurity Best Practices\nThe recommendations below are based on Flux’s latest version.\nHelm Controller\nStart-up flags\nEnsure controller was not started with\n--insecure-kubeconfig-exec=true\n.\nRationale\nKubeConfigs support the execution of a binary command to return the token required to authenticate against a Kubernetes cluster.\nThis is very handy for acquiring contextual tokens that are time-bound (e.g. aws-iam-authenticator).\nHowever, this may be open for abuse in multi-tenancy environments and therefore is disabled by default.\nAudit Procedure\nCheck Helm Controller’s pod YAML for the arguments used at start-up:\nkubectl describe pod -n flux-system -l\napp\n=\nhelm-controller | grep -B\n5\n-A\n10\nArgs\nEnsure controller was not started with\n--insecure-kubeconfig-tls=true\n.\nRationale\nDisables the enforcement of TLS when accessing the API Server of remote clusters.\nThis flag was created to enable scenarios in which non-production clusters need to be accessed via HTTP. Do not disable TLS in production.\nAudit Procedure\nCheck Helm Controller’s pod YAML for the arguments used at start-up:\nkubectl describe pod -n flux-system -l\napp\n=\nhelm-controller | grep -B\n5\n-A\n10\nArgs\nKustomize Controller\nStart-up flags\nEnsure controller was not started with\n--insecure-kubeconfig-exec=true\n.\nRationale\nKubeConfigs support the execution of a binary command to return the token required to authenticate against a Kubernetes cluster.\nThis is very handy for acquiring contextual tokens that are time-bound (e.g. aws-iam-authenticator).\nHowever, this may be open for abuse in multi-tenancy environments and therefore is disabled by default.\nAudit Procedure\nCheck Kustomize Controller’s pod YAML for the arguments used at start-up:\nkubectl describe pod -n flux-system -l\napp\n=\nkustomize-controller | grep -B\n5\n-A\n10\nArgs\nEnsure controller was not started with\n--insecure-kubeconfig-tls=true\n.\nRationale\nDisables the enforcement of TLS when accessing the API Server of remote clusters.\nThis flag was created to enable scenarios in which non-production clusters need to be accessed via HTTP. Do not disable TLS in production.\nAudit Procedure\nCheck Kustomize Controller’s pod YAML for the arguments used at start-up:\nkubectl describe pod -n flux-system -l\napp\n=\nkustomize-controller | grep -B\n5\n-A\n10\nArgs\nEnsure controller was started with\n--no-remote-bases=true\n.\nRationale\nBy default the Kustomize controller allows for kustomize overlays to refer to external bases.\nThis has a performance penalty, as the bases will have to be downloaded on demand during each reconciliation.\nWhen using external bases, there can’t be any assurances that the externally declared state won’t change.\nIn this case, the source loses its hermetic properties. Changes in the external bases will result in changes on the cluster, regardless of whether the source has been modified since the last reconciliation.\nAudit Procedure\nCheck Kustomize Controller’s pod YAML for the arguments used at start-up:\nkubectl describe pod -n flux-system -l\napp\n=\nkustomize-controller | grep -B\n5\n-A\n10\nArgs\nSecret Decryption\nEnsure Secret Decryption is enabled and secrets are not being held in Flux Sources in plaintext.\nRationale\nThe kustomize-controller has an auto decryption mechanism that can decrypt cipher texts on-demand at reconciliation time using an embedded implementation of\nSOPS\n. This enables credentials (e.g. passwords, tokens) and sensitive information to be kept in an encrypted state in the sources.\nAudit Procedure\nCheck for plaintext credentials stored in the Git Repository at both HEAD and historical commits. Auto-detection tools can be used for this such as\nGitLeaks\n,\nTrufflehog\nand\nSquealer\n.\nCheck whether Secret Decryption is properly enabled in each\nspec.decryption\nfield of the cluster’s\nKustomization\nobjects.\nAdditional Best Practices for Shared Cluster Multi-tenancy\nMulti-tenancy Lock-down\nEnsure\nhelm-controller\n,\nkustomize-controller\n,\nnotification-controller\n,\nimage-reflector-controller\nand\nimage-automation-controller\nhave cross namespace references disabled via\n--no-cross-namespace-refs=true\n.\nRationale\nBlocks references to Flux objects across namespaces. This assumes that tenants would own one or multiple namespaces, and should not be allowed to consume other tenant’s objects, as this could enable them to gain access to sources they do not (or should not) have access to.\nAudit Procedure\nCheck the Controller’s YAML for the arguments used at start-up:\nkubectl describe pod -n flux-system -l\napp\n=\nhelm-controller | grep -B\n5\n-A\n10\nArgs\nkubectl describe pod -n flux-system -l\napp\n=\nkustomize-controller | grep -B\n5\n-A\n10\nArgs\nkubectl describe pod -n flux-system -l\napp\n=\nnotification-controller | grep -B\n5\n-A\n10\nArgs\nkubectl describe pod -n flux-system -l\napp\n=\nimage-reflector-controller | grep -B\n5\n-A\n10\nArgs\nkubectl describe pod -n flux-system -l\napp\n=\nimage-automation-controller | grep -B\n5\n-A\n10\nArgs\nEnsure\nhelm-controller\nand\nkustomize-controller\nhave a default service account set via\n--default-service-account=<service-account-name>\n.\nRationale\nEnforces all reconciliations to impersonate a given Service Account, effectively disabling the use of the privileged service account that would otherwise be used by the controller.\nTenants must set a service account for each object that is responsible for applying changes to the Cluster (i.e.\nHelmRelease\nand\nKustomization\n), otherwise Kubernetes’s API Server will not authorize the changes. NB: It is recommended that the default service account used has no permissions set to the control plane.\nAudit Procedure\nCheck the Controller’s YAML for the arguments used at start-up:\nkubectl describe pod -n flux-system -l\napp\n=\nhelm-controller | grep -B\n5\n-A\n10\nArgs\nkubectl describe pod -n flux-system -l\napp\n=\nkustomize-controller | grep -B\n5\n-A\n10\nArgs\nSecret Decryption\nEnsure Secret Decryption is configured correctly, such that each tenant have the correct level of isolation.\nRationale\nThe secret decryption configuration must be aligned with the level of isolation required across tenants.\nFor higher isolation, each tenant must have their own Key Encryption Key (KEK) configured. Note that the access controls to the aforementioned keys must also be aligned for better isolation.\nFor lower isolation requirements, or for secrets that are shared across multiple tenants, cluster-level keys could be used.\nAudit Procedure\nCheck whether the Secret Provider configuration is security hardened. Please seek\nSOPS\nand\nSealedSecrets\ndocumentation for how to best implement each solution.\nWhen SealedSecrets are employed, pay special attention to the scopes being used.\nResource Isolation\nEnsure additional Flux instances are deployed when mission-critical tenants/workloads must be assured.\nRationale\nSharing the same instances of Flux Components across all tenants including the Platform Admin, will lead to all reconciliations competing for the same resources. In addition, all Flux objects will be placed on the same queue for reconciliation which is limited by the number of workers set by each controller (i.e.\n--concurrent=20\n), which could cause reconciliation intervals not to be accurately honored.\nFor improved reliability, additional instances of Flux Components could be deployed, effectively creating separate “lanes” that are not disrupted by noisy neighbors. An example of this approach would be having additional instances of both Kustomize and Helm controllers that focuses on applying platform level changes, which do not compete with Tenants changes.\nRunning multiple Flux instances within the same cluster is supported by means of sharding, please consult the\nFlux sharding and horizontal scaling documentation\nfor more details.\nTo avoid conflicts among controllers while attempting to reconcile Custom Resources, controller types (e.g.\nsource-controller\n) must have be configured with unique label selectors in the\n--watch-label-selector\nflag.\nAudit Procedure\nCheck for the existence of additional Flux controllers instances and their respective scopes. Each controller must be started with\n--watch-label-selector\nand have the selector point to unique label values:\nkubectl describe pod -n flux-system -l\napp\n=\nkustomize-controller | grep -B\n5\n-A\n10\nArgs\nkubectl describe pod -n flux-system -l\napp\n=\nhelm-controller | grep -B\n5\n-A\n10\nArgs\nkubectl describe pod -n flux-system -l\napp\n=\nsource-controller | grep -B\n5\n-A\n10\nArgs\nNode Isolation\nEnsure worker nodes are not being shared across tenants and the Flux components.\nRationale\nPods sharing the same worker node may enable threat vectors which might enable a malicious tenant to have a negative impact on the Confidentiality, Integrity or Availability of the co-located pods.\nThe Flux components may have Control Plane privileges while some tenants may not. A co-located pod could leverage its privileges in the shared worker node to bypass its own Control Plane access limitations by compromising one of the co-located Flux components. For cases in which cross-tenant isolation requirements must be enforced, the same risks apply.\nEmploy techniques to enforce that untrusted workloads are sandboxed. And, ensure that worker nodes are only shared when within the acceptable risks by your security requirements.\nAudit Procedure\nCheck whether you adhere to\nKubernetes Node Isolation Guidelines\nCheck whether there are Admission Controllers/OPA blocking tenants from creating privileged containers.\nCheck whether\nRuntimeClass\nis being employed to sandbox workloads that may be scheduled in shared worker nodes.\nCheck whether\nTaints and Tolerations\nare being used to decrease the likelihood of sharing worker nodes across tenants, or with the Flux controllers. Some cloud providers have this encapsulated as Node Pools.\nNetwork Isolation\nEnsure the Container Network Interface (CNI) being used in the cluster supports Network Policies.\nRationale\nFlux relies on Network Policies to ensure that only Flux components have direct access to the source artifacts kept in the Source Controller.\nAudit Procedure\nCheck whether you adhere to\nKubernetes Network Isolation Guidelines\nConfirm that the\nNetwork Policy\nobjects created by Flux are being enforced by the CNI. Alternatively, run a tool such as\nCyclonus\nor\nSonobuoy\nto validate NetworkPolicy enforcement by the CNI plugin on your cluster.\nAdditional Best Practices for Tenant Dedicated Cluster Multi-tenancy\nEnsure tenants are not able to revoke Platform Admin access to their clusters.\nRationale\nIn environments in which a management cluster is used to bootstrap and manage other clusters, it is important to ensure that a tenant is not allowed to revoke access from the Platform Admin, effectively denying the Management Cluster the ability to further reconcile changes into the tenant’s Cluster.\nThe Platform Admin should make sure that at the tenant’s cluster bootstrap process, this is taken into the account and a breakglass procedure is in place to recover access without the need to rebuild the cluster.\nAudit Procedure\nCheck whether alerts are in place in case the Remote Apply operations fails.\nCheck the permission set given to the tenant’s users and applications is not overly privileged.\nCheck whether there are Admission Controllers/OPA rules blocking changes in Platform Admin’s permissions and overall resources.\nLast modified 2023-12-12:\nUpdate HelmRelease refs to match v2beta2 spec (fbfe03c)",
      "code_examples": [
        {
          "language": "",
          "code": "--insecure-kubeconfig-exec=true",
          "element": "<code>--insecure-kubeconfig-exec=true</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>helm-controller ..."
        },
        {
          "language": "",
          "code": "--insecure-kubeconfig-tls=true",
          "element": "<code>--insecure-kubeconfig-tls=true</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>helm-controller ..."
        },
        {
          "language": "",
          "code": "--insecure-kubeconfig-exec=true",
          "element": "<code>--insecure-kubeconfig-exec=true</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>kustomize-contro..."
        },
        {
          "language": "",
          "code": "--insecure-kubeconfig-tls=true",
          "element": "<code>--insecure-kubeconfig-tls=true</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>kustomize-contro..."
        },
        {
          "language": "",
          "code": "--no-remote-bases=true",
          "element": "<code>--no-remote-bases=true</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>kustomize-contro..."
        },
        {
          "language": "",
          "code": "spec.decryption",
          "element": "<code>spec.decryption</code>"
        },
        {
          "language": "",
          "code": "Kustomization",
          "element": "<code>Kustomization</code>"
        },
        {
          "language": "",
          "code": "helm-controller",
          "element": "<code>helm-controller</code>"
        },
        {
          "language": "",
          "code": "kustomize-controller",
          "element": "<code>kustomize-controller</code>"
        },
        {
          "language": "",
          "code": "notification-controller",
          "element": "<code>notification-controller</code>"
        },
        {
          "language": "",
          "code": "image-reflector-controller",
          "element": "<code>image-reflector-controller</code>"
        },
        {
          "language": "",
          "code": "image-automation-controller",
          "element": "<code>image-automation-controller</code>"
        },
        {
          "language": "",
          "code": "--no-cross-namespace-refs=true",
          "element": "<code>--no-cross-namespace-refs=true</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=notification-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=image-reflector-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=image-automation-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=notification-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=image-reflector-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=image-automation-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>helm-controller ..."
        },
        {
          "language": "",
          "code": "helm-controller",
          "element": "<code>helm-controller</code>"
        },
        {
          "language": "",
          "code": "kustomize-controller",
          "element": "<code>kustomize-controller</code>"
        },
        {
          "language": "",
          "code": "--default-service-account=<service-account-name>",
          "element": "<code>--default-service-account=&lt;service-account-name&gt;</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>helm-controller ..."
        },
        {
          "language": "",
          "code": "--concurrent=20",
          "element": "<code>--concurrent=20</code>"
        },
        {
          "language": "",
          "code": "source-controller",
          "element": "<code>source-controller</code>"
        },
        {
          "language": "",
          "code": "--watch-label-selector",
          "element": "<code>--watch-label-selector</code>"
        },
        {
          "language": "",
          "code": "--watch-label-selector",
          "element": "<code>--watch-label-selector</code>"
        },
        {
          "language": "",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=source-controller | grep -B5-A10Args",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-syste..."
        },
        {
          "language": "language-sh",
          "code": "kubectl describe pod -n flux-system -lapp=kustomize-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=helm-controller | grep -B5-A10Argskubectl describe pod -n flux-system -lapp=source-controller | grep -B5-A10Args",
          "element": "<code class=\"language-sh\" data-lang=\"sh\"><span style=\"display:flex\"><span>kubectl describe pod -n flux-system -l <span style=\"color:#bb60d5\">app</span><span style=\"color:#666\">=</span>kustomize-contro..."
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Security Best Practices",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 2,
          "text": "Security Best Practices",
          "id": "security-best-practices"
        },
        {
          "level": 2,
          "text": "Additional Best Practices for Shared Cluster Multi-tenancy",
          "id": "additional-best-practices-for-shared-cluster-multi-tenancy"
        },
        {
          "level": 2,
          "text": "Additional Best Practices for Tenant Dedicated Cluster Multi-tenancy",
          "id": "additional-best-practices-for-tenant-dedicated-cluster-multi-tenancy"
        },
        {
          "level": 3,
          "text": "Helm Controller",
          "id": "helm-controller"
        },
        {
          "level": 3,
          "text": "Kustomize Controller",
          "id": "kustomize-controller"
        },
        {
          "level": 3,
          "text": "Multi-tenancy Lock-down",
          "id": "multi-tenancy-lock-down"
        },
        {
          "level": 3,
          "text": "Secret Decryption",
          "id": "secret-decryption-1"
        },
        {
          "level": 3,
          "text": "Resource Isolation",
          "id": "resource-isolation"
        },
        {
          "level": 3,
          "text": "Node Isolation",
          "id": "node-isolation"
        },
        {
          "level": 3,
          "text": "Network Isolation",
          "id": "network-isolation"
        },
        {
          "level": 4,
          "text": "Start-up flags",
          "id": "start-up-flags"
        },
        {
          "level": 4,
          "text": "Start-up flags",
          "id": "start-up-flags-1"
        },
        {
          "level": 4,
          "text": "Secret Decryption",
          "id": "secret-decryption"
        }
      ],
      "timestamp": 1750732732.86565
    },
    {
      "url": "https://fluxcd.io/flux/security/",
      "title": "Security Documentation | Flux",
      "content": "Docs\nSecurity\nSecurity Documentation\nFlux Security documentation.\nIntroduction\nFlux has a multi-component design, and integrates with many other systems.\nThis document outlines an overview of security considerations for Flux components,\nproject processes, artifacts, as well as Flux configurable options and\nwhat they enable for both Kubernetes cluster and external system security.\nSee our\nsecurity processes document\nfor vulnerability reporting, handling,\nand disclosure of information for the Flux project and community.\nPlease also have a look at\nour security-related blog posts\n.\nWe are writing there to inform you what we are doing to keep Flux and you safe!\nSigned container images\nThe Flux CLI and the controllers’ images are signed using\nSigstore\nCosign and GitHub OIDC.\nThe container images along with their signatures are published on GitHub Container Registry and Docker Hub.\nTo verify the authenticity of Flux’s container images,\ninstall\ncosign\nv2 and run:\n$\ncosign verify ghcr.io/fluxcd/source-controller:v1.0.0\n\\\n--certificate-identity-regexp=^https://github\\\\.com/fluxcd/.*$ \\\n--certificate-oidc-issuer=https://token.actions.githubusercontent.com\nVerification for ghcr.io/fluxcd/source-controller:v1.0.0 --\nThe following checks were performed on each of these signatures:\n- The cosign claims were validated\n- Existence of the claims in the transparency log was verified offline\n- The code-signing certificate was verified using trusted certificate authority certificates\nWe also wrote\na blog post\nwhich discusses this in some more detail.\nSoftware Bill of Materials\nFor the Flux project we publish a Software Bill of Materials (SBOM) with each release.\nThe SBOM is generated with\nSyft\nin the\nSPDX\nformat.\nThe\nspdx.json\nfile is available for download on the GitHub release page e.g.:\ncurl -sL https://github.com/fluxcd/flux2/releases/download/v2.0.0/flux_2.0.0_sbom.spdx.json | jq\nThe Flux controllers’ images come with SBOMs for each CPU architecture,\nyou can extract the SPDX JSON using Docker’s inspect command:\ndocker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0\n\\\n--format\n\"{{ json (index .SBOM \\\"linux/amd64\\\").SPDX}}\"\nOr by using Docker’s\nsbom command\n:\ndocker sbom fluxcd/source-controller:v1.0.0\nPlease also refer to\nthis blog post\nwhich discusses the idea and value of SBOMs.\nSLSA Provenance\nStarting with Flux version 2.0.0, the build, release and provenance portions of the Flux\nproject supply chain provisionally meet\nSLSA Build Level 3\n.\nPlease see the\nSLSA Assessment\ndocumentation for more details on how the\nprovenance is generated and how Flux complies with the SLSA requirements.\nProvenance verification\nThe provenance of the Flux release artifacts (binaries, container images, SBOMs, deploy manifests)\ncan be verified using the official SLSA verifier tool and Sigstore Cosign.\nPlease see the\nSLSA provenance verification\ndocumentation\nfor more details on how to verify the provenance of Flux release artifacts.\nBuildkit attestations\nThe Flux controllers’ images come with provenance attestations which follow\nthe\nSLSA provenance schema version 0.2\n.\nThe provenance attestations are generated at build time with\nDocker Buildkit\nand\ninclude facts about the build process such as:\nBuild timestamps\nBuild parameters and environment\nVersion control metadata\nSource code details\nMaterials (files, scripts) consumed during the build\nTo extract the SLSA provenance JSON for a specific CPU architecture,\nyou can use Docker’s inspect command:\ndocker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0\n\\\n--format\n\"{{ json (index .Provenance \\\"linux/amd64\\\").SLSA}}\"\nNote that the\nlinux/amd64\ncan be replaced with another architecture variation of the image,\nfor example\nlinux/arm64\nor\nlinux/arm/v7\n.\nScanning for CVEs\nThe Flux controllers’ images are based on Alpine, they contain very few OS packages\nand the controller’s binary which is statically built using Go.\nTo properly scan Flux container images, the scanner must be able to detect the\nAlpine apk packages and the Go modules included in the controller’s Go binary.\nThe Go modules and apk packages are also available for inspection\nin the attached\nSBOM\n.\nThe Flux team recommends users to scan the container images for CVEs using\nTrivy\n,\nwhich is an OSS scanner made by\nAqua Security\n.\nTo scan a controller image with Trivy:\ntrivy image ghcr.io/fluxcd/source-controller:v1.0.0\nWe ask users to keep Flux up-to-date on their clusters,\nthis is the only way to ensure a Flux deployment is free of CVEs.\nNew Flux versions are\npublished periodically\n,\nand the container images are based on the latest Alpine and Go releases.\nWe offer a fully automated solution for keeping Flux up-to-date,\nplease see the Flux GitHub Actions\ndocumentation\nfor more details.\nReporting CVEs in Flux images\nThe Flux controllers are constantly being monitored for new CVEs, and the attack\nsurface for any vulnerability is assessed by maintainers. If a controller is considered\nto be vulnerable, a new patch release will be issued immediately.\nGiven this, and while we do appreciate the effort, reporting CVEs found by a security\nscanner through issues and/or the security mailing list is not necessary.\nPod security standard\nThe controller deployments are configured in conformance with the\nKubernetes\nrestricted pod security standard\n:\nall Linux capabilities are dropped\nthe root filesystem is set to read-only\nthe seccomp profile is set to the runtime default\nrun as non-root is enabled\nthe filesystem group is set to 1337\nthe user and group ID is set to 65534\nController permissions\nWhile Flux integrates with other systems it is built on Kubernetes core controller-runtime\nand properly adheres to Kubernetes security model including RBAC\n1\n.\nFlux installs a set of\nRBAC manifests\n.\nThese include:\nA\ncrd-controller\nClusterRole\n, which:\nHas full access to all the Custom Resource Definitions defined by Flux controllers\nCan get, list, and watch namespaces and secrets\nCan get, list, watch, create, patch, and delete configmaps and their status\nCan get, list, watch, create, patch, and delete coordination.k8s.io leases\nCan create ServiceAccount tokens used for object-level workload identity\nA\ncrd-controller\nClusterRoleBinding\n:\nReferences\ncrd-controller\nClusterRole\nabove\nBound to a service accounts for every Flux controller\nA\ncluster-reconciler\nClusterRoleBinding\n:\nReferences\ncluster-admin\nClusterRole\nBound to service accounts for only\nkustomize-controller\nand\nhelm-controller\nA\nflux-view\nClusterRole\n:\nGrants the Kubernetes builtin\nview\nrole read-only access to Flux Custom Resources\nA\nflux-edit\nClusterRole\n:\nGrants the Kubernetes builtin\nedit\nand\nadmin\nroles write access to Flux Custom Resources\nFlux uses these two\nClusterRoleBinding\nstrategies in order to allow for clear access separation using tools\npurpose-built for policy enforcement (OPA, Kyverno, admission controllers).\nFor example, the design allows all controllers to access Flux CRDs (binds to\ncrd-controller\nClusterRole\n),\nbut only binds the Flux reconciler controllers for Kustomize and Helm to\ncluster-admin\nClusterRole\n,\nas these are the only two controllers that manage resources in the cluster.\nHowever in a\nsoft multi-tenancy setup\n,\nFlux does not reconcile a tenant’s repo under the\ncluster-admin\nrole.\nInstead, you specify a different service account in your manifest, and the Flux controllers will use\nthe Kubernetes Impersonation API under\ncluster-admin\nto impersonate that service account\n2\n.\nIn this way, policy restrictions for this service account are applied to the manifests being reconciled.\nIf the binding is not defined for the correct service account and namespace, it will fail.\nThe roles and permissions for this multi-tenancy approach\nare described in detail here:\nhttps://github.com/fluxcd/flux2-multi-tenancy\n.\nCross-Namespace reference policy\nFlux’s general premise is to follow Kubernetes best RBAC practices which forbid cross-namespace references to potential sensitive data, i.e. Secrets and ConfigMaps. For sources and events, Flux allows referencing resources from other Namespaces. In these cases, the policy is governed by each controller’s\n--no-cross-namespace-refs\nflag. See the\nFlux multi-tenancy configuration page\nfor further information on this flag.\nFurther securing Flux Deployments\nBeyond the baked-in security features of Flux, there are further best\npractices that can be implemented to ensure your Flux deployment is as secure\nas it can be. For more information, checkout the\nFlux Security Best Practices\n.\nHowever, by design cross-namespace references are an exception to RBAC.\nPlatform admins have the option to turn off cross-namespace references as described in the\ninstallation documentation\n.\n↩︎\nPlatform admins have to option to enforce impersonation as described in the\ninstallation documentation\n.\n↩︎\nSecurity Best Practices\nBest practices for securing Flux deployments.\nContextual Authorization\nContextual Authorization for securing Flux deployments.\nSecrets Management\nManaging Secrets in a GitOps way using Flux.\nSLSA Assessment\nFlux assessment of SLSA Level 3 requirements.\nLast modified 2025-06-08:\nAdd RBAC patch to remove Object-level Workload Identity (8de296b)",
      "code_examples": [
        {
          "language": "",
          "code": "$cosign verify ghcr.io/fluxcd/source-controller:v1.0.0\\--certificate-identity-regexp=^https://github\\\\.com/fluxcd/.*$ \\--certificate-oidc-issuer=https://token.actions.githubusercontent.comVerification for ghcr.io/fluxcd/source-controller:v1.0.0 --The following checks were performed on each of these signatures:- The cosign claims were validated- Existence of the claims in the transparency log was verified offline- The code-signing certificate was verified using trusted certificate authority certificates",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d..."
        },
        {
          "language": "language-console",
          "code": "$cosign verify ghcr.io/fluxcd/source-controller:v1.0.0\\--certificate-identity-regexp=^https://github\\\\.com/fluxcd/.*$ \\--certificate-oidc-issuer=https://token.actions.githubusercontent.comVerification for ghcr.io/fluxcd/source-controller:v1.0.0 --The following checks were performed on each of these signatures:- The cosign claims were validated- Existence of the claims in the transparency log was verified offline- The code-signing certificate was verified using trusted certificate authority certificates",
          "element": "<code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d09;font-weight:700\">$</span> cosign verify ghcr.io/fluxcd/source-controller:v1.0.0 <span sty..."
        },
        {
          "language": "",
          "code": "curl -sL https://github.com/fluxcd/flux2/releases/download/v2.0.0/flux_2.0.0_sbom.spdx.json | jq",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>curl -sL https://github.com/..."
        },
        {
          "language": "language-shell",
          "code": "curl -sL https://github.com/fluxcd/flux2/releases/download/v2.0.0/flux_2.0.0_sbom.spdx.json | jq",
          "element": "<code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>curl -sL https://github.com/fluxcd/flux2/releases/download/v2.0.0/flux_2.0.0_sbom.spdx.json | jq\n</span></span></code>"
        },
        {
          "language": "",
          "code": "docker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0\\--format\"{{ json (index .SBOM \\\"linux/amd64\\\").SPDX}}\"",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>docker buildx imagetools ins..."
        },
        {
          "language": "language-shell",
          "code": "docker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0\\--format\"{{ json (index .SBOM \\\"linux/amd64\\\").SPDX}}\"",
          "element": "<code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>docker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0 <span style=\"color:#4070a0;font-weight:700\">\\\n<..."
        },
        {
          "language": "",
          "code": "docker sbom fluxcd/source-controller:v1.0.0",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>docker sbom fluxcd/source-co..."
        },
        {
          "language": "language-shell",
          "code": "docker sbom fluxcd/source-controller:v1.0.0",
          "element": "<code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>docker sbom fluxcd/source-controller:v1.0.0\n</span></span></code>"
        },
        {
          "language": "",
          "code": "docker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0\\--format\"{{ json (index .Provenance \\\"linux/amd64\\\").SLSA}}\"",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>docker buildx imagetools ins..."
        },
        {
          "language": "language-shell",
          "code": "docker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0\\--format\"{{ json (index .Provenance \\\"linux/amd64\\\").SLSA}}\"",
          "element": "<code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>docker buildx imagetools inspect ghcr.io/fluxcd/source-controller:v1.0.0 <span style=\"color:#4070a0;font-weight:700\">\\\n<..."
        },
        {
          "language": "",
          "code": "linux/amd64",
          "element": "<code>linux/amd64</code>"
        },
        {
          "language": "",
          "code": "linux/arm64",
          "element": "<code>linux/arm64</code>"
        },
        {
          "language": "",
          "code": "linux/arm/v7",
          "element": "<code>linux/arm/v7</code>"
        },
        {
          "language": "",
          "code": "trivy image ghcr.io/fluxcd/source-controller:v1.0.0",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>trivy image ghcr.io/fluxcd/s..."
        },
        {
          "language": "language-shell",
          "code": "trivy image ghcr.io/fluxcd/source-controller:v1.0.0",
          "element": "<code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span>trivy image ghcr.io/fluxcd/source-controller:v1.0.0\n</span></span></code>"
        },
        {
          "language": "",
          "code": "crd-controller",
          "element": "<code>crd-controller</code>"
        },
        {
          "language": "",
          "code": "ClusterRole",
          "element": "<code>ClusterRole</code>"
        },
        {
          "language": "",
          "code": "crd-controller",
          "element": "<code>crd-controller</code>"
        },
        {
          "language": "",
          "code": "ClusterRoleBinding",
          "element": "<code>ClusterRoleBinding</code>"
        },
        {
          "language": "",
          "code": "crd-controller",
          "element": "<code>crd-controller</code>"
        },
        {
          "language": "",
          "code": "ClusterRole",
          "element": "<code>ClusterRole</code>"
        },
        {
          "language": "",
          "code": "cluster-reconciler",
          "element": "<code>cluster-reconciler</code>"
        },
        {
          "language": "",
          "code": "ClusterRoleBinding",
          "element": "<code>ClusterRoleBinding</code>"
        },
        {
          "language": "",
          "code": "cluster-admin",
          "element": "<code>cluster-admin</code>"
        },
        {
          "language": "",
          "code": "ClusterRole",
          "element": "<code>ClusterRole</code>"
        },
        {
          "language": "",
          "code": "kustomize-controller",
          "element": "<code>kustomize-controller</code>"
        },
        {
          "language": "",
          "code": "helm-controller",
          "element": "<code>helm-controller</code>"
        },
        {
          "language": "",
          "code": "ClusterRole",
          "element": "<code>ClusterRole</code>"
        },
        {
          "language": "",
          "code": "ClusterRole",
          "element": "<code>ClusterRole</code>"
        },
        {
          "language": "",
          "code": "ClusterRoleBinding",
          "element": "<code>ClusterRoleBinding</code>"
        },
        {
          "language": "",
          "code": "crd-controller",
          "element": "<code>crd-controller</code>"
        },
        {
          "language": "",
          "code": "ClusterRole",
          "element": "<code>ClusterRole</code>"
        },
        {
          "language": "",
          "code": "cluster-admin",
          "element": "<code>cluster-admin</code>"
        },
        {
          "language": "",
          "code": "ClusterRole",
          "element": "<code>ClusterRole</code>"
        },
        {
          "language": "",
          "code": "cluster-admin",
          "element": "<code>cluster-admin</code>"
        },
        {
          "language": "",
          "code": "cluster-admin",
          "element": "<code>cluster-admin</code>"
        },
        {
          "language": "",
          "code": "--no-cross-namespace-refs",
          "element": "<code>--no-cross-namespace-refs</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Security Documentation",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 2,
          "text": "Signed container images",
          "id": "signed-container-images"
        },
        {
          "level": 2,
          "text": "Software Bill of Materials",
          "id": "software-bill-of-materials"
        },
        {
          "level": 2,
          "text": "SLSA Provenance",
          "id": "slsa-provenance"
        },
        {
          "level": 2,
          "text": "Scanning for CVEs",
          "id": "scanning-for-cves"
        },
        {
          "level": 2,
          "text": "Pod security standard",
          "id": "pod-security-standard"
        },
        {
          "level": 2,
          "text": "Controller permissions",
          "id": "controller-permissions"
        },
        {
          "level": 2,
          "text": "Cross-Namespace reference policy",
          "id": "cross-namespace-reference-policy"
        },
        {
          "level": 2,
          "text": "Further securing Flux Deployments",
          "id": "further-securing-flux-deployments"
        },
        {
          "level": 3,
          "text": "Provenance verification",
          "id": "provenance-verification"
        },
        {
          "level": 3,
          "text": "Buildkit attestations",
          "id": "buildkit-attestations"
        },
        {
          "level": 4,
          "text": "Reporting CVEs in Flux images",
          "id": ""
        },
        {
          "level": 5,
          "text": "Security Best Practices",
          "id": ""
        },
        {
          "level": 5,
          "text": "Contextual Authorization",
          "id": ""
        },
        {
          "level": 5,
          "text": "Secrets Management",
          "id": ""
        },
        {
          "level": 5,
          "text": "SLSA Assessment",
          "id": ""
        }
      ],
      "timestamp": 1750732735.724247
    },
    {
      "url": "https://fluxcd.io/flux/security/contextual-authorization/",
      "title": "Contextual Authorization | Flux",
      "content": "Docs\nSecurity\nContextual Authorization\nContextual Authorization\nContextual Authorization for securing Flux deployments.\nIntroduction\nMost cloud providers support context-based authorization, enabling applications\nto benefit from strong access controls applied to a given context (e.g. Virtual\nMachine), without the need of managing authentication tokens and credentials.\nFor example, by granting a given Virtual Machine (or principal that such machine\noperates under) access to AWS S3, applications running inside that machine can\nrequest a token on-demand, which would grant them access to the AWS S3 buckets\nwithout having to store long lived credentials anywhere.\nBy leveraging such capability, Flux users can focus on the big picture, which is\naccess controls enforcement with a least-privileged approach, whilst not having to\ndo deal with security hygiene topics such as encrypting authentication secrets, and\nensure they are being rotated regularly.\nAll that is taken care of automatically by the cloud providers, as the tokens provided\nare context- and time-bound.\nCurrent Support\nBelow is a list of Flux features that support this functionality and their documentation:\nStatus\nComponent\nFeature\nProvider\nRef\nSupported\nSource Controller\nGit Repository Authentication\nAzure\nGuide\nSupported\nSource Controller\nBucket Repository Authentication\nAWS\nGuide\nSupported\nSource Controller\nBucket Repository Authentication\nAzure\nGuide\nSupported\nSource Controller\nBucket Repository Authentication\nGCP\nGuide\nSupported\nSource Controller\nOCI Repository Authentication\nAWS\nGuide\nSupported\nSource Controller\nOCI Repository Authentication\nAzure\nGuide\nSupported\nSource Controller\nOCI Repository Authentication\nGCP\nGuide\nSupported\nSource Controller\nHelm OCI Repository Authentication\nAWS\nGuide\nSupported\nSource Controller\nHelm OCI Repository Authentication\nAzure\nGuide\nSupported\nSource Controller\nHelm OCI Repository Authentication\nGCP\nGuide\nSupported\nImage Reflector Controller\nImage Repository Authentication\nAWS\nGuide\nSupported\nImage Reflector Controller\nImage Repository Authentication\nAzure\nGuide\nSupported\nImage Reflector Controller\nImage Repository Authentication\nGCP\nGuide\nSupported\nImage Automation Controller\nGit Repository Authentication\nAzure\nGuide\nSupported\nKustomize Controller\nSOPS Integration with KMS\nAWS\nGuide\nSupported\nKustomize Controller\nSOPS Integration with KMS\nAzure\nGuide\nSupported\nKustomize Controller\nSOPS Integration with KMS\nGCP\nGuide\nSupported\nNotification Controller\nAzure DevOps Commit Status Updates\nAzure\nGuide\nSupported\nNotification Controller\nAzure Event Hubs\nAzure\nGuide\nSupported\nNotification Controller\nGoogle Cloud Pub/Sub\nGCP\nGuide\nRoadmap\nSupport for context-based authorization should only increase over time.\nFor more information, please visit the tracking issue:\nhttps://github.com/fluxcd/flux2/issues/3003\n.\nLast modified 2025-05-19:\n[RFC-0010] Add section for integrations (daec6cb)",
      "code_examples": [],
      "headings": [
        {
          "level": 1,
          "text": "Contextual Authorization",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 2,
          "text": "Current Support",
          "id": "current-support"
        },
        {
          "level": 2,
          "text": "Roadmap",
          "id": "roadmap"
        }
      ],
      "timestamp": 1750732738.199179
    },
    {
      "url": "https://fluxcd.io/flux/security/secrets-management/",
      "title": "Secrets Management | Flux",
      "content": "Docs\nSecurity\nSecrets Management\nSecrets Management\nManaging Secrets in a GitOps way using Flux.\nIntroduction\nFlux improves the application deployment process by continuously reconciling a\ndesired state, defined at a source, against a target cluster. One of the challenges\nwith this process is its dependency on secrets, that must not be stored in plain-text\nlike the rest of the desired state.\nSecrets are sensitive information that an application needs to operate such as:\ncredentials, passwords, keys, tokens and certificates. Managing secrets declaratively\nneeds to be done right because of its broad security implications.\nWe will cover the mechanisms supported by Flux, as well as the security principles,\nconcerns and techniques to consider when managing secrets with Flux.\nWhat’s inside the toolbox?\nFirst of all, let’s go through the different options supported by Flux and Kubernetes.\nNowadays there are a multitude of secret management options. Some are available in-cluster,\ndirectly in the comfort of your Kubernetes cluster, and others that are provided from\nout-of-cluster, for example a Cloud based KMS.\nKubernetes Secrets\nKubernetes has a\nbuilt-in mechanism\nto store and manage secrets. The secrets\nare stored in etcd either in plain-text or\nencrypted\n.\nThey are the vanilla offering, which is used during\nflux bootstrap\n, for example, to store your\nSSH Deploy Keys. Unless when the initial Flux source supports\ncontextual authorization\n,\nin which case no secrets are required.\nStoring plain-text secrets in your desired state is not recommended, so apart from the secret\nused to authenticate against your initial source, Flux users should not manage these. Instead,\nthey should rely mostly on other mechanisms covered below.\nSecrets Decryption Operators\nSometimes referred to as Encrypted Secrets, Secrets Decryption Operators enable secrets to be stored\nin ciphertext as Kubernetes resources within a Flux source. They are deployed into the cluster by\nFlux in their original CustomResourceDefinition (CRD) form, which is later used by its Secret\nDecryption Operator to decrypt those secrets and generate a Kubernetes Secret.\nThis is transparent to the consuming applications, making it a quite suitable approach to retrofit\ninto an existing setup. An example of a Secret Decryption Operator is\nSealed Secrets\n.\nStoring encrypted secrets in Git repositories enables configuration versioning to leverage the\nsame practices used for managing, versioning and releasing application and/or infrastructure\nwhen using declarative “everything as code”, for example pull-requests, tags and branch\nstrategies.\nNote that some sources may keep a history of the encrypted Secrets (e.g.\nGitRepository\n)\nthrough time. Increasing the impact when old encryption keys are leaked, especially when\nother security measures are not in place (e.g. secret rotation) or when long-lived secrets\nare being handled (e.g. Public TLS Certs).\nNotice that secrets can be stored in any Source type supported by Flux, such as\nBuckets\nand\nOCI repositories\n.\nFlux specific guides on using Secrets Decryption Operators:\nBitnami Sealed Secrets\nUsing Flux to decrypt Secrets on-demand\nFlux has the ability to decrypt secrets stored in Flux sources by itself, without the need of\nadditional controllers installed in the cluster. The approach relies on keeping in Flux sources\nencrypted Kubernetes Secrets, which are decrypted on-demand with\nSOPS\n, just before they are\ndeployed into the target clusters.\nThis approach is more flexible than using\nSealed Secrets\n, as\nSOPS\nsupports cloud-based Key\nManagement Services of the major cloud providers (Azure KeyVault, GCP KMS and AWS KMS), HashiCorp\nVault, as well as “off-line” decryption using Age and PGP.\nThis mechanism supports\nkustomize-secretgenerator\nwhich ensures that dependent workloads will\nreload automatically and start using the latest version of the secret. Notice that most approaches\nthat are based on Kubernetes Secrets would require something like\nstakater/Reloader\nto achieve\nthe same result. The\nKubernetes blog\nexplains quite well how this works.\nThe security concerns of this approach are similar to the Secrets Decryption Operators, but with\nthe added benefit that no additional controllers are required, therefore reducing resources consumption\nand the attack surface. When using external providers (e.g. KMS, Vault), remember that they can become\na single point of failure, if they are deleted by mistake (or unavailable by extended periods) this\ncould impact your solution.\nFlux supports the two main names in Encrypted Secrets and has specific how-to guides for them:\nMozilla SOPS Guide\nSecrets decryption\nSecrets Synchronized by Operators\nThe source of truth for your secrets can reside outside of the cluster, and then be synchronised\ninto the cluster as Kubernetes Secrets by operators. Much like encrypted secrets, this process\nis transparent to the workloads in the cluster.\nTwo examples of this type of operator are\n1Password Operator\nand\nExternal Secrets Operator\n.\nBut given their nature, Flux is able to support any operator that manages Kubernetes secrets.\nThis approach provides a level of redundancy by default, as secrets are kept at both the cluster\nand the remote source, so small failures can go undetected. It supports hybrid workloads\nquite well, when some secrets have to be shared with applications that are not Kubernetes-based.\nWhen using mutable secrets, it could be hard for Flux or the dependent applications to know\nwhether they are using the latest version of a given secret. In such cases, immutable secrets,\nwhere the name also contains the version of the secret, may help.\nTake into account the loading times when provisioning a new cluster, as that can become a\nbottleneck slowing down the provisioning time as the number of secrets increases.\nFlux supports all operators that provide this functionality.\nSecrets mounted via CSI Drivers\nAnother way to bring external secrets into Kubernetes, is the use of CSI Drivers,\nwhich mounts secrets as files directly into a Pod filesystem, instead of generating\nnative Kubernetes Secrets.\nDue to the way it works, the secrets are not accessible within the Kubernetes Control\nPlane, so although you can use it with your workloads, it won’t work when providing\nto CustomResourceTypes (CRDs) that need a reference to a secret\n(e.g.\n.spec.secretRef.name\nin\nGitRepository\n).\nWith CSI Drivers, the mounting takes place at Pod starting time, so issues accessing\nthe external source of the secrets may be more impactful.\nHere are a few CSI providers:\nHashiCorp Vault\nAzure KeyVault\nAWS Secrets Manager\nGCP CSI Driver\nDirect access to out-of-cluster Secrets\nDirect access to a secret management solution that resides outside of a Kubernetes\ncluster is also an option. Which could be a useful alternative when lifting and\nshifting legacy applications that already depend on such approach.\nHere the secret management solution will become a single point of failure,\nexpect issues when it goes temporarily unavailable and make sure to have disaster recovery plans.\nAlso observe throttling limits of cloud solutions, given that different applications\nmay be targeting the same Secret Manager, without a rate limiter across all of them,\nthis could easily lead to an outage at scale.\nFlux currently does not directly fetch secrets from out-of-cluster solutions, in the\nsame way that most Kubernetes native tools don’t, therefore this approach may need to\nbe combined with things such as Secrets Synchronized by Operators. However, this will\nnot block the ability of your applications to do so.\nBig Picture - Things to consider\nOnce you are aware of the different tools in the toolbox, it is important to align them\nwith your actual requirements, taking into account some key points:\nExpiration and Rotation\nSecrets should have an expiration time, and ideally such expiration should be enforced,\nso that the potential of leakage has a well-defined risk window.\nTo facilitate the uninterrupted use of the dependent applications, rotation should be\nautomated taking into account that at times different versions of the same secret\n(old and new) may need to be supported at the same time - e.g. whilst validating a\nnew version of the application that is being deployed.\nBoth secrets can remain active during a time window, but once the new version is\nvalidated after deployment, the previous secrets can be safely decommissioned.\nCloud KMS solutions tend to provide secret versioning built-in.\nAccess Management and Auditing\nAccess to secrets should be restricted to the servers and applications within the environment\nthey need to be accessed. The same goes for users and service accounts.\nWhen considering the different solutions, it is important to note how they hang together\nand what the gaps are. If you have a strong requirement for access and auditing controls,\nhaving a well-defined api-server auditing in place, together with tight RBAC policies in your\ncluster is only part of the problem. Also take into account how those secrets are sourced,\nstored and handled. Maybe having secrets stored (even if in encrypted form) in an easily\naccessible Flux source that has a loosely defined RBAC and no auditing in place may not meet\nsuch requirements.\nLeast Privileged and Segregation of duties\nThe scope of each secret must be carefully considered to decrease the blast radius in\ncase of breach. A trade-off must be reached to attain a balance between the two extremes:\nhaving a single secret that has all the access, versus having too many secrets that are\nalways used in combination.\nSharing the same secret across different scopes, just because they have the same permissions\nmay lead to disruption if such secret needs to be quickly rotated.\nDisaster Recovery\nThe entire provisioning of your infrastructure and application must take into account\nbreak the glass procedures that are secure, provide relevant security controls (e.g. auditing)\nand cannot be misused to bypass other processes (e.g. Access Management).\nAround disaster recovery scenarios, consider how they align with your Availability and\nConfidentiality requirements.\nDon’t co-locate ciphertext with encryption keys\nIt should go without saying, but never place secrets together with keys that can provide privilege\nescalation routes. For example, if you store the decryption key for your secrets in GitHub secrets,\nand all your encrypted secrets are stored in the same repository, a single GitHub account\n(with enough access) compromised is enough for all your secrets to be decrypted.\nInstead, segregate encryption keys from ciphertext and understand what needs to be compromised\nfor the data to be at risk.\nSingle Points of Failure\nIdentify all potential single points of failure and ensure that there is a way around them.\nIf all your secrets are encrypted using an encryption key stored in Vault, and due to a major\nfailure your Vault instance is completely lost, and no backup is to be found, the encrypted\nsecrets are now useless. Therefore, think big picture, and ensure that each step of the way\nhas a redundancy and that process is regularly exercised.\nThe same goes for temporary single points of failure. If you rely on a Key Hierarchy Architecture\nbased on a cloud KMS to provision an on-premises cluster/application, consider the impact\nthey would have in case of a failure pre, mid or post deploy (of either cluster or applications).\nEphemeral or Single-use Secrets\nThe easiest type of secrets to manage are the ones that ephemeral; context-bound and time-bound.\nHowever, they are not supported by all use-cases. Whenever they are, prioritise their use over\nstatic or long-lived secrets.\nAn example of an ephemeral secret that is time-bound, is a token provided by cloud providers to\nany application running within a given Cloud Machine. Those tokens are generated automatically,\nand have a short expiration time. In some cases you can even tie them to a network boundary,\nmeaning that even if they get breached, they won’t be able to be used outside the current\ncontext.\nFlux supports\ncontextual authorization\nfor the major Cloud Providers, be aware of the supported\nfeatures and use them whenever possible.\nDetect “chicken and egg” scenarios\nFlux won’t protect you from yourself. On a running cluster, it is quite easy to incrementally fall\ninto the trap of building a non-provisionable cluster. For example, if your first Kustomization\ndepends on a CustomResourceType (CRD) to deploy a secret, which is only deployed as part of another\nKustomization, Flux may not be able to redeploy your sources from scratch on a new cluster.\nMake sure that your pipeline identifies and tests such scenarios. Automate the provisioning of clusters\nthat can test the entire E2E of your deployment process, and ensure that it is executed regularly.\nSummary\nFlux supports a wide range of Secret Management solutions. And it is up to its users\nto define what works best for their use case. This subject isn’t easy, and due diligence\nis important to ensure the appropriate level of security controls are in place.\nOverall, none of the approaches covered above are inherently secure or insecure, but they\nare rather part of a big picture in which what matters the most is the weakest link\nand how it all hangs together. As with all things around security, a layered approach is\nrecommended.\nTake into account your threat model, availability and resilience requirements\nwhen deciding what works best for you, and rest assured that a combination of some of\nthe above will make more sense, especially when disaster recovery and break the glass\nscenarios are considered.\nLast modified 2023-08-24:\nFix broken API anchor links (fabe6e7)",
      "code_examples": [
        {
          "language": "",
          "code": "flux bootstrap",
          "element": "<code>flux bootstrap</code>"
        },
        {
          "language": "",
          "code": "GitRepository",
          "element": "<code>GitRepository</code>"
        },
        {
          "language": "",
          "code": ".spec.secretRef.name",
          "element": "<code>.spec.secretRef.name</code>"
        },
        {
          "language": "",
          "code": "GitRepository",
          "element": "<code>GitRepository</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Secrets Management",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 3,
          "text": "What’s inside the toolbox?",
          "id": "whats-inside-the-toolbox"
        },
        {
          "level": 3,
          "text": "Big Picture - Things to consider",
          "id": "big-picture---things-to-consider"
        },
        {
          "level": 3,
          "text": "Summary",
          "id": "summary"
        },
        {
          "level": 4,
          "text": "Kubernetes Secrets",
          "id": "kubernetes-secrets"
        },
        {
          "level": 4,
          "text": "Secrets Decryption Operators",
          "id": "secrets-decryption-operators"
        },
        {
          "level": 4,
          "text": "Using Flux to decrypt Secrets on-demand",
          "id": "using-flux-to-decrypt-secrets-on-demand"
        },
        {
          "level": 4,
          "text": "Secrets Synchronized by Operators",
          "id": "secrets-synchronized-by-operators"
        },
        {
          "level": 4,
          "text": "Secrets mounted via CSI Drivers",
          "id": "secrets-mounted-via-csi-drivers"
        },
        {
          "level": 4,
          "text": "Direct access to out-of-cluster Secrets",
          "id": "direct-access-to-out-of-cluster-secrets"
        },
        {
          "level": 4,
          "text": "Expiration and Rotation",
          "id": "expiration-and-rotation"
        },
        {
          "level": 4,
          "text": "Access Management and Auditing",
          "id": "access-management-and-auditing"
        },
        {
          "level": 4,
          "text": "Least Privileged and Segregation of duties",
          "id": "least-privileged-and-segregation-of-duties"
        },
        {
          "level": 4,
          "text": "Disaster Recovery",
          "id": "disaster-recovery"
        },
        {
          "level": 4,
          "text": "Don’t co-locate ciphertext with encryption keys",
          "id": "dont-co-locate-ciphertext-with-encryption-keys"
        },
        {
          "level": 4,
          "text": "Single Points of Failure",
          "id": "single-points-of-failure"
        },
        {
          "level": 4,
          "text": "Ephemeral or Single-use Secrets",
          "id": "ephemeral-or-single-use-secrets"
        },
        {
          "level": 4,
          "text": "Detect “chicken and egg” scenarios",
          "id": "detect-chicken-and-egg-scenarios"
        }
      ],
      "timestamp": 1750732740.7838988
    },
    {
      "url": "https://fluxcd.io/flux/security/slsa-assessment/",
      "title": "SLSA Assessment | Flux",
      "content": "Docs\nSecurity\nSLSA Assessment\nSLSA Assessment\nFlux assessment of SLSA Level 3 requirements.\nIntroduction\nSupply Chain Levels for Software Artifacts, or SLSA (pronounced “salsa”),\nis a security framework which aims to prevent tampering and secure artifacts in a project.\nSLSA is designed to support automation that tracks code handling from source to binary\nprotecting against tampering regardless of the complexity of the software supply chain.\nStarting with Flux version 2.0.0, the build, release and provenance portions of the Flux\nproject supply chain provisionally meet\nSLSA Build Level 3\n.\nSLSA Requirements and Flux Compliance State\nWhat follows is an assessment made by members of the Flux core maintainers team\non how Flux v2.0 complies with the Build Level 3 requirements as specified by\nSLSA v1.0\n.\nProducer Requirements\nRequirement\nRequired at SLSA L3\nMet by Flux\nChoose an appropriate build platform\nYes\nYes\nFollow a consistent build process\nYes\nYes\nDistribute provenance\nYes\nYes\nChoose an appropriate build platform\nThe producer MUST choose a builder capable of producing Build Level 3 provenance.\nThe Flux project uses Git for source code management and the Flux project’s repositories are hosted on GitHub under\nthe FluxCD organization.\nAll the Flux maintainers are required to have two-factor authentication enabled and to sign-off all their\ncontributions.\nThe Flux project uses GitHub Actions and GitHub Runners for building all its release artifacts.\nThe build and release process runs in isolation on an ephemeral environment provided by GitHub-hosted runners.\nFollow a consistent build process\nThe producer MUST build their artifact in a consistent manner such that verifiers can form expectations about the\nbuild process.\nThe build and release process is defined in code (GitHub Workflows and Makefiles) and is kept under version control.\nThe GitHub Workflows make use of GitHub Actions pinned to their Git commit SHA and are kept up-to-date using GitHub\nDependabot.\nAll changes to build and release process are done via Pull Requests that must be approved by at least one Flux\nmaintainer.\nThe release process can only be kicked off by a Flux maintainer by pushing a Git tag in the semver format.\nDistribute provenance\nThe producer MUST distribute provenance to artifact consumers.\nThe Flux project uses the\nofficial\nSLSA GitHub Generator project\nfor provenance\ngeneration and distribution.\nThe provenance for the release artifacts published to GitHub releases (binaries, SBOMs, deploy manifests, source code)\nis generated using the\ngenerator_generic_slsa3\nGitHub Workflow provided by\nthe\nSLSA GitHub Generator project\n.\nThe provenance for the release artifacts published to GitHub Container Registry and to DockerHub (Flux controllers\nmulti-arch container images) is generated using the\ngenerator_container_slsa3\nGitHub Workflow provided by\nthe\nSLSA GitHub Generator project\n.\nBuild Platform Requirements\nProvenance generation\nRequirement\nRequired at SLSA L3\nMet by Flux\nProvenance Exists\nYes\nYes\nProvenance is Authentic\nYes\nYes\nProvenance is Unforgeable\nYes\nYes\nThe build process MUST generate provenance that unambiguously identifies the output package by cryptographic digest\nand describes how that package was produced.\nThe Flux project release workflows make use of the\nofficial\nSLSA GitHub Generator project\nfor provenance\ngeneration.\nThe provenance file stores the SHA-256 hashes of the release artifacts (binaries, SBOMs, deploy manifests, source\ncode).\nThe provenance identifies the Flux container images using their digest in SHA-256 format.\nConsumers MUST be able to validate the authenticity of the provenance attestation in order to ensure integrity and\ndefine trust.\nThe provenance is signed by Sigstore Cosign using the GitHub OIDC identity and the public key to verify the provenance\nis stored in the public\nRekor transparency log\n.\nThe release process and the provenance generation are run in isolation on an ephemeral environment provided by\nGitHub-hosted runners.\nThe provenance of the Flux release artifacts (binaries, container images, SBOMs, deploy manifests) can be verified\nusing the official\nSLSA verifier tool\n.\nProvenance MUST be strongly resistant to forgery by tenants.\nThe provenance generation workflows run on ephemeral and isolated virtual machines which are fully managed by GitHub.\nThe provenance signing secrets are ephemeral and are generated through\nSigstore’s\nkeyless signing\nprocedure.\nThe\nSLSA GitHub generator\nruns on separate virtual machines\nthan the build and release process, so that the Flux build scripts don’t have access to the signing secrets.\nIsolation strength\nRequirement\nRequired at SLSA L3\nMet by Flux\nHosted\nYes\nYes\nIsolated\nYes\nYes\nAll build steps ran using a hosted build platform on shared or dedicated infrastructure.\nThe release process and the provenance generation are run in isolation on an ephemeral environment provided by\nGitHub-hosted runners.\nThe provenance generation is decoupled from the build process,\nthe\nSLSA GitHub generator\nruns on separate virtual machines\nfully managed by GitHub.\nThe build platform ensured that the build steps ran in an isolated environment, free of unintended external influence.\nThe release process can only be kicked off by a Flux maintainer by pushing a Git tag in the semver format.\nThe release process runs on ephemeral and isolated virtual machines which are fully managed by GitHub.\nThe release process can’t access the provenance signing key, because the provenance generator runs in isolation on\nseparate GitHub-hosted runners.\nProvenance verification\nThe provenance of the Flux release artifacts (binaries, container images, SBOMs, deploy manifests)\ncan be verified using the official\nSLSA verifier tool\n.\nContainer images\nThe provenance of the Flux multi-arch container images hosted on GitHub Container Registry\nand DockerHub can be verified using the official\nSLSA verifier tool\nand\nSigstore Cosign\n.\nWhat follows is the list of Flux components along with their minimum required version for provenance verification.\nGit Repository\nImages\nMin version\nProvenance (SLSA L3)\nflux2\ndocker.io/fluxcd/flux-cli\nghcr.io/fluxcd/flux-cli\nv2.0.1\nYes\nsource-controller\ndocker.io/fluxcd/source-contoller\nghcr.io/fluxcd/source-contoller\nv1.0.0\nYes\nkustomize-controller\ndocker.io/fluxcd/kustomize-contoller\nghcr.io/fluxcd/kustomize-contoller\nv1.0.0\nYes\nnotification-controller\ndocker.io/fluxcd/notification-contoller\nghcr.io/fluxcd/notification-contoller\nv1.0.0\nYes\nhelm-controller\ndocker.io/fluxcd/helm-contoller\nghcr.io/fluxcd/helm-contoller\nv0.35.0\nYes\nimage-reflector-controller\ndocker.io/fluxcd/image-reflector-contoller\nghcr.io/fluxcd/image-reflector-contoller\nv0.29.0\nYes\nimage-automation-controller\ndocker.io/fluxcd/image-automation-contoller\nghcr.io/fluxcd/image-automation-contoller\nv0.35.0\nYes\nExample\nWe will be using the\nsource-controller\ncontainer\nimage hosted on GHCR for this example, but these instructions can be used for all Flux container images.\nFirst, collect the digest of the image to verify:\n$\ncrane digest ghcr.io/fluxcd/source-controller:v1.0.0\nsha256:8dfd386a338eab2fde70cd7609e3b35a6e2f30283ecf2366da53013295fa65f3\nUsing the digest, verify the provenance of the Flux controller by specifying the repository and version:\n$\nslsa-verifier verify-image ghcr.io/fluxcd/source-controller:v1.0.0@sha256:8dfd386a338eab2fde70cd7609e3b35a6e2f30283ecf2366da53013295fa65f3 --source-uri github.com/fluxcd/source-controller --source-tag v1.0.0\nVerified build using builder https://github.comslsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.7.0 at commit a40e0da705f26710077a7591f9dad05b7cd55acd\nPASSED: Verified SLSA provenance\nUsing Cosign, verify the SLSA provenance attestation by specifying the workflow and GitHub OIDC issuer:\n$\ncosign verify-attestation --type slsaprovenance --certificate-identity-regexp https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v --certificate-oidc-issuer https://token.actions.githubusercontent.com ghcr.io/fluxcd/source-controller:v1.0.0\nVerification for ghcr.io/fluxcd/source-controller:v1.0.0 --\nThe following checks were performed on each of these signatures:\n- The cosign claims were validated\n- Existence of the claims in the transparency log was verified offline\n- The code-signing certificate was verified using trusted certificate authority certificates\nCertificate subject: https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.7.0\nCertificate issuer URL: https://token.actions.githubusercontent.com\nGitHub Workflow Trigger: push\nGitHub Workflow SHA: a40e0da705f26710077a7591f9dad05b7cd55acd\nGitHub Workflow Name: release\nGitHub Workflow Repository: fluxcd/source-controller\nGitHub Workflow Ref: refs/tags/v1.0.0\nFlux artifacts\nThe provenance of the Flux release artifacts (binaries, container images, SBOMs, deploy manifests) published on\nGitHub can be verified using the official\nSLSA verifier tool\n.\nExample\nIn this example we use the Flux SBOM file,\nbut the instructions can be used for all artifacts included with the Flux release.\nFirst, download the release artifacts from GitHub:\nFLUX_VER\n=\n2.0.1\n&&\n\\\ngh release download v\n${\nFLUX_VER\n}\n-R\n=\nfluxcd/flux2 -p\n=\n\"*\"\nUsing the\nprovenance.intoto.jsonl\nfile,\nverify the provenance attestation of the Flux SBOM (\nflux_<version>_sbom.spdx.json\n):\n$\nslsa-verifier verify-artifact --provenance-path provenance.intoto.jsonl --source-uri github.com/fluxcd/flux2 --source-tag v\n${\nFLUX_VER\n}\nflux_\n${\nFLUX_VER\n}\n_sbom.spdx.json\nVerified signature against tlog entry index 27066821 at URL: https://rekor.sigstore.dev/api/v1/log/entries/24296fb24b8ad77ac2d2dc6381ec7f1f04d991344771214c5fb5861621dbd9da6f0551f806cbf609\nVerified build using builder https://github.comslsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@refs/tags/v1.7.0 at commit 9b3162495ce1b99b1fcdf137c553f543eafe3ec7\nVerifying artifact flux_2.0.1_sbom.spdx.json: PASSED\nPASSED: Verified SLSA provenance\nLast modified 2023-07-11:\nAdd SBOM provenance verification to SLSA guide (d362d2d)",
      "code_examples": [
        {
          "language": "",
          "code": "generator_generic_slsa3",
          "element": "<code>generator_generic_slsa3</code>"
        },
        {
          "language": "",
          "code": "generator_container_slsa3",
          "element": "<code>generator_container_slsa3</code>"
        },
        {
          "language": "",
          "code": "docker.io/fluxcd/flux-cli",
          "element": "<code>docker.io/fluxcd/flux-cli</code>"
        },
        {
          "language": "",
          "code": "ghcr.io/fluxcd/flux-cli",
          "element": "<code>ghcr.io/fluxcd/flux-cli</code>"
        },
        {
          "language": "",
          "code": "docker.io/fluxcd/source-contoller",
          "element": "<code>docker.io/fluxcd/source-contoller</code>"
        },
        {
          "language": "",
          "code": "ghcr.io/fluxcd/source-contoller",
          "element": "<code>ghcr.io/fluxcd/source-contoller</code>"
        },
        {
          "language": "",
          "code": "docker.io/fluxcd/kustomize-contoller",
          "element": "<code>docker.io/fluxcd/kustomize-contoller</code>"
        },
        {
          "language": "",
          "code": "ghcr.io/fluxcd/kustomize-contoller",
          "element": "<code>ghcr.io/fluxcd/kustomize-contoller</code>"
        },
        {
          "language": "",
          "code": "docker.io/fluxcd/notification-contoller",
          "element": "<code>docker.io/fluxcd/notification-contoller</code>"
        },
        {
          "language": "",
          "code": "ghcr.io/fluxcd/notification-contoller",
          "element": "<code>ghcr.io/fluxcd/notification-contoller</code>"
        },
        {
          "language": "",
          "code": "docker.io/fluxcd/helm-contoller",
          "element": "<code>docker.io/fluxcd/helm-contoller</code>"
        },
        {
          "language": "",
          "code": "ghcr.io/fluxcd/helm-contoller",
          "element": "<code>ghcr.io/fluxcd/helm-contoller</code>"
        },
        {
          "language": "",
          "code": "docker.io/fluxcd/image-reflector-contoller",
          "element": "<code>docker.io/fluxcd/image-reflector-contoller</code>"
        },
        {
          "language": "",
          "code": "ghcr.io/fluxcd/image-reflector-contoller",
          "element": "<code>ghcr.io/fluxcd/image-reflector-contoller</code>"
        },
        {
          "language": "",
          "code": "docker.io/fluxcd/image-automation-contoller",
          "element": "<code>docker.io/fluxcd/image-automation-contoller</code>"
        },
        {
          "language": "",
          "code": "ghcr.io/fluxcd/image-automation-contoller",
          "element": "<code>ghcr.io/fluxcd/image-automation-contoller</code>"
        },
        {
          "language": "",
          "code": "$crane digest ghcr.io/fluxcd/source-controller:v1.0.0sha256:8dfd386a338eab2fde70cd7609e3b35a6e2f30283ecf2366da53013295fa65f3",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d..."
        },
        {
          "language": "language-console",
          "code": "$crane digest ghcr.io/fluxcd/source-controller:v1.0.0sha256:8dfd386a338eab2fde70cd7609e3b35a6e2f30283ecf2366da53013295fa65f3",
          "element": "<code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d09;font-weight:700\">$</span> crane digest ghcr.io/fluxcd/source-controller:v1.0.0\n</span></s..."
        },
        {
          "language": "",
          "code": "$slsa-verifier verify-image ghcr.io/fluxcd/source-controller:v1.0.0@sha256:8dfd386a338eab2fde70cd7609e3b35a6e2f30283ecf2366da53013295fa65f3 --source-uri github.com/fluxcd/source-controller --source-tag v1.0.0Verified build using builder https://github.comslsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.7.0 at commit a40e0da705f26710077a7591f9dad05b7cd55acdPASSED: Verified SLSA provenance",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d..."
        },
        {
          "language": "language-console",
          "code": "$slsa-verifier verify-image ghcr.io/fluxcd/source-controller:v1.0.0@sha256:8dfd386a338eab2fde70cd7609e3b35a6e2f30283ecf2366da53013295fa65f3 --source-uri github.com/fluxcd/source-controller --source-tag v1.0.0Verified build using builder https://github.comslsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.7.0 at commit a40e0da705f26710077a7591f9dad05b7cd55acdPASSED: Verified SLSA provenance",
          "element": "<code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d09;font-weight:700\">$</span> slsa-verifier verify-image ghcr.io/fluxcd/source-controller:v1...."
        },
        {
          "language": "",
          "code": "$cosign verify-attestation --type slsaprovenance --certificate-identity-regexp https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v --certificate-oidc-issuer https://token.actions.githubusercontent.com ghcr.io/fluxcd/source-controller:v1.0.0Verification for ghcr.io/fluxcd/source-controller:v1.0.0 --The following checks were performed on each of these signatures:- The cosign claims were validated- Existence of the claims in the transparency log was verified offline- The code-signing certificate was verified using trusted certificate authority certificatesCertificate subject: https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.7.0Certificate issuer URL: https://token.actions.githubusercontent.comGitHub Workflow Trigger: pushGitHub Workflow SHA: a40e0da705f26710077a7591f9dad05b7cd55acdGitHub Workflow Name: releaseGitHub Workflow Repository: fluxcd/source-controllerGitHub Workflow Ref: refs/tags/v1.0.0",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d..."
        },
        {
          "language": "language-console",
          "code": "$cosign verify-attestation --type slsaprovenance --certificate-identity-regexp https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v --certificate-oidc-issuer https://token.actions.githubusercontent.com ghcr.io/fluxcd/source-controller:v1.0.0Verification for ghcr.io/fluxcd/source-controller:v1.0.0 --The following checks were performed on each of these signatures:- The cosign claims were validated- Existence of the claims in the transparency log was verified offline- The code-signing certificate was verified using trusted certificate authority certificatesCertificate subject: https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.7.0Certificate issuer URL: https://token.actions.githubusercontent.comGitHub Workflow Trigger: pushGitHub Workflow SHA: a40e0da705f26710077a7591f9dad05b7cd55acdGitHub Workflow Name: releaseGitHub Workflow Repository: fluxcd/source-controllerGitHub Workflow Ref: refs/tags/v1.0.0",
          "element": "<code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d09;font-weight:700\">$</span> cosign verify-attestation --type slsaprovenance --certificate-i..."
        },
        {
          "language": "",
          "code": "FLUX_VER=2.0.1&&\\gh release download v${FLUX_VER}-R=fluxcd/flux2 -p=\"*\"",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span><span style=\"color:#bb60d5\">..."
        },
        {
          "language": "language-shell",
          "code": "FLUX_VER=2.0.1&&\\gh release download v${FLUX_VER}-R=fluxcd/flux2 -p=\"*\"",
          "element": "<code class=\"language-shell\" data-lang=\"shell\"><span style=\"display:flex\"><span><span style=\"color:#bb60d5\">FLUX_VER</span><span style=\"color:#666\">=</span>2.0.1 <span style=\"color:#666\">&amp;&amp;</s..."
        },
        {
          "language": "",
          "code": "provenance.intoto.jsonl",
          "element": "<code>provenance.intoto.jsonl</code>"
        },
        {
          "language": "",
          "code": "flux_<version>_sbom.spdx.json",
          "element": "<code>flux_&lt;version&gt;_sbom.spdx.json</code>"
        },
        {
          "language": "",
          "code": "$slsa-verifier verify-artifact --provenance-path provenance.intoto.jsonl --source-uri github.com/fluxcd/flux2 --source-tag v${FLUX_VER}flux_${FLUX_VER}_sbom.spdx.jsonVerified signature against tlog entry index 27066821 at URL: https://rekor.sigstore.dev/api/v1/log/entries/24296fb24b8ad77ac2d2dc6381ec7f1f04d991344771214c5fb5861621dbd9da6f0551f806cbf609Verified build using builder https://github.comslsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@refs/tags/v1.7.0 at commit 9b3162495ce1b99b1fcdf137c553f543eafe3ec7Verifying artifact flux_2.0.1_sbom.spdx.json: PASSEDPASSED: Verified SLSA provenance",
          "element": "<pre style=\"background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4\" tabindex=\"0\"><code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d..."
        },
        {
          "language": "language-console",
          "code": "$slsa-verifier verify-artifact --provenance-path provenance.intoto.jsonl --source-uri github.com/fluxcd/flux2 --source-tag v${FLUX_VER}flux_${FLUX_VER}_sbom.spdx.jsonVerified signature against tlog entry index 27066821 at URL: https://rekor.sigstore.dev/api/v1/log/entries/24296fb24b8ad77ac2d2dc6381ec7f1f04d991344771214c5fb5861621dbd9da6f0551f806cbf609Verified build using builder https://github.comslsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@refs/tags/v1.7.0 at commit 9b3162495ce1b99b1fcdf137c553f543eafe3ec7Verifying artifact flux_2.0.1_sbom.spdx.json: PASSEDPASSED: Verified SLSA provenance",
          "element": "<code class=\"language-console\" data-lang=\"console\"><span style=\"display:flex\"><span><span style=\"color:#c65d09;font-weight:700\">$</span> slsa-verifier verify-artifact --provenance-path provenance.into..."
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "SLSA Assessment",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 2,
          "text": "SLSA Requirements and Flux Compliance State",
          "id": "slsa-requirements-and-flux-compliance-state"
        },
        {
          "level": 2,
          "text": "Provenance verification",
          "id": "provenance-verification"
        },
        {
          "level": 3,
          "text": "Producer Requirements",
          "id": "producer-requirements"
        },
        {
          "level": 3,
          "text": "Build Platform Requirements",
          "id": "build-platform-requirements"
        },
        {
          "level": 3,
          "text": "Container images",
          "id": "container-images"
        },
        {
          "level": 3,
          "text": "Example",
          "id": "example"
        },
        {
          "level": 3,
          "text": "Flux artifacts",
          "id": "flux-artifacts"
        },
        {
          "level": 3,
          "text": "Example",
          "id": "example-1"
        },
        {
          "level": 4,
          "text": "Choose an appropriate build platform",
          "id": "choose-an-appropriate-build-platform"
        },
        {
          "level": 4,
          "text": "Follow a consistent build process",
          "id": "follow-a-consistent-build-process"
        },
        {
          "level": 4,
          "text": "Distribute provenance",
          "id": "distribute-provenance"
        },
        {
          "level": 4,
          "text": "Provenance generation",
          "id": "provenance-generation"
        },
        {
          "level": 4,
          "text": "Isolation strength",
          "id": "isolation-strength"
        }
      ],
      "timestamp": 1750732743.8329978
    }
  ],
  "total_pages": 14,
  "errors": []
}