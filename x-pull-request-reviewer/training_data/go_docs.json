{
  "technology": "go",
  "base_url": "https://golang.org/doc/",
  "pages": [
    {
      "url": "https://golang.org/doc/devel/release",
      "title": "Release History - The Go Programming Language",
      "content": "Release History\nThis page summarizes the changes between official stable releases of Go.\nThe\nchange log\nhas the full details.\nTo update to a specific release, use:\ngit fetch --tags\ngit checkout\ngoX.Y.Z\nRelease Policy\nEach major Go release is supported until there are two newer major releases.\nFor example, Go 1.5 was supported until the Go 1.7 release, and Go 1.6 was\nsupported until the Go 1.8 release.\nWe fix critical problems, including\ncritical security problems\n,\nin supported releases as needed by issuing minor revisions\n(for example, Go 1.6.1, Go 1.6.2, and so on).\ngo1.24.0 (released 2025-02-11)\nGo 1.24.0 is a major release of Go.\n\tRead the\nGo 1.24 Release Notes\nfor more information.\nMinor revisions\ngo1.24.1\n\t\t(released 2025-03-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to cgo, the compiler, the\ngo\ncommand, and the\nreflect\n,\nruntime\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.24.1 milestone\non our issue tracker for details.\ngo1.24.2\n\t\t(released 2025-04-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the runtime, the\ngo\ncommand, and the\ncrypto/tls\n,\ngo/types\n,\nnet/http\n, and\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.24.2 milestone\non our issue tracker for details.\ngo1.24.3\n\t\t(released 2025-05-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nos\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the runtime, the compiler, the linker, the\ngo\ncommand, and the\ncrypto/tls\nand\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.24.3 milestone\non our issue tracker for details.\ngo1.24.4\n\t\t(released 2025-06-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\n,\nnet/http\n, and\nos\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker, the\ngo\ncommand, and the\nhash/maphash\nand\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.24.4 milestone\non our issue tracker for details.\ngo1.23.0 (released 2024-08-13)\nGo 1.23.0 is a major release of Go.\n\tRead the\nGo 1.23 Release Notes\nfor more information.\nMinor revisions\ngo1.23.1\n\t\t(released 2024-09-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nencoding/gob\n,\ngo/build/constraint\n, and\ngo/parser\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\ndatabase/sql\n,\ngo/types\n,\nos\n,\nruntime/trace\n, and\nunique\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.1 milestone\non our issue tracker for details.\ngo1.23.2\n\t\t(released 2024-10-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, cgo, the runtime, and the\nmaps\n,\nos\n,\nos/exec\n,\ntime\n, and\nunique\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.2 milestone\non our issue tracker for details.\ngo1.23.3\n\t\t(released 2024-11-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the linker, the runtime, and the\nnet/http\n,\nos\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.3 milestone\non our issue tracker for details.\ngo1.23.4\n\t\t(released 2024-12-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, the runtime, the\ntrace\ncommand, and the\nsyscall\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.4 milestone\non our issue tracker for details.\ngo1.23.5\n\t\t(released 2025-01-16)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\nand\nnet/http\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the runtime, and the\nnet\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.5 milestone\non our issue tracker for details.\ngo1.23.6\n\t\t(released 2025-02-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/elliptic\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler and the\ngo\ncommand.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.6 milestone\non our issue tracker for details.\ngo1.23.7\n\t\t(released 2025-03-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to cgo, the compiler, and the\nreflect\n,\nruntime\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.7 milestone\non our issue tracker for details.\ngo1.23.8\n\t\t(released 2025-04-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the runtime and the\ngo\ncommand.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.8 milestone\non our issue tracker for details.\ngo1.23.9\n\t\t(released 2025-05-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime and the linker.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.9 milestone\non our issue tracker for details.\ngo1.23.10\n\t\t(released 2025-06-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nos\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.23.10 milestone\non our issue tracker for details.\ngo1.22.0 (released 2024-02-06)\nGo 1.22.0 is a major release of Go.\n\tRead the\nGo 1.22 Release Notes\nfor more information.\nMinor revisions\ngo1.22.1\n\t\t(released 2024-03-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\n,\nhtml/template\n,\nnet/http\n,\nnet/http/cookiejar\n, and\nnet/mail\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, the\ntrace\ncommand, and the\ngo/types\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.1 milestone\non our issue tracker for details.\ngo1.22.2\n\t\t(released 2024-04-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the linker, and the\nencoding/gob\n,\ngo/types\n,\nnet/http\n, and\nruntime/trace\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.2 milestone\non our issue tracker for details.\ngo1.22.3\n\t\t(released 2024-05-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand and the\nnet\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the runtime, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.3 milestone\non our issue tracker for details.\ngo1.22.4\n\t\t(released 2024-06-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/zip\nand\nnet/netip\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the linker, the runtime, and the\nos\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.4 milestone\non our issue tracker for details.\ngo1.22.5\n\t\t(released 2024-07-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, cgo, the\ngo\ncommand, the linker, the runtime, and the\ncrypto/tls\n,\ngo/types\n,\nnet\n,\nnet/http\n, and\nos/exec\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.5 milestone\non our issue tracker for details.\ngo1.22.6\n\t\t(released 2024-08-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the\ngo\ncommand, the compiler, the linker, the\ntrace\ncommand, the\ncovdata\ncommand, and the\nbytes\n,\ngo/types\n, and\nos/exec\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.6 milestone\non our issue tracker for details.\ngo1.22.7\n\t\t(released 2024-09-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nencoding/gob\n,\ngo/build/constraint\n, and\ngo/parser\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the\nfix\ncommand and the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.7 milestone\non our issue tracker for details.\ngo1.22.8\n\t\t(released 2024-10-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, and the\nmaps\nand\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.8 milestone\non our issue tracker for details.\ngo1.22.9\n\t\t(released 2024-11-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the linker.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.9 milestone\non our issue tracker for details.\ngo1.22.10\n\t\t(released 2024-12-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime and the\nsyscall\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.10 milestone\non our issue tracker for details.\ngo1.22.11\n\t\t(released 2025-01-16)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\nand\nnet/http\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.11 milestone\non our issue tracker for details.\ngo1.22.12\n\t\t(released 2025-02-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/elliptic\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler and the\ngo\ncommand.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.22.12 milestone\non our issue tracker for details.\ngo1.21.0 (released 2023-08-08)\nGo 1.21.0 is a major release of Go.\n\tRead the\nGo 1.21 Release Notes\nfor more information.\nMinor revisions\ngo1.21.1\n\t\t(released 2023-09-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tfour\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncmd/go\n,\ncrypto/tls\n, and\nhtml/template\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the linker, the runtime, and the\ncontext\n,\ncrypto/tls\n,\nencoding/gob\n,\nencoding/xml\n,\ngo/types\n,\nnet/http\n,\nos\n, and\npath/filepath\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.1 milestone\non our issue tracker for details.\ngo1.21.2\n\t\t(released 2023-10-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tone\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncmd/go\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the linker, the runtime, and the\nruntime/metrics\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.2 milestone\non our issue tracker for details.\ngo1.21.3\n\t\t(released 2023-10-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.3 milestone\non our issue tracker for details.\ngo1.21.4\n\t\t(released 2023-11-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\npath/filepath\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker, the runtime, the compiler, and the\ngo/types\n,\nnet/http\n, and\nruntime/cgo\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.4 milestone\non our issue tracker for details.\ngo1.21.5\n\t\t(released 2023-12-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand, and the\nnet/http\nand\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\ncrypto/rand\n,\nnet\n,\nos\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.5 milestone\non our issue tracker for details.\ngo1.21.6\n\t\t(released 2024-01-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, the runtime, and the\ncrypto/tls\n,\nmaps\n, and\nruntime/pprof\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.6 milestone\non our issue tracker for details.\ngo1.21.7\n\t\t(released 2024-02-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\ncrypto/x509\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.7 milestone\non our issue tracker for details.\ngo1.21.8\n\t\t(released 2024-03-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\n,\nhtml/template\n,\nnet/http\n,\nnet/http/cookiejar\n, and\nnet/mail\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the\ngo\ncommand and the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.8 milestone\non our issue tracker for details.\ngo1.21.9\n\t\t(released 2024-04-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker, and the\ngo/types\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.9 milestone\non our issue tracker for details.\ngo1.21.10\n\t\t(released 2024-05-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.10 milestone\non our issue tracker for details.\ngo1.21.11\n\t\t(released 2024-06-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/zip\nand\nnet/netip\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\nos\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.11 milestone\non our issue tracker for details.\ngo1.21.12\n\t\t(released 2024-07-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\ncrypto/x509\n,\nnet/http\n,\nnet/netip\n, and\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.12 milestone\non our issue tracker for details.\ngo1.21.13\n\t\t(released 2024-08-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the\ngo\ncommand, the\ncovdata\ncommand, and the\nbytes\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.21.13 milestone\non our issue tracker for details.\ngo1.20 (released 2023-02-01)\nGo 1.20 is a major release of Go.\n\tRead the\nGo 1.20 Release Notes\nfor more information.\nMinor revisions\ngo1.20.1\n\t\t(released 2023-02-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/tls\n,\nmime/multipart\n,\nnet/http\n, and\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the linker, the runtime, and the\ntime\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.1 milestone\non our issue tracker for details.\ngo1.20.2\n\t\t(released 2023-03-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/elliptic\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ncovdata\ncommand, the linker, the runtime, and the\ncrypto/ecdh\n,\ncrypto/rsa\n,\ncrypto/x509\n,\nos\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.2 milestone\non our issue tracker for details.\ngo1.20.3\n\t\t(released 2023-04-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo/parser\n,\nhtml/template\n,\nmime/multipart\n,\nnet/http\n, and\nnet/textproto\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the linker, the runtime, and the\ntime\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.3 milestone\non our issue tracker for details.\ngo1.20.4\n\t\t(released 2023-05-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tthree\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nhtml/template\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the runtime, and the\ncrypto/subtle\n,\ncrypto/tls\n,\nnet/http\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.4 milestone\non our issue tracker for details.\ngo1.20.5\n\t\t(released 2023-06-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tfour\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncmd/go\nand\nruntime\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\ncrypto/rsa\n,\nnet\n, and\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.5 milestone\non our issue tracker for details.\ngo1.20.6\n\t\t(released 2023-07-11)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, cgo, the\ncover\ntool, the\ngo\ncommand, the runtime, and the\ncrypto/ecdsa\n,\ngo/build\n,\ngo/printer\n,\nnet/mail\n, and\ntext/template\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.6 milestone\non our issue tracker for details.\ngo1.20.7\n\t\t(released 2023-08-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/tls\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the assembler and the compiler.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.7 milestone\non our issue tracker for details.\ngo1.20.8\n\t\t(released 2023-09-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ttwo\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nhtml/template\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\ncrypto/tls\n,\ngo/types\n,\nnet/http\n, and\npath/filepath\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.8 milestone\non our issue tracker for details.\ngo1.20.9\n\t\t(released 2023-10-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tone\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncmd/go\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the\ngo\ncommand and the linker.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.9 milestone\non our issue tracker for details.\ngo1.20.10\n\t\t(released 2023-10-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.10 milestone\non our issue tracker for details.\ngo1.20.11\n\t\t(released 2023-11-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\npath/filepath\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.11 milestone\non our issue tracker for details.\ngo1.20.12\n\t\t(released 2023-12-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand, and the\nnet/http\nand\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler and the\ngo\ncommand.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.12 milestone\non our issue tracker for details.\ngo1.20.13\n\t\t(released 2024-01-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime and the\ncrypto/tls\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.13 milestone\non our issue tracker for details.\ngo1.20.14\n\t\t(released 2024-02-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the\ncrypto/x509\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.20.14 milestone\non our issue tracker for details.\ngo1.19 (released 2022-08-02)\nGo 1.19 is a major release of Go.\n\tRead the\nGo 1.19 Release Notes\nfor more information.\nMinor revisions\ngo1.19.1\n\t\t(released 2022-09-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nnet/url\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the\npprof\ncommand, the linker, the runtime, and the\ncrypto/tls\nand\ncrypto/x509\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.1 milestone\non our issue tracker for details.\ngo1.19.2\n\t\t(released 2022-10-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/tar\n,\nnet/http/httputil\n, and\nregexp\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the linker, the runtime, and the\ngo/types\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.2 milestone\non our issue tracker for details.\ngo1.19.3\n\t\t(released 2022-11-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nos/exec\nand\nsyscall\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler and the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.3 milestone\non our issue tracker for details.\ngo1.19.4\n\t\t(released 2022-12-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nos\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the runtime, and the\ncrypto/x509\n,\nos/exec\n, and\nsync/atomic\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.4 milestone\non our issue tracker for details.\ngo1.19.5\n\t\t(released 2023-01-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, the linker, and the\ncrypto/x509\n,\nnet/http\n,\nsync/atomic\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.5 milestone\non our issue tracker for details.\ngo1.19.6\n\t\t(released 2023-02-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/tls\n,\nmime/multipart\n,\nnet/http\n, and\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the\ngo\ncommand, the linker, the runtime, and the\ncrypto/x509\n,\nnet/http\n, and\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.6 milestone\non our issue tracker for details.\ngo1.19.7\n\t\t(released 2023-03-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/elliptic\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker, the runtime, and the\ncrypto/x509\nand\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.7 milestone\non our issue tracker for details.\ngo1.19.8\n\t\t(released 2023-04-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo/parser\n,\nhtml/template\n,\nmime/multipart\n,\nnet/http\n, and\nnet/textproto\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker, the runtime, and the\ntime\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.8 milestone\non our issue tracker for details.\ngo1.19.9\n\t\t(released 2023-05-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tthree\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nhtml/template\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the runtime, and the\ncrypto/tls\nand\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.9 milestone\non our issue tracker for details.\ngo1.19.10\n\t\t(released 2023-06-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tfour\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncmd/go\nand\nruntime\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, and the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.10 milestone\non our issue tracker for details.\ngo1.19.11\n\t\t(released 2023-07-11)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to cgo, the\ncover\ntool, the\ngo\ncommand, the runtime, and the\ngo/printer\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.11 milestone\non our issue tracker for details.\ngo1.19.12\n\t\t(released 2023-08-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/tls\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the assembler and the compiler.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.12 milestone\non our issue tracker for details.\ngo1.19.13\n\t\t(released 2023-09-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the\ngo\ncommand, and the\ncrypto/tls\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.19.13 milestone\non our issue tracker for details.\ngo1.18 (released 2022-03-15)\nGo 1.18 is a major release of Go.\n\tRead the\nGo 1.18 Release Notes\nfor more information.\nMinor revisions\ngo1.18.1\n\t\t(released 2022-04-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/elliptic\n,\ncrypto/x509\n, and\nencoding/pem\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, vet, and the\nbytes\n,\ncrypto/x509\n, and\ngo/types\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.1 milestone\non our issue tracker for details.\ngo1.18.2\n\t\t(released 2022-05-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nsyscall\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, the\ngo\ncommand, and the\ncrypto/x509\n,\ngo/types\n,\nnet/http/httptest\n,\nreflect\n, and\nsync/atomic\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.2 milestone\non our issue tracker for details.\ngo1.18.3\n\t\t(released 2022-06-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/rand\n,\ncrypto/tls\n,\nos/exec\n, and\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, and the\ncrypto/tls\nand\ntext/template/parse\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.3 milestone\non our issue tracker for details.\ngo1.18.4\n\t\t(released 2022-07-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncompress/gzip\n,\nencoding/gob\n,\nencoding/xml\n,\ngo/parser\n,\nio/fs\n,\nnet/http\n, and\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the linker, the runtime, and the\nruntime/metrics\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.4 milestone\non our issue tracker for details.\ngo1.18.5\n\t\t(released 2022-08-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nencoding/gob\nand\nmath/big\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\ntesting\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.5 milestone\non our issue tracker for details.\ngo1.18.6\n\t\t(released 2022-09-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the\npprof\ncommand, the runtime, and the\ncrypto/tls\n,\nencoding/xml\n, and\nnet\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.6 milestone\non our issue tracker for details.\ngo1.18.7\n\t\t(released 2022-10-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/tar\n,\nnet/http/httputil\n, and\nregexp\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the linker, and the\ngo/types\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.7 milestone\non our issue tracker for details.\ngo1.18.8\n\t\t(released 2022-11-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nos/exec\nand\nsyscall\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.8 milestone\non our issue tracker for details.\ngo1.18.9\n\t\t(released 2022-12-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nos\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to cgo, the compiler, the runtime, and the\ncrypto/x509\nand\nos/exec\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.9 milestone\non our issue tracker for details.\ngo1.18.10\n\t\t(released 2023-01-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, the linker, and the\ncrypto/x509\n,\nnet/http\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.18.10 milestone\non our issue tracker for details.\ngo1.17 (released 2021-08-16)\nGo 1.17 is a major release of Go.\n\tRead the\nGo 1.17 Release Notes\nfor more information.\nMinor revisions\ngo1.17.1\n\t\t(released 2021-09-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\narchive/zip\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, linker, the\ngo\ncommand, and the\ncrypto/rand\n,\nembed\n,\ngo/types\n,\nhtml/template\n, and\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.1 milestone\non our issue tracker for details.\ngo1.17.2\n\t\t(released 2021-10-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to linker and the\nmisc/wasm\ndirectory, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, the\ngo\ncommand, and the\ntext/template\nand\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.2 milestone\non our issue tracker for details.\ngo1.17.3\n\t\t(released 2021-11-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/zip\nand\ndebug/macho\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, the\nmisc/wasm\ndirectory, and the\nnet/http\nand\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.3 milestone\non our issue tracker for details.\ngo1.17.4\n\t\t(released 2021-12-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, and the\ngo/types\n,\nnet/http\n, and\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.4 milestone\non our issue tracker for details.\ngo1.17.5\n\t\t(released 2021-12-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.5 milestone\non our issue tracker for details.\ngo1.17.6\n\t\t(released 2022-01-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, and the\ncrypto/x509\n,\nnet/http\n, and\nreflect\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.6 milestone\non our issue tracker for details.\ngo1.17.7\n\t\t(released 2022-02-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand, and the\ncrypto/elliptic\nand\nmath/big\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, and the\ndebug/macho\n,\ndebug/pe\n, and\nnet/http/httptest\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.7 milestone\non our issue tracker for details.\ngo1.17.8\n\t\t(released 2022-03-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nregexp/syntax\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, the\ngo\ncommand, and the\ncrypto/x509\nand\nnet\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.8 milestone\non our issue tracker for details.\ngo1.17.9\n\t\t(released 2022-04-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/elliptic\nand\nencoding/pem\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker and runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.9 milestone\non our issue tracker for details.\ngo1.17.10\n\t\t(released 2022-05-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nsyscall\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, and the\ncrypto/x509\nand\nnet/http/httptest\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.10 milestone\non our issue tracker for details.\ngo1.17.11\n\t\t(released 2022-06-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/rand\n,\ncrypto/tls\n,\nos/exec\n, and\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the\ncrypto/tls\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.11 milestone\non our issue tracker for details.\ngo1.17.12\n\t\t(released 2022-07-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncompress/gzip\n,\nencoding/gob\n,\nencoding/xml\n,\ngo/parser\n,\nio/fs\n,\nnet/http\n, and\npath/filepath\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, the runtime, and the\nruntime/metrics\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.12 milestone\non our issue tracker for details.\ngo1.17.13\n\t\t(released 2022-08-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nencoding/gob\nand\nmath/big\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler and the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.17.13 milestone\non our issue tracker for details.\ngo1.16 (released 2021-02-16)\nGo 1.16 is a major release of Go.\n\tRead the\nGo 1.16 Release Notes\nfor more information.\nMinor revisions\ngo1.16.1\n\t\t(released 2021-03-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/zip\nand\nencoding/xml\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.1 milestone\non our issue tracker for details.\ngo1.16.2\n\t\t(released 2021-03-11)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, linker, the\ngo\ncommand, and the\nsyscall\nand\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.2 milestone\non our issue tracker for details.\ngo1.16.3\n\t\t(released 2021-04-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, and the\ntesting\nand\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.3 milestone\non our issue tracker for details.\ngo1.16.4\n\t\t(released 2021-05-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, and the\narchive/zip\n,\nsyscall\n, and\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.4 milestone\non our issue tracker for details.\ngo1.16.5\n\t\t(released 2021-06-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/zip\n,\nmath/big\n,\nnet\n, and\nnet/http/httputil\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker, the\ngo\ncommand, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.5 milestone\non our issue tracker for details.\ngo1.16.6\n\t\t(released 2021-07-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/tls\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, and the\nnet\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.6 milestone\non our issue tracker for details.\ngo1.16.7\n\t\t(released 2021-08-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http/httputil\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.7 milestone\non our issue tracker for details.\ngo1.16.8\n\t\t(released 2021-09-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\narchive/zip\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the\narchive/zip\n,\ngo/internal/gccgoimporter\n,\nhtml/template\n,\nnet/http\n, and\nruntime/pprof\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.8 milestone\non our issue tracker for details.\ngo1.16.9\n\t\t(released 2021-10-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to linker and the\nmisc/wasm\ndirectory, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to runtime and the\ntext/template\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.9 milestone\non our issue tracker for details.\ngo1.16.10\n\t\t(released 2021-11-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/zip\nand\ndebug/macho\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, linker, runtime, the\nmisc/wasm\ndirectory, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.10 milestone\non our issue tracker for details.\ngo1.16.11\n\t\t(released 2021-12-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, runtime, and the\nnet/http\n,\nnet/http/httptest\n, and\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.11 milestone\non our issue tracker for details.\ngo1.16.12\n\t\t(released 2021-12-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.12 milestone\non our issue tracker for details.\ngo1.16.13\n\t\t(released 2022-01-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.13 milestone\non our issue tracker for details.\ngo1.16.14\n\t\t(released 2022-02-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand, and the\ncrypto/elliptic\nand\nmath/big\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, and the\ndebug/macho\n,\ndebug/pe\n,\nnet/http/httptest\n, and\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.14 milestone\non our issue tracker for details.\ngo1.16.15\n\t\t(released 2022-03-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nregexp/syntax\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, the\ngo\ncommand, and the\nnet\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.16.15 milestone\non our issue tracker for details.\ngo1.15 (released 2020-08-11)\nGo 1.15 is a major release of Go.\n\tRead the\nGo 1.15 Release Notes\nfor more information.\nMinor revisions\ngo1.15.1\n\t\t(released 2020-09-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http/cgi\nand\nnet/http/fcgi\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.1 milestone\non our issue tracker for details.\ngo1.15.2\n\t\t(released 2020-09-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, runtime, documentation, the\ngo\ncommand, and the\nnet/mail\n,\nos\n,\nsync\n, and\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.2 milestone\non our issue tracker for details.\ngo1.15.3\n\t\t(released 2020-10-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, runtime, the\ngo\ncommand, and the\nbytes\n,\nplugin\n, and\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.3 milestone\non our issue tracker for details.\ngo1.15.4\n\t\t(released 2020-11-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, linker, runtime, and the\ncompress/flate\n,\nnet/http\n,\nreflect\n, and\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.4 milestone\non our issue tracker for details.\ngo1.15.5\n\t\t(released 2020-11-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand and the\nmath/big\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.5 milestone\non our issue tracker for details.\ngo1.15.6\n\t\t(released 2020-12-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, and the\nio\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.6 milestone\non our issue tracker for details.\ngo1.15.7\n\t\t(released 2021-01-19)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand and the\ncrypto/elliptic\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.7 milestone\non our issue tracker for details.\ngo1.15.8\n\t\t(released 2021-02-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, the\ngo\ncommand, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.8 milestone\non our issue tracker for details.\ngo1.15.9\n\t\t(released 2021-03-10)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nencoding/xml\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.9 milestone\non our issue tracker for details.\ngo1.15.10\n\t\t(released 2021-03-11)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, the\ngo\ncommand, and the\nnet/http\n,\nos\n,\nsyscall\n, and\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.10 milestone\non our issue tracker for details.\ngo1.15.11\n\t\t(released 2021-04-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, linker, runtime, the\ngo\ncommand, and the\ndatabase/sql\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.11 milestone\non our issue tracker for details.\ngo1.15.12\n\t\t(released 2021-05-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, and the\narchive/zip\n,\nsyscall\n, and\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.12 milestone\non our issue tracker for details.\ngo1.15.13\n\t\t(released 2021-06-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\narchive/zip\n,\nmath/big\n,\nnet\n, and\nnet/http/httputil\npackages, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker, the\ngo\ncommand, and the\nmath/big\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.13 milestone\non our issue tracker for details.\ngo1.15.14\n\t\t(released 2021-07-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/tls\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker and the\nnet\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.14 milestone\non our issue tracker for details.\ngo1.15.15\n\t\t(released 2021-08-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\nnet/http/httputil\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, the\ngo\ncommand, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.15.15 milestone\non our issue tracker for details.\ngo1.14 (released 2020-02-25)\nGo 1.14 is a major release of Go.\n\tRead the\nGo 1.14 Release Notes\nfor more information.\nMinor revisions\ngo1.14.1\n\t\t(released 2020-03-19)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, tools, and the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.1 milestone\non our issue tracker for details.\ngo1.14.2\n\t\t(released 2020-04-08)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the go command, the runtime, and the\nos/exec\nand\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.2 milestone\non our issue tracker for details.\ngo1.14.3\n\t\t(released 2020-05-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, the runtime, and the\ngo/doc\nand\nmath/big\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.3 milestone\non our issue tracker for details.\ngo1.14.4\n\t\t(released 2020-06-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the\ngo\ndoc\ncommand, the runtime, and the\nencoding/json\nand\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.4 milestone\non our issue tracker for details.\ngo1.14.5\n\t\t(released 2020-07-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.5 milestone\non our issue tracker for details.\ngo1.14.6\n\t\t(released 2020-07-16)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the\ngo\ncommand, the compiler, the linker, vet, and the\ndatabase/sql\n,\nencoding/json\n,\nnet/http\n,\nreflect\n, and\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.6 milestone\non our issue tracker for details.\ngo1.14.7\n\t\t(released 2020-08-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nencoding/binary\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.7 milestone\non our issue tracker for details.\ngo1.14.8\n\t\t(released 2020-09-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http/cgi\nand\nnet/http/fcgi\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.8 milestone\non our issue tracker for details.\ngo1.14.9\n\t\t(released 2020-09-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, documentation, and the\nnet/http\nand\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.9 milestone\non our issue tracker for details.\ngo1.14.10\n\t\t(released 2020-10-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, runtime, and the\nplugin\nand\ntesting\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.10 milestone\non our issue tracker for details.\ngo1.14.11\n\t\t(released 2020-11-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime, and the\nnet/http\nand\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.11 milestone\non our issue tracker for details.\ngo1.14.12\n\t\t(released 2020-11-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand and the\nmath/big\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.12 milestone\non our issue tracker for details.\ngo1.14.13\n\t\t(released 2020-12-03)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, runtime, and the\ngo\ncommand.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.13 milestone\non our issue tracker for details.\ngo1.14.14\n\t\t(released 2021-01-19)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ngo\ncommand and the\ncrypto/elliptic\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.14 milestone\non our issue tracker for details.\ngo1.14.15\n\t\t(released 2021-02-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, runtime, the\ngo\ncommand, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.14.15 milestone\non our issue tracker for details.\ngo1.13 (released 2019-09-03)\nGo 1.13 is a major release of Go.\n\tRead the\nGo 1.13 Release Notes\nfor more information.\nMinor revisions\ngo1.13.1\n\t\t(released 2019-09-25)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nnet/textproto\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.1 milestone\non our issue tracker for details.\ngo1.13.2\n\t\t(released 2019-10-17)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the compiler and the\ncrypto/dsa\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.2 milestone\non our issue tracker for details.\ngo1.13.3\n\t\t(released 2019-10-17)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, the toolchain, the runtime, and the\ncrypto/ecdsa\n,\nnet\n,\nnet/http\n, and\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.3 milestone\non our issue tracker for details.\ngo1.13.4\n\t\t(released 2019-10-31)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the\nnet/http\nand\nsyscall\npackages.\n\t\t\tIt also fixes an issue on macOS 10.15 Catalina\nwhere the non-notarized installer and binaries were being\nrejected by Gatekeeper\n.\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.4 milestone\non our issue tracker for details.\ngo1.13.5\n\t\t(released 2019-12-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, the runtime, the linker, and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.5 milestone\non our issue tracker for details.\ngo1.13.6\n\t\t(released 2020-01-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.6 milestone\non our issue tracker for details.\ngo1.13.7\n\t\t(released 2020-01-28)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ttwo\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.7 milestone\non our issue tracker for details.\ngo1.13.8\n\t\t(released 2020-02-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime, and the\ncrypto/x509\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.8 milestone\non our issue tracker for details.\ngo1.13.9\n\t\t(released 2020-03-19)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, tools, the runtime, the toolchain, and the\ncrypto/cypher\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.9 milestone\non our issue tracker for details.\ngo1.13.10\n\t\t(released 2020-04-08)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, the runtime, and the\nos/exec\nand\ntime\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.10 milestone\non our issue tracker for details.\ngo1.13.11\n\t\t(released 2020-05-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.11 milestone\non our issue tracker for details.\ngo1.13.12\n\t\t(released 2020-06-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime, and the\ngo/types\nand\nmath/big\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.12 milestone\non our issue tracker for details.\ngo1.13.13\n\t\t(released 2020-07-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\nand\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.13 milestone\non our issue tracker for details.\ngo1.13.14\n\t\t(released 2020-07-16)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, vet, and the\ndatabase/sql\n,\nnet/http\n, and\nreflect\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.14 milestone\non our issue tracker for details.\ngo1.13.15\n\t\t(released 2020-08-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nencoding/binary\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.13.15 milestone\non our issue tracker for details.\ngo1.12 (released 2019-02-25)\nGo 1.12 is a major release of Go.\n\tRead the\nGo 1.12 Release Notes\nfor more information.\nMinor revisions\ngo1.12.1\n\t\t(released 2019-03-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, the go command, and the\nfmt\n,\nnet/smtp\n,\nos\n,\npath/filepath\n,\nsync\n, and\ntext/template\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.1 milestone\non our issue tracker for details.\ngo1.12.2\n\t\t(released 2019-04-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the runtime, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, the go command, and the\ndoc\n,\nnet\n,\nnet/http/httputil\n, and\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.2 milestone\non our issue tracker for details.\ngo1.12.3\n\t\t(released 2019-04-08)\n\t\t\n\t\t\twas accidentally released without its\nintended fix. It is identical to go1.12.2, except for its version\nnumber. The intended fix is in go1.12.4.\ngo1.12.4\n\t\t(released 2019-04-11)\n\t\t\n\t\t\tfixes an issue where using the prebuilt binary\nreleases on older versions of GNU/Linux\nled to failures\nwhen linking programs that used cgo.\nOnly Linux users who hit this issue need to update.\ngo1.12.5\n\t\t(released 2019-05-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, the linker, the go command, the runtime, and the\nos\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.5 milestone\non our issue tracker for details.\ngo1.12.6\n\t\t(released 2019-06-11)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, the linker, the go command, and the\ncrypto/x509\n,\nnet/http\n, and\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.6 milestone\non our issue tracker for details.\ngo1.12.7\n\t\t(released 2019-07-08)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, and the linker.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.7 milestone\non our issue tracker for details.\ngo1.12.8\n\t\t(released 2019-08-13)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nnet/url\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.8 milestone\non our issue tracker for details.\ngo1.12.9\n\t\t(released 2019-08-15)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the linker, and the\nmath/big\nand\nos\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.9 milestone\non our issue tracker for details.\ngo1.12.10\n\t\t(released 2019-09-25)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nnet/textproto\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.10 milestone\non our issue tracker for details.\ngo1.12.11\n\t\t(released 2019-10-17)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/dsa\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.11 milestone\non our issue tracker for details.\ngo1.12.12\n\t\t(released 2019-10-17)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, runtime, and the\nnet\nand\nsyscall\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.12 milestone\non our issue tracker for details.\ngo1.12.13\n\t\t(released 2019-10-31)\n\t\t\n\t\t\tfixes an issue on macOS 10.15 Catalina\nwhere the non-notarized installer and binaries were being\nrejected by Gatekeeper\n.\nOnly macOS users who hit this issue need to update.\ngo1.12.14\n\t\t(released 2019-12-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\t \n\t\t\t\tfix to the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.14 milestone\non our issue tracker for details.\ngo1.12.15\n\t\t(released 2020-01-09)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime and the\nnet/http\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.15 milestone\non our issue tracker for details.\ngo1.12.16\n\t\t(released 2020-01-28)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ttwo\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\ncrypto/x509\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.16 milestone\non our issue tracker for details.\ngo1.12.17\n\t\t(released 2020-02-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\t \n\t\t\t\tfix to the runtime.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.12.17 milestone\non our issue tracker for details.\ngo1.11 (released 2018-08-24)\nGo 1.11 is a major release of Go.\n\tRead the\nGo 1.11 Release Notes\nfor more information.\nMinor revisions\ngo1.11.1\n\t\t(released 2018-10-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, documentation, go command, runtime, and the\ncrypto/x509\n,\nencoding/json\n,\ngo/types\n,\nnet\n,\nnet/http\n, and\nreflect\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.1 milestone\non our issue tracker for details.\ngo1.11.2\n\t\t(released 2018-11-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, documentation, go command, and the\ndatabase/sql\nand\ngo/types\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.2 milestone\non our issue tracker for details.\ngo1.11.3\n\t\t(released 2018-12-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tthree\n\t\t\t\tsecurity\n\t\t\t\tfixes to \"go get\" and the\ncrypto/x509\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.3 milestone\non our issue tracker for details.\ngo1.11.4\n\t\t(released 2018-12-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, linker, runtime, documentation, go command, and the\ngo/types\nand\nnet/http\npackages.\n\t\t\tIt includes a fix to a bug introduced in Go 1.11.3 that broke\ngo\nget\nfor import path patterns containing \"\n...\n\".\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.4 milestone\non our issue tracker for details.\ngo1.11.5\n\t\t(released 2019-01-23)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/elliptic\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.5 milestone\non our issue tracker for details.\ngo1.11.6\n\t\t(released 2019-03-14)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to cgo, the compiler, linker, runtime, go command, and the\ncrypto/x509\n,\nencoding/json\n,\nnet\n, and\nnet/url\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.6 milestone\non our issue tracker for details.\ngo1.11.7\n\t\t(released 2019-04-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the runtime and the\nnet\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.7 milestone\non our issue tracker for details.\ngo1.11.8\n\t\t(released 2019-04-08)\n\t\t\n\t\t\twas accidentally released without its\nintended fix. It is identical to go1.11.7, except for its version\nnumber. The intended fix is in go1.11.9.\ngo1.11.9\n\t\t(released 2019-04-11)\n\t\t\n\t\t\tfixes an issue where using the prebuilt binary\nreleases on older versions of GNU/Linux\nled to failures\nwhen linking programs that used cgo.\nOnly Linux users who hit this issue need to update.\ngo1.11.10\n\t\t(released 2019-05-06)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the runtime, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the linker.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.10 milestone\non our issue tracker for details.\ngo1.11.11\n\t\t(released 2019-06-11)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\t \n\t\t\t\tfix to the\ncrypto/x509\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.11 milestone\non our issue tracker for details.\ngo1.11.12\n\t\t(released 2019-07-08)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler and the linker.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.12 milestone\non our issue tracker for details.\ngo1.11.13\n\t\t(released 2019-08-13)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/http\nand\nnet/url\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.11.13 milestone\non our issue tracker for details.\ngo1.10 (released 2018-02-16)\nGo 1.10 is a major release of Go.\n\tRead the\nGo 1.10 Release Notes\nfor more information.\nMinor revisions\ngo1.10.1\n\t\t(released 2018-03-28)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the go command, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, and the\narchive/zip\n,\ncrypto/tls\n,\ncrypto/x509\n,\nencoding/json\n,\nnet\n,\nnet/http\n, and\nnet/http/pprof\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.10.1 milestone\non our issue tracker for details.\ngo1.10.2\n\t\t(released 2018-05-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, and go command.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.10.2 milestone\non our issue tracker for details.\ngo1.10.3\n\t\t(released 2018-06-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, and the\ncrypto/tls\n,\ncrypto/x509\n, and\nstrings\npackages.\n\t\t\tIn particular, it adds\nminimal support to the go command for the vgo transition\n.\n\n\t\t\t\n\t\t\tSee the\nGo 1.10.3 milestone\non our issue tracker for details.\ngo1.10.4\n\t\t(released 2018-08-24)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, linker, and the\nbytes\n,\nmime/multipart\n,\nnet/http\n, and\nstrings\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.10.4 milestone\non our issue tracker for details.\ngo1.10.5\n\t\t(released 2018-11-02)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, linker, runtime, and the\ndatabase/sql\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.10.5 milestone\non our issue tracker for details.\ngo1.10.6\n\t\t(released 2018-12-12)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\tthree\n\t\t\t\tsecurity\n\t\t\t\tfixes to \"go get\" and the\ncrypto/x509\npackage.\n\t\t\tIt contains the same fixes as Go 1.11.3 and was released at the same time.\n\n\t\t\t\n\t\t\tSee the\nGo 1.10.6 milestone\non our issue tracker for details.\ngo1.10.7\n\t\t(released 2018-12-14)\n\t\t\n\t\t\tincludes a fix to a bug introduced in Go 1.10.6\nthat broke\ngo\nget\nfor import path patterns containing\n\"\n...\n\".\nSee the\nGo 1.10.7 milestone\non our issue tracker for details.\ngo1.10.8\n\t\t(released 2019-01-23)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to the\ncrypto/elliptic\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.10.8 milestone\non our issue tracker for details.\ngo1.9 (released 2017-08-24)\nGo 1.9 is a major release of Go.\n\tRead the\nGo 1.9 Release Notes\nfor more information.\nMinor revisions\ngo1.9.1\n\t\t(released 2017-10-04)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ttwo\n\t\t\t\tsecurity\n\t\t\t\tfixes.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.9.1 milestone\non our issue tracker for details.\ngo1.9.2\n\t\t(released 2017-10-25)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler, linker, runtime, documentation,\ngo\ncommand, and the\ncrypto/x509\n,\ndatabase/sql\n,\nlog\n, and\nnet/smtp\npackages.\n\t\t\tIt includes a fix to a bug introduced in Go 1.9.1 that broke\ngo\nget\nof non-Git repositories under certain conditions.\n\n\t\t\t\n\t\t\tSee the\nGo 1.9.2 milestone\non our issue tracker for details.\ngo1.9.3\n\t\t(released 2018-01-22)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the\nnet/url\npackage, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, runtime, and the\ndatabase/sql\n,\nmath/big\n, and\nnet/http\npackages.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.9.3 milestone\non our issue tracker for details.\ngo1.9.4\n\t\t(released 2018-02-07)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\ta\n\t\t\t\tsecurity\n\t\t\t\tfix to \"go get\".\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.9.4 milestone\non our issue tracker for details.\ngo1.9.5\n\t\t(released 2018-03-28)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\tsecurity\n\t\t\t\tfixes to the go command, as well as\n\t\t\t\t\n\t\t\t\tbug \n\t\t\t\tfixes to the compiler, go command, and the\nnet/http/pprof\npackage.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.9.5 milestone\non our issue tracker for details.\ngo1.9.6\n\t\t(released 2018-05-01)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the compiler and go command.\n\t\t\t\n\n\t\t\t\n\t\t\tSee the\nGo 1.9.6 milestone\non our issue tracker for details.\ngo1.9.7\n\t\t(released 2018-06-05)\n\t\t\n\t\t\tincludes\n\t\t\t\n\t\t\t\t\n\t\t\t\t \n\t\t\t\tfixes to the go command, and the\ncrypto/x509\nand\nstrings\npackages.\n\t\t\tIn particular, it adds\nminimal support to the go command for the vgo transition\n.\n\n\t\t\t\n\t\t\tSee the\nGo 1.9.7 milestone\non our issue tracker for details.\ngo1.8 (released 2017-02-16)\nGo 1.8 is a major release of Go.\nRead the\nGo 1.8 Release Notes\nfor more information.\nMinor revisions\ngo1.8.1 (released 2017-04-07) includes fixes to the compiler, linker, runtime,\ndocumentation,\ngo\ncommand and the\ncrypto/tls\n,\nencoding/xml\n,\nimage/png\n,\nnet\n,\nnet/http\n,\nreflect\n,\ntext/template\n,\nand\ntime\npackages.\nSee the\nGo\n1.8.1 milestone\non our issue tracker for details.\ngo1.8.2 (released 2017-05-23) includes a security fix to the\ncrypto/elliptic\npackage.\nSee the\nGo\n1.8.2 milestone\non our issue tracker for details.\ngo1.8.3 (released 2017-05-24) includes fixes to the compiler, runtime,\ndocumentation, and the\ndatabase/sql\npackage.\nSee the\nGo\n1.8.3 milestone\non our issue tracker for details.\ngo1.8.4 (released 2017-10-04) includes two security fixes.\nIt contains the same fixes as Go 1.9.1 and was released at the same time.\nSee the\nGo\n1.8.4 milestone\non our issue tracker for details.\ngo1.8.5 (released 2017-10-25) includes fixes to the compiler, linker, runtime,\ndocumentation,\ngo\ncommand,\nand the\ncrypto/x509\nand\nnet/smtp\npackages.\nIt includes a fix to a bug introduced in Go 1.8.4 that broke\ngo\nget\nof non-Git repositories under certain conditions.\nSee the\nGo\n1.8.5 milestone\non our issue tracker for details.\ngo1.8.6 (released 2018-01-22) includes the same fix in\nmath/big\nas Go 1.9.3 and was released at the same time.\nSee the\nGo\n1.8.6 milestone\non our issue tracker for details.\ngo1.8.7 (released 2018-02-07) includes a security fix to \"go get\".\nIt contains the same fix as Go 1.9.4 and was released at the same time.\nSee the\nGo\n1.8.7\nmilestone on our issue tracker for details.\ngo1.7 (released 2016-08-15)\nGo 1.7 is a major release of Go.\nRead the\nGo 1.7 Release Notes\nfor more information.\nMinor revisions\ngo1.7.1 (released 2016-09-07) includes fixes to the compiler, runtime,\ndocumentation, and the\ncompress/flate\n,\nhash/crc32\n,\nio\n,\nnet\n,\nnet/http\n,\npath/filepath\n,\nreflect\n, and\nsyscall\npackages.\nSee the\nGo\n1.7.1 milestone\non our issue tracker for details.\ngo1.7.2 should not be used. It was tagged but not fully released.\nThe release was deferred due to a last minute bug report.\nUse go1.7.3 instead, and refer to the summary of changes below.\ngo1.7.3 (released 2016-10-19) includes fixes to the compiler, runtime,\nand the\ncrypto/cipher\n,\ncrypto/tls\n,\nnet/http\n, and\nstrings\npackages.\nSee the\nGo\n1.7.3 milestone\non our issue tracker for details.\ngo1.7.4 (released 2016-12-01) includes two security fixes.\nSee the\nGo\n1.7.4 milestone\non our issue tracker for details.\ngo1.7.5 (released 2017-01-26) includes fixes to the compiler, runtime,\nand the\ncrypto/x509\nand\ntime\npackages.\nSee the\nGo\n1.7.5 milestone\non our issue tracker for details.\ngo1.7.6 (released 2017-05-23) includes the same security fix as Go 1.8.2 and\nwas released at the same time.\nSee the\nGo\n1.8.2 milestone\non our issue tracker for details.\ngo1.6 (released 2016-02-17)\nGo 1.6 is a major release of Go.\nRead the\nGo 1.6 Release Notes\nfor more information.\nMinor revisions\ngo1.6.1 (released 2016-04-12) includes two security fixes.\nSee the\nGo\n1.6.1 milestone\non our issue tracker for details.\ngo1.6.2 (released 2016-04-20) includes fixes to the compiler, runtime, tools,\ndocumentation, and the\nmime/multipart\n,\nnet/http\n, and\nsort\npackages.\nSee the\nGo\n1.6.2 milestone\non our issue tracker for details.\ngo1.6.3 (released 2016-07-17) includes security fixes to the\nnet/http/cgi\npackage and\nnet/http\npackage when used in\na CGI environment.\nSee the\nGo\n1.6.3 milestone\non our issue tracker for details.\ngo1.6.4 (released 2016-12-01) includes two security fixes.\nIt contains the same fixes as Go 1.7.4 and was released at the same time.\nSee the\nGo\n1.7.4 milestone\non our issue tracker for details.\ngo1.5 (released 2015-08-19)\nGo 1.5 is a major release of Go.\nRead the\nGo 1.5 Release Notes\nfor more information.\nMinor revisions\ngo1.5.1 (released 2015-09-08) includes bug fixes to the compiler, assembler, and\nthe\nfmt\n,\nnet/textproto\n,\nnet/http\n, and\nruntime\npackages.\nSee the\nGo\n1.5.1 milestone\non our issue tracker for details.\ngo1.5.2 (released 2015-12-02) includes bug fixes to the compiler, linker, and\nthe\nmime/multipart\n,\nnet\n, and\nruntime\npackages.\nSee the\nGo\n1.5.2 milestone\non our issue tracker for details.\ngo1.5.3 (released 2016-01-13) includes a security fix to the\nmath/big\npackage\naffecting the\ncrypto/tls\npackage.\nSee the\nrelease announcement\nfor details.\ngo1.5.4 (released 2016-04-12) includes two security fixes.\nIt contains the same fixes as Go 1.6.1 and was released at the same time.\nSee the\nGo\n1.6.1 milestone\non our issue tracker for details.\ngo1.4 (released 2014-12-10)\nGo 1.4 is a major release of Go.\nRead the\nGo 1.4 Release Notes\nfor more information.\nMinor revisions\ngo1.4.1 (released 2015-01-15) includes bug fixes to the linker and the\nlog\n,\nsyscall\n, and\nruntime\npackages.\nSee the\nGo 1.4.1 milestone on our issue tracker\nfor details.\ngo1.4.2 (released 2015-02-17) includes security fixes to the compiler, and bug fixes to the\ngo\ncommand, the compiler and linker, and the\nruntime\n,\nsyscall\n,\nreflect\n, and\nmath/big\npackages.\nSee the\nGo 1.4.2 milestone on our issue tracker\nfor details.\ngo1.4.3 (released 2015-09-22) includes security fixes to the\nnet/http\npackage and bug fixes to the\nruntime\npackage.\nSee the\nGo 1.4.3 milestone on our issue tracker\nfor details.\ngo1.3 (released 2014-06-18)\nGo 1.3 is a major release of Go.\nRead the\nGo 1.3 Release Notes\nfor more information.\nMinor revisions\ngo1.3.1 (released 2014-08-13) includes bug fixes to the compiler and the\nruntime\n,\nnet\n, and\ncrypto/rsa\npackages.\nSee the\nchange history\nfor details.\ngo1.3.2 (released 2014-09-25) includes security fixes to the\ncrypto/tls\npackage and bug fixes to cgo.\nSee the\nchange history\nfor details.\ngo1.3.3 (released 2014-09-30) includes further bug fixes to cgo, the runtime package, and the nacl port.\nSee the\nchange history\nfor details.\ngo1.2 (released 2013-12-01)\nGo 1.2 is a major release of Go.\nRead the\nGo 1.2 Release Notes\nfor more information.\nMinor revisions\ngo1.2.1 (released 2014-03-02) includes bug fixes to the\nruntime\n,\nnet\n, and\ndatabase/sql\npackages.\nSee the\nchange history\nfor details.\ngo1.2.2 (released 2014-05-05) includes a\nsecurity fix\nthat affects the tour binary included in the binary distributions (thanks to Guillaume T).\ngo1.1 (released 2013-05-13)\nGo 1.1 is a major release of Go.\nRead the\nGo 1.1 Release Notes\nfor more information.\nMinor revisions\ngo1.1.1 (released 2013-06-13) includes a security fix to the compiler and several bug fixes to the compiler and runtime.\nSee the\nchange history\nfor details.\ngo1.1.2 (released 2013-08-13) includes fixes to the\ngc\ncompiler\nand\ncgo\n, and the\nbufio\n,\nruntime\n,\nsyscall\n, and\ntime\npackages.\nSee the\nchange history\nfor details.\nIf you use package syscall's\nGetrlimit\nand\nSetrlimit\nfunctions under Linux on the ARM or 386 architectures, please note change\n11803043\nthat fixes\nissue 5949\n.\ngo1 (released 2012-03-28)\nGo 1 is a major release of Go that will be stable in the long term.\nRead the\nGo 1 Release Notes\nfor more information.\nIt is intended that programs written for Go 1 will continue to compile and run\ncorrectly, unchanged, under future versions of Go 1.\nRead the\nGo 1 compatibility document\nfor more\nabout the future of Go 1.\nThe go1 release corresponds to\nweekly.2012-03-27\n.\nMinor revisions\ngo1.0.1 (released 2012-04-25) was issued to\nfix\nan\nescape analysis bug\nthat can lead to memory corruption.\nIt also includes several minor code and documentation fixes.\ngo1.0.2 (released 2012-06-13) was issued to fix two bugs in the implementation\nof maps using struct or array keys:\nissue 3695\nand\nissue 3573\n.\nIt also includes many minor code and documentation fixes.\ngo1.0.3 (released 2012-09-21) includes minor code and documentation fixes.\nSee the\ngo1 release branch history\nfor the complete list of changes.\nOlder releases\nSee the\nPre-Go 1 Release History\npage for notes\non earlier releases.",
      "code_examples": [
        {
          "language": "",
          "code": "git fetch --tags\ngit checkoutgoX.Y.Z",
          "element": "<pre>\ngit fetch --tags\ngit checkout <i>goX.Y.Z</i>\n</pre>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "hash/maphash",
          "element": "<code>hash/maphash</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "go/build/constraint",
          "element": "<code>go/build/constraint</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "runtime/trace",
          "element": "<code>runtime/trace</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "net/http/cookiejar",
          "element": "<code>net/http/cookiejar</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "runtime/trace",
          "element": "<code>runtime/trace</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "go/build/constraint",
          "element": "<code>go/build/constraint</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "encoding/xml",
          "element": "<code>encoding/xml</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "runtime/metrics",
          "element": "<code>runtime/metrics</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "runtime/cgo",
          "element": "<code>runtime/cgo</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "crypto/rand",
          "element": "<code>crypto/rand</code>"
        },
        {
          "language": "",
          "code": "runtime/pprof",
          "element": "<code>runtime/pprof</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "net/http/cookiejar",
          "element": "<code>net/http/cookiejar</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "mime/multipart",
          "element": "<code>mime/multipart</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "crypto/ecdh",
          "element": "<code>crypto/ecdh</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "mime/multipart",
          "element": "<code>mime/multipart</code>"
        },
        {
          "language": "",
          "code": "net/textproto",
          "element": "<code>net/textproto</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "crypto/subtle",
          "element": "<code>crypto/subtle</code>"
        },
        {
          "language": "",
          "code": "crypto/ecdsa",
          "element": "<code>crypto/ecdsa</code>"
        },
        {
          "language": "",
          "code": "text/template",
          "element": "<code>text/template</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "archive/tar",
          "element": "<code>archive/tar</code>"
        },
        {
          "language": "",
          "code": "net/http/httputil",
          "element": "<code>net/http/httputil</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "sync/atomic",
          "element": "<code>sync/atomic</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "sync/atomic",
          "element": "<code>sync/atomic</code>"
        },
        {
          "language": "",
          "code": "mime/multipart",
          "element": "<code>mime/multipart</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "mime/multipart",
          "element": "<code>mime/multipart</code>"
        },
        {
          "language": "",
          "code": "net/textproto",
          "element": "<code>net/textproto</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "encoding/pem",
          "element": "<code>encoding/pem</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "net/http/httptest",
          "element": "<code>net/http/httptest</code>"
        },
        {
          "language": "",
          "code": "sync/atomic",
          "element": "<code>sync/atomic</code>"
        },
        {
          "language": "",
          "code": "crypto/rand",
          "element": "<code>crypto/rand</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "text/template/parse",
          "element": "<code>text/template/parse</code>"
        },
        {
          "language": "",
          "code": "compress/gzip",
          "element": "<code>compress/gzip</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "encoding/xml",
          "element": "<code>encoding/xml</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "runtime/metrics",
          "element": "<code>runtime/metrics</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "encoding/xml",
          "element": "<code>encoding/xml</code>"
        },
        {
          "language": "",
          "code": "archive/tar",
          "element": "<code>archive/tar</code>"
        },
        {
          "language": "",
          "code": "net/http/httputil",
          "element": "<code>net/http/httputil</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "crypto/rand",
          "element": "<code>crypto/rand</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "text/template",
          "element": "<code>text/template</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "debug/macho",
          "element": "<code>debug/macho</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "debug/macho",
          "element": "<code>debug/macho</code>"
        },
        {
          "language": "",
          "code": "net/http/httptest",
          "element": "<code>net/http/httptest</code>"
        },
        {
          "language": "",
          "code": "regexp/syntax",
          "element": "<code>regexp/syntax</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "encoding/pem",
          "element": "<code>encoding/pem</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "net/http/httptest",
          "element": "<code>net/http/httptest</code>"
        },
        {
          "language": "",
          "code": "crypto/rand",
          "element": "<code>crypto/rand</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "compress/gzip",
          "element": "<code>compress/gzip</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "encoding/xml",
          "element": "<code>encoding/xml</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "runtime/metrics",
          "element": "<code>runtime/metrics</code>"
        },
        {
          "language": "",
          "code": "encoding/gob",
          "element": "<code>encoding/gob</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "encoding/xml",
          "element": "<code>encoding/xml</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "net/http/httputil",
          "element": "<code>net/http/httputil</code>"
        },
        {
          "language": "",
          "code": "net/http/httputil",
          "element": "<code>net/http/httputil</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "go/internal/gccgoimporter",
          "element": "<code>go/internal/gccgoimporter</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "runtime/pprof",
          "element": "<code>runtime/pprof</code>"
        },
        {
          "language": "",
          "code": "text/template",
          "element": "<code>text/template</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "debug/macho",
          "element": "<code>debug/macho</code>"
        },
        {
          "language": "",
          "code": "net/http/httptest",
          "element": "<code>net/http/httptest</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "debug/macho",
          "element": "<code>debug/macho</code>"
        },
        {
          "language": "",
          "code": "net/http/httptest",
          "element": "<code>net/http/httptest</code>"
        },
        {
          "language": "",
          "code": "regexp/syntax",
          "element": "<code>regexp/syntax</code>"
        },
        {
          "language": "",
          "code": "net/http/cgi",
          "element": "<code>net/http/cgi</code>"
        },
        {
          "language": "",
          "code": "net/http/fcgi",
          "element": "<code>net/http/fcgi</code>"
        },
        {
          "language": "",
          "code": "compress/flate",
          "element": "<code>compress/flate</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "encoding/xml",
          "element": "<code>encoding/xml</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "net/http/httputil",
          "element": "<code>net/http/httputil</code>"
        },
        {
          "language": "",
          "code": "net/http/httputil",
          "element": "<code>net/http/httputil</code>"
        },
        {
          "language": "",
          "code": "encoding/json",
          "element": "<code>encoding/json</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "encoding/json",
          "element": "<code>encoding/json</code>"
        },
        {
          "language": "",
          "code": "encoding/binary",
          "element": "<code>encoding/binary</code>"
        },
        {
          "language": "",
          "code": "net/http/cgi",
          "element": "<code>net/http/cgi</code>"
        },
        {
          "language": "",
          "code": "net/http/fcgi",
          "element": "<code>net/http/fcgi</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "net/textproto",
          "element": "<code>net/textproto</code>"
        },
        {
          "language": "",
          "code": "crypto/ecdsa",
          "element": "<code>crypto/ecdsa</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/cypher",
          "element": "<code>crypto/cypher</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "encoding/binary",
          "element": "<code>encoding/binary</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "text/template",
          "element": "<code>text/template</code>"
        },
        {
          "language": "",
          "code": "net/http/httputil",
          "element": "<code>net/http/httputil</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "net/textproto",
          "element": "<code>net/textproto</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "encoding/json",
          "element": "<code>encoding/json</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "encoding/json",
          "element": "<code>encoding/json</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "archive/zip",
          "element": "<code>archive/zip</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "encoding/json",
          "element": "<code>encoding/json</code>"
        },
        {
          "language": "",
          "code": "net/http/pprof",
          "element": "<code>net/http/pprof</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "mime/multipart",
          "element": "<code>mime/multipart</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "net/http/pprof",
          "element": "<code>net/http/pprof</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "encoding/xml",
          "element": "<code>encoding/xml</code>"
        },
        {
          "language": "",
          "code": "text/template",
          "element": "<code>text/template</code>"
        },
        {
          "language": "",
          "code": "crypto/elliptic",
          "element": "<code>crypto/elliptic</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "compress/flate",
          "element": "<code>compress/flate</code>"
        },
        {
          "language": "",
          "code": "path/filepath",
          "element": "<code>path/filepath</code>"
        },
        {
          "language": "",
          "code": "crypto/cipher",
          "element": "<code>crypto/cipher</code>"
        },
        {
          "language": "",
          "code": "crypto/x509",
          "element": "<code>crypto/x509</code>"
        },
        {
          "language": "",
          "code": "mime/multipart",
          "element": "<code>mime/multipart</code>"
        },
        {
          "language": "",
          "code": "net/http/cgi",
          "element": "<code>net/http/cgi</code>"
        },
        {
          "language": "",
          "code": "net/textproto",
          "element": "<code>net/textproto</code>"
        },
        {
          "language": "",
          "code": "mime/multipart",
          "element": "<code>mime/multipart</code>"
        },
        {
          "language": "",
          "code": "database/sql",
          "element": "<code>database/sql</code>"
        },
        {
          "language": "",
          "code": "weekly.2012-03-27",
          "element": "<code><a href=\"weekly.html#2012-03-27\">weekly.2012-03-27</a></code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Release History",
          "id": ""
        },
        {
          "level": 2,
          "text": "Release Policy",
          "id": "policy"
        },
        {
          "level": 2,
          "text": "go1.24.0 (released 2025-02-11)",
          "id": "go1.24.0"
        },
        {
          "level": 2,
          "text": "go1.23.0 (released 2024-08-13)",
          "id": "go1.23.0"
        },
        {
          "level": 2,
          "text": "go1.22.0 (released 2024-02-06)",
          "id": "go1.22.0"
        },
        {
          "level": 2,
          "text": "go1.21.0 (released 2023-08-08)",
          "id": "go1.21.0"
        },
        {
          "level": 2,
          "text": "go1.20 (released 2023-02-01)",
          "id": "go1.20"
        },
        {
          "level": 2,
          "text": "go1.19 (released 2022-08-02)",
          "id": "go1.19"
        },
        {
          "level": 2,
          "text": "go1.18 (released 2022-03-15)",
          "id": "go1.18"
        },
        {
          "level": 2,
          "text": "go1.17 (released 2021-08-16)",
          "id": "go1.17"
        },
        {
          "level": 2,
          "text": "go1.16 (released 2021-02-16)",
          "id": "go1.16"
        },
        {
          "level": 2,
          "text": "go1.15 (released 2020-08-11)",
          "id": "go1.15"
        },
        {
          "level": 2,
          "text": "go1.14 (released 2020-02-25)",
          "id": "go1.14"
        },
        {
          "level": 2,
          "text": "go1.13 (released 2019-09-03)",
          "id": "go1.13"
        },
        {
          "level": 2,
          "text": "go1.12 (released 2019-02-25)",
          "id": "go1.12"
        },
        {
          "level": 2,
          "text": "go1.11 (released 2018-08-24)",
          "id": "go1.11"
        },
        {
          "level": 2,
          "text": "go1.10 (released 2018-02-16)",
          "id": "go1.10"
        },
        {
          "level": 2,
          "text": "go1.9 (released 2017-08-24)",
          "id": "go1.9"
        },
        {
          "level": 2,
          "text": "go1.8 (released 2017-02-16)",
          "id": "go1.8"
        },
        {
          "level": 2,
          "text": "go1.7 (released 2016-08-15)",
          "id": "go1.7"
        },
        {
          "level": 2,
          "text": "go1.6 (released 2016-02-17)",
          "id": "go1.6"
        },
        {
          "level": 2,
          "text": "go1.5 (released 2015-08-19)",
          "id": "go1.5"
        },
        {
          "level": 2,
          "text": "go1.4 (released 2014-12-10)",
          "id": "go1.4"
        },
        {
          "level": 2,
          "text": "go1.3 (released 2014-06-18)",
          "id": "go1.3"
        },
        {
          "level": 2,
          "text": "go1.2 (released 2013-12-01)",
          "id": "go1.2"
        },
        {
          "level": 2,
          "text": "go1.1 (released 2013-05-13)",
          "id": "go1.1"
        },
        {
          "level": 2,
          "text": "go1 (released 2012-03-28)",
          "id": "go1"
        },
        {
          "level": 2,
          "text": "Older releases",
          "id": "pre.go1"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.24.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.23.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.22.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.21.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.20.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.19.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.18.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.17.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.16.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.15.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.14.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.13.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.12.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.11.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.10.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.9.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.8.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.7.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.6.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.5.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.4.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.3.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.2.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.1.minor"
        },
        {
          "level": 3,
          "text": "Minor revisions",
          "id": "go1.minor"
        }
      ],
      "timestamp": 1750757561.282413
    },
    {
      "url": "https://golang.org/doc/effective_go",
      "title": "Effective Go - The Go Programming Language",
      "content": "Documentation\nEffective Go\nEffective Go\nIntroduction\nGo is a new language.  Although it borrows ideas from\nexisting languages,\nit has unusual properties that make effective Go programs\ndifferent in character from programs written in its relatives.\nA straightforward translation of a C++ or Java program into Go\nis unlikely to produce a satisfactory resultJava programs\nare written in Java, not Go.\nOn the other hand, thinking about the problem from a Go\nperspective could produce a successful but quite different\nprogram.\nIn other words,\nto write Go well, it's important to understand its properties\nand idioms.\nIt's also important to know the established conventions for\nprogramming in Go, such as naming, formatting, program\nconstruction, and so on, so that programs you write\nwill be easy for other Go programmers to understand.\nThis document gives tips for writing clear, idiomatic Go code.\nIt augments the\nlanguage specification\n,\nthe\nTour of Go\n,\nand\nHow to Write Go Code\n,\nall of which you\nshould read first.\nNote added January, 2022:\nThis document was written for Go's\nrelease in 2009, and has not been updated significantly since.\nAlthough it is a good guide to understand how to use the language\nitself, thanks to the stability of the language, it says little\nabout the libraries and nothing about significant changes to the\nGo ecosystem since it was written, such as the build system, testing,\nmodules, and polymorphism.\nThere are no plans to update it, as so much has happened and a large\nand growing set of documents, blogs, and books do a fine job of\ndescribing modern Go usage.\nEffective Go continues to be useful, but the reader should\nunderstand it is far from a complete guide.\nSee\nissue\n28782\nfor context.\nExamples\nThe\nGo package sources\nare intended to serve not\nonly as the core library but also as examples of how to\nuse the language.\nMoreover, many of the packages contain working, self-contained\nexecutable examples you can run directly from the\ngo.dev\nweb site, such as\nthis one\n(if\nnecessary, click on the word \"Example\" to open it up).\nIf you have a question about how to approach a problem or how something\nmight be implemented, the documentation, code and examples in the\nlibrary can provide answers, ideas and\nbackground.\nFormatting\nFormatting issues are the most contentious\nbut the least consequential.\nPeople can adapt to different formatting styles\nbut it's better if they don't have to, and\nless time is devoted to the topic\nif everyone adheres to the same style.\nThe problem is how to approach this Utopia without a long\nprescriptive style guide.\nWith Go we take an unusual\napproach and let the machine\ntake care of most formatting issues.\nThe\ngofmt\nprogram\n(also available as\ngo fmt\n, which\noperates at the package level rather than source file level)\nreads a Go program\nand emits the source in a standard style of indentation\nand vertical alignment, retaining and if necessary\nreformatting comments.\nIf you want to know how to handle some new layout\nsituation, run\ngofmt\n; if the answer doesn't\nseem right, rearrange your program (or file a bug about\ngofmt\n),\ndon't work around it.\nAs an example, there's no need to spend time lining up\nthe comments on the fields of a structure.\nGofmt\nwill do that for you.  Given the\ndeclaration\ntype T struct {\n    name string // name of the object\n    value int // its value\n}\ngofmt\nwill line up the columns:\ntype T struct {\n    name    string // name of the object\n    value   int    // its value\n}\nAll Go code in the standard packages has been formatted with\ngofmt\n.\nSome formatting details remain.  Very briefly:\nIndentation\nWe use tabs for indentation and\ngofmt\nemits them by default.\n    Use spaces only if you must.\nLine length\nGo has no line length limit.  Don't worry about overflowing a punched card.\n    If a line feels too long, wrap it and indent with an extra tab.\nParentheses\nGo needs fewer parentheses than C and Java: control structures (\nif\n,\nfor\n,\nswitch\n) do not have parentheses in\n    their syntax.\n    Also, the operator precedence hierarchy is shorter and clearer, so\nx<<8 + y<<16\nmeans what the spacing implies, unlike in the other languages.\nCommentary\nGo provides C-style\n/* */\nblock comments\nand C++-style\n//\nline comments.\nLine comments are the norm;\nblock comments appear mostly as package comments, but\nare useful within an expression or to disable large swaths of code.\nComments that appear before top-level declarations, with no intervening newlines,\nare considered to document the declaration itself.\nThese doc comments are the primary documentation for a given Go package or command.\nFor more about doc comments, see \nGo Doc Comments\n.\nNames\nNames are as important in Go as in any other language.\nThey even have semantic effect:\nthe visibility of a name outside a package is determined by whether its\nfirst character is upper case.\nIt's therefore worth spending a little time talking about naming conventions\nin Go programs.\nPackage names\nWhen a package is imported, the package name becomes an accessor for the\ncontents.  After\nimport \"bytes\"\nthe importing package can talk about\nbytes.Buffer\n.  It's\nhelpful if everyone using the package can use the same name to refer to\nits contents, which implies that the package name should be good:\nshort, concise, evocative.  By convention, packages are given\nlower case, single-word names; there should be no need for underscores\nor mixedCaps.\nErr on the side of brevity, since everyone using your\npackage will be typing that name.\nAnd don't worry about collisions\na priori\n.\nThe package name is only the default name for imports; it need not be unique\nacross all source code, and in the rare case of a collision the\nimporting package can choose a different name to use locally.\nIn any case, confusion is rare because the file name in the import\ndetermines just which package is being used.\nAnother convention is that the package name is the base name of\nits source directory;\nthe package in\nsrc/encoding/base64\nis imported as\n\"encoding/base64\"\nbut has name\nbase64\n,\nnot\nencoding_base64\nand not\nencodingBase64\n.\nThe importer of a package will use the name to refer to its contents,\nso exported names in the package can use that fact\nto avoid repetition.\n(Don't use the\nimport .\nnotation, which can simplify\ntests that must run outside the package they are testing, but should otherwise be avoided.)\nFor instance, the buffered reader type in the\nbufio\npackage is called\nReader\n,\nnot\nBufReader\n, because users see it as\nbufio.Reader\n,\nwhich is a clear, concise name.\nMoreover,\nbecause imported entities are always addressed with their package name,\nbufio.Reader\ndoes not conflict with\nio.Reader\n.\nSimilarly, the function to make new instances of\nring.Ring\nwhich\nis the definition of a\nconstructor\nin Gowould\nnormally be called\nNewRing\n, but since\nRing\nis the only type exported by the package, and since the\npackage is called\nring\n, it's called just\nNew\n,\nwhich clients of the package see as\nring.New\n.\nUse the package structure to help you choose good names.\nAnother short example is\nonce.Do\n;\nonce.Do(setup)\nreads well and would not be improved by\nwriting\nonce.DoOrWaitUntilDone(setup)\n.\nLong names don't automatically make things more readable.\nA helpful doc comment can often be more valuable than an extra long name.\nGetters\nGo doesn't provide automatic support for getters and setters.\nThere's nothing wrong with providing getters and setters yourself,\nand it's often appropriate to do so, but it's neither idiomatic nor necessary\nto put\nGet\ninto the getter's name.  If you have a field called\nowner\n(lower case, unexported), the getter method should be\ncalled\nOwner\n(upper case, exported), not\nGetOwner\n.\nThe use of upper-case names for export provides the hook to discriminate\nthe field from the method.\nA setter function, if needed, will likely be called\nSetOwner\n.\nBoth names read well in practice:\nowner := obj.Owner()\nif owner != user {\n    obj.SetOwner(user)\n}\nInterface names\nBy convention, one-method interfaces are named by\nthe method name plus an -er suffix or similar modification\nto construct an agent noun:\nReader\n,\nWriter\n,\nFormatter\n,\nCloseNotifier\netc.\nThere are a number of such names and it's productive to honor them and the function\nnames they capture.\nRead\n,\nWrite\n,\nClose\n,\nFlush\n,\nString\nand so on have\ncanonical signatures and meanings.  To avoid confusion,\ndon't give your method one of those names unless it\nhas the same signature and meaning.\nConversely, if your type implements a method with the\nsame meaning as a method on a well-known type,\ngive it the same name and signature;\ncall your string-converter method\nString\nnot\nToString\n.\nMixedCaps\nFinally, the convention in Go is to use\nMixedCaps\nor\nmixedCaps\nrather than underscores to write\nmultiword names.\nSemicolons\nLike C, Go's formal grammar uses semicolons to terminate statements,\nbut unlike in C, those semicolons do not appear in the source.\nInstead the lexer uses a simple rule to insert semicolons automatically\nas it scans, so the input text is mostly free of them.\nThe rule is this. If the last token before a newline is an identifier\n(which includes words like\nint\nand\nfloat64\n),\na basic literal such as a number or string constant, or one of the\ntokens\nbreak continue fallthrough return ++ -- ) }\nthe lexer always inserts a semicolon after the token.\nThis could be summarized as, if the newline comes\nafter a token that could end a statement, insert a semicolon.\nA semicolon can also be omitted immediately before a closing brace,\nso a statement such as\ngo func() { for { dst <- <-src } }()\nneeds no semicolons.\nIdiomatic Go programs have semicolons only in places such as\nfor\nloop clauses, to separate the initializer, condition, and\ncontinuation elements.  They are also necessary to separate multiple\nstatements on a line, should you write code that way.\nOne consequence of the semicolon insertion rules\nis that you cannot put the opening brace of a\ncontrol structure (\nif\n,\nfor\n,\nswitch\n,\nor\nselect\n) on the next line.  If you do, a semicolon\nwill be inserted before the brace, which could cause unwanted\neffects.  Write them like this\nif i < f() {\n    g()\n}\nnot like this\nif i < f()  // wrong!\n{           // wrong!\n    g()\n}\nControl structures\nThe control structures of Go are related to those of C but differ\nin important ways.\nThere is no\ndo\nor\nwhile\nloop, only a\nslightly generalized\nfor\n;\nswitch\nis more flexible;\nif\nand\nswitch\naccept an optional\ninitialization statement like that of\nfor\n;\nbreak\nand\ncontinue\nstatements\ntake an optional label to identify what to break or continue;\nand there are new control structures including a type switch and a\nmultiway communications multiplexer,\nselect\n.\nThe syntax is also slightly different:\nthere are no parentheses\nand the bodies must always be brace-delimited.\nIf\nIn Go a simple\nif\nlooks like this:\nif x > 0 {\n    return y\n}\nMandatory braces encourage writing simple\nif\nstatements\non multiple lines.  It's good style to do so anyway,\nespecially when the body contains a control statement such as a\nreturn\nor\nbreak\n.\nSince\nif\nand\nswitch\naccept an initialization\nstatement, it's common to see one used to set up a local variable.\nif err := file.Chmod(0664); err != nil {\n    log.Print(err)\n    return err\n}\nIn the Go libraries, you'll find that\nwhen an\nif\nstatement doesn't flow into the next statementthat is,\nthe body ends in\nbreak\n,\ncontinue\n,\ngoto\n, or\nreturn\nthe unnecessary\nelse\nis omitted.\nf, err := os.Open(name)\nif err != nil {\n    return err\n}\ncodeUsing(f)\nThis is an example of a common situation where code must guard against a\nsequence of error conditions.  The code reads well if the\nsuccessful flow of control runs down the page, eliminating error cases\nas they arise.  Since error cases tend to end in\nreturn\nstatements, the resulting code needs no\nelse\nstatements.\nf, err := os.Open(name)\nif err != nil {\n    return err\n}\nd, err := f.Stat()\nif err != nil {\n    f.Close()\n    return err\n}\ncodeUsing(f, d)\nRedeclaration and reassignment\nAn aside: The last example in the previous section demonstrates a detail of how the\n:=\nshort declaration form works.\nThe declaration that calls\nos.Open\nreads,\nf, err := os.Open(name)\nThis statement declares two variables,\nf\nand\nerr\n.\nA few lines later, the call to\nf.Stat\nreads,\nd, err := f.Stat()\nwhich looks as if it declares\nd\nand\nerr\n.\nNotice, though, that\nerr\nappears in both statements.\nThis duplication is legal:\nerr\nis declared by the first statement,\nbut only\nre-assigned\nin the second.\nThis means that the call to\nf.Stat\nuses the existing\nerr\nvariable declared above, and just gives it a new value.\nIn a\n:=\ndeclaration a variable\nv\nmay appear even\nif it has already been declared, provided:\nthis declaration is in the same scope as the existing declaration of\nv\n(if\nv\nis already declared in an outer scope, the declaration will create a new variable ),\nthe corresponding value in the initialization is assignable to\nv\n, and\nthere is at least one other variable that is created by the declaration.\nThis unusual property is pure pragmatism,\nmaking it easy to use a single\nerr\nvalue, for example,\nin a long\nif-else\nchain.\nYou'll see it used often.\n It's worth noting here that in Go the scope of function parameters and return values\nis the same as the function body, even though they appear lexically outside the braces\nthat enclose the body.\nFor\nThe Go\nfor\nloop is similar tobut not the same asC's.\nIt unifies\nfor\nand\nwhile\nand there is no\ndo-while\n.\nThere are three forms, only one of which has semicolons.\n// Like a C for\nfor init; condition; post { }\n\n// Like a C while\nfor condition { }\n\n// Like a C for(;;)\nfor { }\nShort declarations make it easy to declare the index variable right in the loop.\nsum := 0\nfor i := 0; i < 10; i++ {\n    sum += i\n}\nIf you're looping over an array, slice, string, or map,\nor reading from a channel, a\nrange\nclause can\nmanage the loop.\nfor key, value := range oldMap {\n    newMap[key] = value\n}\nIf you only need the first item in the range (the key or index), drop the second:\nfor key := range m {\n    if key.expired() {\n        delete(m, key)\n    }\n}\nIf you only need the second item in the range (the value), use the\nblank identifier\n, an underscore, to discard the first:\nsum := 0\nfor _, value := range array {\n    sum += value\n}\nThe blank identifier has many uses, as described in\na later section\n.\nFor strings, the\nrange\ndoes more work for you, breaking out individual\nUnicode code points by parsing the UTF-8.\nErroneous encodings consume one byte and produce the\nreplacement rune U+FFFD.\n(The name (with associated builtin type)\nrune\nis Go terminology for a\nsingle Unicode code point.\nSee\nthe language specification\nfor details.)\nThe loop\nfor pos, char := range \"\\x80\" { // \\x80 is an illegal UTF-8 encoding\n    fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos)\n}\nprints\ncharacter U+65E5 '' starts at byte position 0\ncharacter U+672C '' starts at byte position 3\ncharacter U+FFFD '' starts at byte position 6\ncharacter U+8A9E '' starts at byte position 7\nFinally, Go has no comma operator and\n++\nand\n--\nare statements not expressions.\nThus if you want to run multiple variables in a\nfor\nyou should use parallel assignment (although that precludes\n++\nand\n--\n).\n// Reverse a\nfor i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {\n    a[i], a[j] = a[j], a[i]\n}\nSwitch\nGo's\nswitch\nis more general than C's.\nThe expressions need not be constants or even integers,\nthe cases are evaluated top to bottom until a match is found,\nand if the\nswitch\nhas no expression it switches on\ntrue\n.\nIt's therefore possibleand idiomaticto write an\nif\n-\nelse\n-\nif\n-\nelse\nchain as a\nswitch\n.\nfunc unhex(c byte) byte {\n    switch {\n    case '0' <= c && c <= '9':\n        return c - '0'\n    case 'a' <= c && c <= 'f':\n        return c - 'a' + 10\n    case 'A' <= c && c <= 'F':\n        return c - 'A' + 10\n    }\n    return 0\n}\nThere is no automatic fall through, but cases can be presented\nin comma-separated lists.\nfunc shouldEscape(c byte) bool {\n    switch c {\n    case ' ', '?', '&', '=', '#', '+', '%':\n        return true\n    }\n    return false\n}\nAlthough they are not nearly as common in Go as some other C-like\nlanguages,\nbreak\nstatements can be used to terminate\na\nswitch\nearly.\nSometimes, though, it's necessary to break out of a surrounding loop,\nnot the switch, and in Go that can be accomplished by putting a label\non the loop and \"breaking\" to that label.\nThis example shows both uses.\nLoop:\n    for n := 0; n < len(src); n += size {\n        switch {\n        case src[n] < sizeOne:\n            if validateOnly {\n                break\n            }\n            size = 1\n            update(src[n])\n\n        case src[n] < sizeTwo:\n            if n+1 >= len(src) {\n                err = errShortInput\n                break Loop\n            }\n            if validateOnly {\n                break\n            }\n            size = 2\n            update(src[n] + src[n+1]<<shift)\n        }\n    }\nOf course, the\ncontinue\nstatement also accepts an optional label\nbut it applies only to loops.\nTo close this section, here's a comparison routine for byte slices that uses two\nswitch\nstatements:\n// Compare returns an integer comparing the two byte slices,\n// lexicographically.\n// The result will be 0 if a == b, -1 if a < b, and +1 if a > b\nfunc Compare(a, b []byte) int {\n    for i := 0; i < len(a) && i < len(b); i++ {\n        switch {\n        case a[i] > b[i]:\n            return 1\n        case a[i] < b[i]:\n            return -1\n        }\n    }\n    switch {\n    case len(a) > len(b):\n        return 1\n    case len(a) < len(b):\n        return -1\n    }\n    return 0\n}\nType switch\nA switch can also be used to discover the dynamic type of an interface\nvariable.  Such a\ntype switch\nuses the syntax of a type\nassertion with the keyword\ntype\ninside the parentheses.\nIf the switch declares a variable in the expression, the variable will\nhave the corresponding type in each clause.\nIt's also idiomatic to reuse the name in such cases, in effect declaring\na new variable with the same name but a different type in each case.\nvar t interface{}\nt = functionOfSomeType()\nswitch t := t.(type) {\ndefault:\n    fmt.Printf(\"unexpected type %T\\n\", t)     // %T prints whatever type t has\ncase bool:\n    fmt.Printf(\"boolean %t\\n\", t)             // t has type bool\ncase int:\n    fmt.Printf(\"integer %d\\n\", t)             // t has type int\ncase *bool:\n    fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool\ncase *int:\n    fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int\n}\nFunctions\nMultiple return values\nOne of Go's unusual features is that functions and methods\ncan return multiple values.  This form can be used to\nimprove on a couple of clumsy idioms in C programs: in-band\nerror returns such as\n-1\nfor\nEOF\nand modifying an argument passed by address.\nIn C, a write error is signaled by a negative count with the\nerror code secreted away in a volatile location.\nIn Go,\nWrite\ncan return a count\nand\nan error: Yes, you wrote some\nbytes but not all of them because you filled the device.\nThe signature of the\nWrite\nmethod on files from\npackage\nos\nis:\nfunc (file *File) Write(b []byte) (n int, err error)\nand as the documentation says, it returns the number of bytes\nwritten and a non-nil\nerror\nwhen\nn\n!=\nlen(b)\n.\nThis is a common style; see the section on error handling for more examples.\nA similar approach obviates the need to pass a pointer to a return\nvalue to simulate a reference parameter.\nHere's a simple-minded function to\ngrab a number from a position in a byte slice, returning the number\nand the next position.\nfunc nextInt(b []byte, i int) (int, int) {\n    for ; i < len(b) && !isDigit(b[i]); i++ {\n    }\n    x := 0\n    for ; i < len(b) && isDigit(b[i]); i++ {\n        x = x*10 + int(b[i]) - '0'\n    }\n    return x, i\n}\nYou could use it to scan the numbers in an input slice\nb\nlike this:\nfor i := 0; i < len(b); {\n        x, i = nextInt(b, i)\n        fmt.Println(x)\n    }\nNamed result parameters\nThe return or result \"parameters\" of a Go function can be given names and\nused as regular variables, just like the incoming parameters.\nWhen named, they are initialized to the zero values for their types when\nthe function begins; if the function executes a\nreturn\nstatement\nwith no arguments, the current values of the result parameters are\nused as the returned values.\nThe names are not mandatory but they can make code shorter and clearer:\nthey're documentation.\nIf we name the results of\nnextInt\nit becomes\nobvious which returned\nint\nis which.\nfunc nextInt(b []byte, pos int) (value, nextPos int) {\nBecause named results are initialized and tied to an unadorned return, they can simplify\nas well as clarify.  Here's a version\nof\nio.ReadFull\nthat uses them well:\nfunc ReadFull(r Reader, buf []byte) (n int, err error) {\n    for len(buf) > 0 && err == nil {\n        var nr int\n        nr, err = r.Read(buf)\n        n += nr\n        buf = buf[nr:]\n    }\n    return\n}\nDefer\nGo's\ndefer\nstatement schedules a function call (the\ndeferred\nfunction) to be run immediately before the function\nexecuting the\ndefer\nreturns.  It's an unusual but\neffective way to deal with situations such as resources that must be\nreleased regardless of which path a function takes to return.  The\ncanonical examples are unlocking a mutex or closing a file.\n// Contents returns the file's contents as a string.\nfunc Contents(filename string) (string, error) {\n    f, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer f.Close()  // f.Close will run when we're finished.\n\n    var result []byte\n    buf := make([]byte, 100)\n    for {\n        n, err := f.Read(buf[0:])\n        result = append(result, buf[0:n]...) // append is discussed later.\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return \"\", err  // f will be closed if we return here.\n        }\n    }\n    return string(result), nil // f will be closed if we return here.\n}\nDeferring a call to a function such as\nClose\nhas two advantages.  First, it\nguarantees that you will never forget to close the file, a mistake\nthat's easy to make if you later edit the function to add a new return\npath.  Second, it means that the close sits near the open,\nwhich is much clearer than placing it at the end of the function.\nThe arguments to the deferred function (which include the receiver if\nthe function is a method) are evaluated when the\ndefer\nexecutes, not when the\ncall\nexecutes.  Besides avoiding worries\nabout variables changing values as the function executes, this means\nthat a single deferred call site can defer multiple function\nexecutions.  Here's a silly example.\nfor i := 0; i < 5; i++ {\n    defer fmt.Printf(\"%d \", i)\n}\nDeferred functions are executed in LIFO order, so this code will cause\n4 3 2 1 0\nto be printed when the function returns.  A\nmore plausible example is a simple way to trace function execution\nthrough the program.  We could write a couple of simple tracing\nroutines like this:\nfunc trace(s string)   { fmt.Println(\"entering:\", s) }\nfunc untrace(s string) { fmt.Println(\"leaving:\", s) }\n\n// Use them like this:\nfunc a() {\n    trace(\"a\")\n    defer untrace(\"a\")\n    // do something....\n}\nWe can do better by exploiting the fact that arguments to deferred\nfunctions are evaluated when the\ndefer\nexecutes.  The\ntracing routine can set up the argument to the untracing routine.\nThis example:\nfunc trace(s string) string {\n    fmt.Println(\"entering:\", s)\n    return s\n}\n\nfunc un(s string) {\n    fmt.Println(\"leaving:\", s)\n}\n\nfunc a() {\n    defer un(trace(\"a\"))\n    fmt.Println(\"in a\")\n}\n\nfunc b() {\n    defer un(trace(\"b\"))\n    fmt.Println(\"in b\")\n    a()\n}\n\nfunc main() {\n    b()\n}\nprints\nentering: b\nin b\nentering: a\nin a\nleaving: a\nleaving: b\nFor programmers accustomed to block-level resource management from\nother languages,\ndefer\nmay seem peculiar, but its most\ninteresting and powerful applications come precisely from the fact\nthat it's not block-based but function-based.  In the section on\npanic\nand\nrecover\nwe'll see another\nexample of its possibilities.\nData\nAllocation with\nnew\nGo has two allocation primitives, the built-in functions\nnew\nand\nmake\n.\nThey do different things and apply to different types, which can be confusing,\nbut the rules are simple.\nLet's talk about\nnew\nfirst.\nIt's a built-in function that allocates memory, but unlike its namesakes\nin some other languages it does not\ninitialize\nthe memory,\nit only\nzeros\nit.\nThat is,\nnew(T)\nallocates zeroed storage for a new item of type\nT\nand returns its address, a value of type\n*T\n.\nIn Go terminology, it returns a pointer to a newly allocated zero value of type\nT\n.\nSince the memory returned by\nnew\nis zeroed, it's helpful to arrange\nwhen designing your data structures that the\nzero value of each type can be used without further initialization.  This means a user of\nthe data structure can create one with\nnew\nand get right to\nwork.\nFor example, the documentation for\nbytes.Buffer\nstates that\n\"the zero value for\nBuffer\nis an empty buffer ready to use.\"\nSimilarly,\nsync.Mutex\ndoes not\nhave an explicit constructor or\nInit\nmethod.\nInstead, the zero value for a\nsync.Mutex\nis defined to be an unlocked mutex.\nThe zero-value-is-useful property works transitively. Consider this type declaration.\ntype SyncedBuffer struct {\n    lock    sync.Mutex\n    buffer  bytes.Buffer\n}\nValues of type\nSyncedBuffer\nare also ready to use immediately upon allocation\nor just declaration.  In the next snippet, both\np\nand\nv\nwill work\ncorrectly without further arrangement.\np := new(SyncedBuffer)  // type *SyncedBuffer\nvar v SyncedBuffer      // type  SyncedBuffer\nConstructors and composite literals\nSometimes the zero value isn't good enough and an initializing\nconstructor is necessary, as in this example derived from\npackage\nos\n.\nfunc NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := new(File)\n    f.fd = fd\n    f.name = name\n    f.dirinfo = nil\n    f.nepipe = 0\n    return f\n}\nThere's a lot of boilerplate in there.  We can simplify it\nusing a\ncomposite literal\n, which is\nan expression that creates a\nnew instance each time it is evaluated.\nfunc NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := File{fd, name, nil, 0}\n    return &f\n}\nNote that, unlike in C, it's perfectly OK to return the address of a local variable;\nthe storage associated with the variable survives after the function\nreturns.\nIn fact, taking the address of a composite literal\nallocates a fresh instance each time it is evaluated,\nso we can combine these last two lines.\nreturn &File{fd, name, nil, 0}\nThe fields of a composite literal are laid out in order and must all be present.\nHowever, by labeling the elements explicitly as\nfield\n:\nvalue\npairs, the initializers can appear in any\norder, with the missing ones left as their respective zero values.  Thus we could say\nreturn &File{fd: fd, name: name}\nAs a limiting case, if a composite literal contains no fields at all, it creates\na zero value for the type.  The expressions\nnew(File)\nand\n&File{}\nare equivalent.\nComposite literals can also be created for arrays, slices, and maps,\nwith the field labels being indices or map keys as appropriate.\nIn these examples, the initializations work regardless of the values of\nEnone\n,\nEio\n, and\nEinval\n, as long as they are distinct.\na := [...]string   {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}\ns := []string      {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}\nm := map[int]string{Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}\nAllocation with\nmake\nBack to allocation.\nThe built-in function\nmake(T,\nargs\n)\nserves\na purpose different from\nnew(T)\n.\nIt creates slices, maps, and channels only, and it returns an\ninitialized\n(not\nzeroed\n)\nvalue of type\nT\n(not\n*T\n).\nThe reason for the distinction\nis that these three types represent, under the covers, references to data structures that\nmust be initialized before use.\nA slice, for example, is a three-item descriptor\ncontaining a pointer to the data (inside an array), the length, and the\ncapacity, and until those items are initialized, the slice is\nnil\n.\nFor slices, maps, and channels,\nmake\ninitializes the internal data structure and prepares\nthe value for use.\nFor instance,\nmake([]int, 10, 100)\nallocates an array of 100 ints and then creates a slice\nstructure with length 10 and a capacity of 100 pointing at the first\n10 elements of the array.\n(When making a slice, the capacity can be omitted; see the section on slices\nfor more information.)\nIn contrast,\nnew([]int)\nreturns a pointer to a newly allocated, zeroed slice\nstructure, that is, a pointer to a\nnil\nslice value.\nThese examples illustrate the difference between\nnew\nand\nmake\n.\nvar p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful\nvar v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints\n\n// Unnecessarily complex:\nvar p *[]int = new([]int)\n*p = make([]int, 100, 100)\n\n// Idiomatic:\nv := make([]int, 100)\nRemember that\nmake\napplies only to maps, slices and channels\nand does not return a pointer.\nTo obtain an explicit pointer allocate with\nnew\nor take the address\nof a variable explicitly.\nArrays\nArrays are useful when planning the detailed layout of memory and sometimes\ncan help avoid allocation, but primarily\nthey are a building block for slices, the subject of the next section.\nTo lay the foundation for that topic, here are a few words about arrays.\nThere are major differences between the ways arrays work in Go and C.\nIn Go,\nArrays are values. Assigning one array to another copies all the elements.\nIn particular, if you pass an array to a function, it\nwill receive a\ncopy\nof the array, not a pointer to it.\nThe size of an array is part of its type.  The types\n[10]int\nand\n[20]int\nare distinct.\nThe value property can be useful but also expensive; if you want C-like behavior and efficiency,\nyou can pass a pointer to the array.\nfunc Sum(a *[3]float64) (sum float64) {\n    for _, v := range *a {\n        sum += v\n    }\n    return\n}\n\narray := [...]float64{7.0, 8.5, 9.1}\nx := Sum(&array)  // Note the explicit address-of operator\nBut even this style isn't idiomatic Go.\nUse slices instead.\nSlices\nSlices wrap arrays to give a more general, powerful, and convenient\ninterface to sequences of data.  Except for items with explicit\ndimension such as transformation matrices, most array programming in\nGo is done with slices rather than simple arrays.\nSlices hold references to an underlying array, and if you assign one\nslice to another, both refer to the same array.\nIf a function takes a slice argument, changes it makes to\nthe elements of the slice will be visible to the caller, analogous to\npassing a pointer to the underlying array.  A\nRead\nfunction can therefore accept a slice argument rather than a pointer\nand a count; the length within the slice sets an upper\nlimit of how much data to read.  Here is the signature of the\nRead\nmethod of the\nFile\ntype in package\nos\n:\nfunc (f *File) Read(buf []byte) (n int, err error)\nThe method returns the number of bytes read and an error value, if\nany.\nTo read into the first 32 bytes of a larger buffer\nbuf\n,\nslice\n(here used as a verb) the buffer.\nn, err := f.Read(buf[0:32])\nSuch slicing is common and efficient.  In fact, leaving efficiency aside for\nthe moment, the following snippet would also read the first 32 bytes of the buffer.\nvar n int\n    var err error\n    for i := 0; i < 32; i++ {\n        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.\n        n += nbytes\n        if nbytes == 0 || e != nil {\n            err = e\n            break\n        }\n    }\nThe length of a slice may be changed as long as it still fits within\nthe limits of the underlying array; just assign it to a slice of\nitself.  The\ncapacity\nof a slice, accessible by the built-in\nfunction\ncap\n, reports the maximum length the slice may\nassume.  Here is a function to append data to a slice.  If the data\nexceeds the capacity, the slice is reallocated.  The\nresulting slice is returned.  The function uses the fact that\nlen\nand\ncap\nare legal when applied to the\nnil\nslice, and return 0.\nfunc Append(slice, data []byte) []byte {\n    l := len(slice)\n    if l + len(data) > cap(slice) {  // reallocate\n        // Allocate double what's needed, for future growth.\n        newSlice := make([]byte, (l+len(data))*2)\n        // The copy function is predeclared and works for any slice type.\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[0:l+len(data)]\n    copy(slice[l:], data)\n    return slice\n}\nWe must return the slice afterwards because, although\nAppend\ncan modify the elements of\nslice\n, the slice itself (the run-time data\nstructure holding the pointer, length, and capacity) is passed by value.\nThe idea of appending to a slice is so useful it's captured by the\nappend\nbuilt-in function.  To understand that function's\ndesign, though, we need a little more information, so we'll return\nto it later.\nTwo-dimensional slices\nGo's arrays and slices are one-dimensional.\nTo create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays\nor slice-of-slices, like this:\ntype Transform [3][3]float64  // A 3x3 array, really an array of arrays.\ntype LinesOfText [][]byte     // A slice of byte slices.\nBecause slices are variable-length, it is possible to have each inner\nslice be a different length.\nThat can be a common situation, as in our\nLinesOfText\nexample: each line has an independent length.\ntext := LinesOfText{\n    []byte(\"Now is the time\"),\n    []byte(\"for all good gophers\"),\n    []byte(\"to bring some fun to the party.\"),\n}\nSometimes it's necessary to allocate a 2D slice, a situation that can arise when\nprocessing scan lines of pixels, for instance.\nThere are two ways to achieve this.\nOne is to allocate each slice independently; the other\nis to allocate a single array and point the individual slices into it.\nWhich to use depends on your application.\nIf the slices might grow or shrink, they should be allocated independently\nto avoid overwriting the next line; if not, it can be more efficient to construct\nthe object with a single allocation.\nFor reference, here are sketches of the two methods.\nFirst, a line at a time:\n// Allocate the top-level slice.\npicture := make([][]uint8, YSize) // One row per unit of y.\n// Loop over the rows, allocating the slice for each row.\nfor i := range picture {\n    picture[i] = make([]uint8, XSize)\n}\nAnd now as one allocation, sliced into lines:\n// Allocate the top-level slice, the same as before.\npicture := make([][]uint8, YSize) // One row per unit of y.\n// Allocate one large slice to hold all the pixels.\npixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.\n// Loop over the rows, slicing each row from the front of the remaining pixels slice.\nfor i := range picture {\n    picture[i], pixels = pixels[:XSize], pixels[XSize:]\n}\nMaps\nMaps are a convenient and powerful built-in data structure that associate\nvalues of one type (the\nkey\n) with values of another type\n(the\nelement\nor\nvalue\n).\nThe key can be of any type for which the equality operator is defined,\nsuch as integers,\nfloating point and complex numbers,\nstrings, pointers, interfaces (as long as the dynamic type\nsupports equality), structs and arrays.\nSlices cannot be used as map keys,\nbecause equality is not defined on them.\nLike slices, maps hold references to an underlying data structure.\nIf you pass a map to a function\nthat changes the contents of the map, the changes will be visible\nin the caller.\nMaps can be constructed using the usual composite literal syntax\nwith colon-separated key-value pairs,\nso it's easy to build them during initialization.\nvar timeZone = map[string]int{\n    \"UTC\":  0*60*60,\n    \"EST\": -5*60*60,\n    \"CST\": -6*60*60,\n    \"MST\": -7*60*60,\n    \"PST\": -8*60*60,\n}\nAssigning and fetching map values looks syntactically just like\ndoing the same for arrays and slices except that the index doesn't\nneed to be an integer.\noffset := timeZone[\"EST\"]\nAn attempt to fetch a map value with a key that\nis not present in the map will return the zero value for the type\nof the entries\nin the map.  For instance, if the map contains integers, looking\nup a non-existent key will return\n0\n.\nA set can be implemented as a map with value type\nbool\n.\nSet the map entry to\ntrue\nto put the value in the set, and then\ntest it by simple indexing.\nattended := map[string]bool{\n    \"Ann\": true,\n    \"Joe\": true,\n    ...\n}\n\nif attended[person] { // will be false if person is not in the map\n    fmt.Println(person, \"was at the meeting\")\n}\nSometimes you need to distinguish a missing entry from\na zero value.  Is there an entry for\n\"UTC\"\nor is that 0 because it's not in the map at all?\nYou can discriminate with a form of multiple assignment.\nvar seconds int\nvar ok bool\nseconds, ok = timeZone[tz]\nFor obvious reasons this is called the comma ok idiom.\nIn this example, if\ntz\nis present,\nseconds\nwill be set appropriately and\nok\nwill be true; if not,\nseconds\nwill be set to zero and\nok\nwill\nbe false.\nHere's a function that puts it together with a nice error report:\nfunc offset(tz string) int {\n    if seconds, ok := timeZone[tz]; ok {\n        return seconds\n    }\n    log.Println(\"unknown time zone:\", tz)\n    return 0\n}\nTo test for presence in the map without worrying about the actual value,\nyou can use the\nblank identifier\n(\n_\n)\nin place of the usual variable for the value.\n_, present := timeZone[tz]\nTo delete a map entry, use the\ndelete\nbuilt-in function, whose arguments are the map and the key to be deleted.\nIt's safe to do this even if the key is already absent\nfrom the map.\ndelete(timeZone, \"PDT\")  // Now on Standard Time\nPrinting\nFormatted printing in Go uses a style similar to C's\nprintf\nfamily but is richer and more general. The functions live in the\nfmt\npackage and have capitalized names:\nfmt.Printf\n,\nfmt.Fprintf\n,\nfmt.Sprintf\nand so on.  The string functions (\nSprintf\netc.)\nreturn a string rather than filling in a provided buffer.\nYou don't need to provide a format string.  For each of\nPrintf\n,\nFprintf\nand\nSprintf\nthere is another pair\nof functions, for instance\nPrint\nand\nPrintln\n.\nThese functions do not take a format string but instead generate a default\nformat for each argument. The\nPrintln\nversions also insert a blank\nbetween arguments and append a newline to the output while\nthe\nPrint\nversions add blanks only if the operand on neither side is a string.\nIn this example each line produces the same output.\nfmt.Printf(\"Hello %d\\n\", 23)\nfmt.Fprint(os.Stdout, \"Hello \", 23, \"\\n\")\nfmt.Println(\"Hello\", 23)\nfmt.Println(fmt.Sprint(\"Hello \", 23))\nThe formatted print functions\nfmt.Fprint\nand friends take as a first argument any object\nthat implements the\nio.Writer\ninterface; the variables\nos.Stdout\nand\nos.Stderr\nare familiar instances.\nHere things start to diverge from C.  First, the numeric formats such as\n%d\ndo not take flags for signedness or size; instead, the printing routines use the\ntype of the argument to decide these properties.\nvar x uint64 = 1<<64 - 1\nfmt.Printf(\"%d %x; %d %x\\n\", x, x, int64(x), int64(x))\nprints\n18446744073709551615 ffffffffffffffff; -1 -1\nIf you just want the default conversion, such as decimal for integers, you can use\nthe catchall format\n%v\n(for value); the result is exactly\nwhat\nPrint\nand\nPrintln\nwould produce.\nMoreover, that format can print\nany\nvalue, even arrays, slices, structs, and\nmaps.  Here is a print statement for the time zone map defined in the previous section.\nfmt.Printf(\"%v\\n\", timeZone)  // or just fmt.Println(timeZone)\nwhich gives output:\nmap[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]\nFor maps,\nPrintf\nand friends sort the output lexicographically by key.\nWhen printing a struct, the modified format\n%+v\nannotates the\nfields of the structure with their names, and for any value the alternate\nformat\n%#v\nprints the value in full Go syntax.\ntype T struct {\n    a int\n    b float64\n    c string\n}\nt := &T{ 7, -2.35, \"abc\\tdef\" }\nfmt.Printf(\"%v\\n\", t)\nfmt.Printf(\"%+v\\n\", t)\nfmt.Printf(\"%#v\\n\", t)\nfmt.Printf(\"%#v\\n\", timeZone)\nprints\n&{7 -2.35 abc   def}\n&{a:7 b:-2.35 c:abc     def}\n&main.T{a:7, b:-2.35, c:\"abc\\tdef\"}\nmap[string]int{\"CST\":-21600, \"EST\":-18000, \"MST\":-25200, \"PST\":-28800, \"UTC\":0}\n(Note the ampersands.)\nThat quoted string format is also available through\n%q\nwhen\napplied to a value of type\nstring\nor\n[]byte\n.\nThe alternate format\n%#q\nwill use backquotes instead if possible.\n(The\n%q\nformat also applies to integers and runes, producing a\nsingle-quoted rune constant.)\nAlso,\n%x\nworks on strings, byte arrays and byte slices as well as\non integers, generating a long hexadecimal string, and with\na space in the format (\n%x\n) it puts spaces between the bytes.\nAnother handy format is\n%T\n, which prints the\ntype\nof a value.\nfmt.Printf(\"%T\\n\", timeZone)\nprints\nmap[string]int\nIf you want to control the default format for a custom type, all that's required is to define\na method with the signature\nString() string\non the type.\nFor our simple type\nT\n, that might look like this.\nfunc (t *T) String() string {\n    return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c)\n}\nfmt.Printf(\"%v\\n\", t)\nto print in the format\n7/-2.35/\"abc\\tdef\"\n(If you need to print\nvalues\nof type\nT\nas well as pointers to\nT\n,\nthe receiver for\nString\nmust be of value type; this example used a pointer because\nthat's more efficient and idiomatic for struct types.\nSee the section below on\npointers vs. value receivers\nfor more information.)\nOur\nString\nmethod is able to call\nSprintf\nbecause the\nprint routines are fully reentrant and can be wrapped this way.\nThere is one important detail to understand about this approach,\nhowever: don't construct a\nString\nmethod by calling\nSprintf\nin a way that will recur into your\nString\nmethod indefinitely.  This can happen if the\nSprintf\ncall attempts to print the receiver directly as a string, which in\nturn will invoke the method again.  It's a common and easy mistake\nto make, as this example shows.\ntype MyString string\n\nfunc (m MyString) String() string {\n    return fmt.Sprintf(\"MyString=%s\", m) // Error: will recur forever.\n}\nIt's also easy to fix: convert the argument to the basic string type, which does not have the\nmethod.\ntype MyString string\nfunc (m MyString) String() string {\n    return fmt.Sprintf(\"MyString=%s\", string(m)) // OK: note conversion.\n}\nIn the\ninitialization section\nwe'll see another technique that avoids this recursion.\nAnother printing technique is to pass a print routine's arguments directly to another such routine.\nThe signature of\nPrintf\nuses the type\n...interface{}\nfor its final argument to specify that an arbitrary number of parameters (of arbitrary type)\ncan appear after the format.\nfunc Printf(format string, v ...interface{}) (n int, err error) {\nWithin the function\nPrintf\n,\nv\nacts like a variable of type\n[]interface{}\nbut if it is passed to another variadic function, it acts like\na regular list of arguments.\nHere is the implementation of the\nfunction\nlog.Println\nwe used above. It passes its arguments directly to\nfmt.Sprintln\nfor the actual formatting.\n// Println prints to the standard logger in the manner of fmt.Println.\nfunc Println(v ...interface{}) {\n    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)\n}\nWe write\n...\nafter\nv\nin the nested call to\nSprintln\nto tell the\ncompiler to treat\nv\nas a list of arguments; otherwise it would just pass\nv\nas a single slice argument.\nThere's even more to printing than we've covered here.  See the\ngodoc\ndocumentation\nfor package\nfmt\nfor the details.\nBy the way, a\n...\nparameter can be of a specific type, for instance\n...int\nfor a min function that chooses the least of a list of integers:\nfunc Min(a ...int) int {\n    min := int(^uint(0) >> 1)  // largest int\n    for _, i := range a {\n        if i < min {\n            min = i\n        }\n    }\n    return min\n}\nAppend\nNow we have the missing piece we needed to explain the design of\nthe\nappend\nbuilt-in function.  The signature of\nappend\nis different from our custom\nAppend\nfunction above.\nSchematically, it's like this:\nfunc append(slice []\nT\n, elements ...\nT\n) []\nT\nwhere\nT\nis a placeholder for any given type.  You can't\nactually write a function in Go where the type\nT\nis determined by the caller.\nThat's why\nappend\nis built in: it needs support from the\ncompiler.\nWhat\nappend\ndoes is append the elements to the end of\nthe slice and return the result.  The result needs to be returned\nbecause, as with our hand-written\nAppend\n, the underlying\narray may change.  This simple example\nx := []int{1,2,3}\nx = append(x, 4, 5, 6)\nfmt.Println(x)\nprints\n[1 2 3 4 5 6]\n.  So\nappend\nworks a\nlittle like\nPrintf\n, collecting an arbitrary number of\narguments.\nBut what if we wanted to do what our\nAppend\ndoes and\nappend a slice to a slice?  Easy: use\n...\nat the call\nsite, just as we did in the call to\nOutput\nabove.  This\nsnippet produces identical output to the one above.\nx := []int{1,2,3}\ny := []int{4,5,6}\nx = append(x, y...)\nfmt.Println(x)\nWithout that\n...\n, it wouldn't compile because the types\nwould be wrong;\ny\nis not of type\nint\n.\nInitialization\nAlthough it doesn't look superficially very different from\ninitialization in C or C++, initialization in Go is more powerful.\nComplex structures can be built during initialization and the ordering\nissues among initialized objects, even among different packages, are handled\ncorrectly.\nConstants\nConstants in Go are just thatconstant.\nThey are created at compile time, even when defined as\nlocals in functions,\nand can only be numbers, characters (runes), strings or booleans.\nBecause of the compile-time restriction, the expressions\nthat define them must be constant expressions,\nevaluatable by the compiler.  For instance,\n1<<3\nis a constant expression, while\nmath.Sin(math.Pi/4)\nis not because\nthe function call to\nmath.Sin\nneeds\nto happen at run time.\nIn Go, enumerated constants are created using the\niota\nenumerator.  Since\niota\ncan be part of an expression and\nexpressions can be implicitly repeated, it is easy to build intricate\nsets of values.\ntype ByteSize float64\n\nconst (\n    _           = iota\n// ignore first value by assigning to blank identifier\nKB ByteSize = 1 << (10 * iota)\n    MB\n    GB\n    TB\n    PB\n    EB\n    ZB\n    YB\n)\nThe ability to attach a method such as\nString\nto any\nuser-defined type makes it possible for arbitrary values to format themselves\nautomatically for printing.\nAlthough you'll see it most often applied to structs, this technique is also useful for\nscalar types such as floating-point types like\nByteSize\n.\nfunc (b ByteSize) String() string {\n    switch {\n    case b >= YB:\n        return fmt.Sprintf(\"%.2fYB\", b/YB)\n    case b >= ZB:\n        return fmt.Sprintf(\"%.2fZB\", b/ZB)\n    case b >= EB:\n        return fmt.Sprintf(\"%.2fEB\", b/EB)\n    case b >= PB:\n        return fmt.Sprintf(\"%.2fPB\", b/PB)\n    case b >= TB:\n        return fmt.Sprintf(\"%.2fTB\", b/TB)\n    case b >= GB:\n        return fmt.Sprintf(\"%.2fGB\", b/GB)\n    case b >= MB:\n        return fmt.Sprintf(\"%.2fMB\", b/MB)\n    case b >= KB:\n        return fmt.Sprintf(\"%.2fKB\", b/KB)\n    }\n    return fmt.Sprintf(\"%.2fB\", b)\n}\nThe expression\nYB\nprints as\n1.00YB\n,\nwhile\nByteSize(1e13)\nprints as\n9.09TB\n.\nThe use here of\nSprintf\nto implement\nByteSize\n's\nString\nmethod is safe\n(avoids recurring indefinitely) not because of a conversion but\nbecause it calls\nSprintf\nwith\n%f\n,\nwhich is not a string format:\nSprintf\nwill only call\nthe\nString\nmethod when it wants a string, and\n%f\nwants a floating-point value.\nVariables\nVariables can be initialized just like constants but the\ninitializer can be a general expression computed at run time.\nvar (\n    home   = os.Getenv(\"HOME\")\n    user   = os.Getenv(\"USER\")\n    gopath = os.Getenv(\"GOPATH\")\n)\nThe init function\nFinally, each source file can define its own niladic\ninit\nfunction to\nset up whatever state is required.  (Actually each file can have multiple\ninit\nfunctions.)\nAnd finally means finally:\ninit\nis called after all the\nvariable declarations in the package have evaluated their initializers,\nand those are evaluated only after all the imported packages have been\ninitialized.\nBesides initializations that cannot be expressed as declarations,\na common use of\ninit\nfunctions is to verify or repair\ncorrectness of the program state before real execution begins.\nfunc init() {\n    if user == \"\" {\n        log.Fatal(\"$USER not set\")\n    }\n    if home == \"\" {\n        home = \"/home/\" + user\n    }\n    if gopath == \"\" {\n        gopath = home + \"/go\"\n    }\n    // gopath may be overridden by --gopath flag on command line.\n    flag.StringVar(&gopath, \"gopath\", gopath, \"override default GOPATH\")\n}\nMethods\nPointers vs. Values\nAs we saw with\nByteSize\n,\nmethods can be defined for any named type (except a pointer or an interface);\nthe receiver does not have to be a struct.\nIn the discussion of slices above, we wrote an\nAppend\nfunction.  We can define it as a method on slices instead.  To do\nthis, we first declare a named type to which we can bind the method, and\nthen make the receiver for the method a value of that type.\ntype ByteSlice []byte\n\nfunc (slice ByteSlice) Append(data []byte) []byte {\n    // Body exactly the same as the Append function defined above.\n}\nThis still requires the method to return the updated slice.  We can\neliminate that clumsiness by redefining the method to take a\npointer\nto a\nByteSlice\nas its receiver, so the\nmethod can overwrite the caller's slice.\nfunc (p *ByteSlice) Append(data []byte) {\n    slice := *p\n    // Body as above, without the return.\n    *p = slice\n}\nIn fact, we can do even better.  If we modify our function so it looks\nlike a standard\nWrite\nmethod, like this,\nfunc (p *ByteSlice) Write(data []byte) (n int, err error) {\n    slice := *p\n    // Again as above.\n    *p = slice\n    return len(data), nil\n}\nthen the type\n*ByteSlice\nsatisfies the standard interface\nio.Writer\n, which is handy.  For instance, we can\nprint into one.\nvar b ByteSlice\n    fmt.Fprintf(&b, \"This hour has %d days\\n\", 7)\nWe pass the address of a\nByteSlice\nbecause only\n*ByteSlice\nsatisfies\nio.Writer\n.\nThe rule about pointers vs. values for receivers is that value methods\ncan be invoked on pointers and values, but pointer methods can only be\ninvoked on pointers.\nThis rule arises because pointer methods can modify the receiver; invoking\nthem on a value would cause the method to receive a copy of the value, so\nany modifications would be discarded.\nThe language therefore disallows this mistake.\nThere is a handy exception, though. When the value is addressable, the\nlanguage takes care of the common case of invoking a pointer method on a\nvalue by inserting the address operator automatically.\nIn our example, the variable\nb\nis addressable, so we can call\nits\nWrite\nmethod with just\nb.Write\n. The compiler\nwill rewrite that to\n(&b).Write\nfor us.\nBy the way, the idea of using\nWrite\non a slice of bytes\nis central to the implementation of\nbytes.Buffer\n.\nInterfaces and other types\nInterfaces\nInterfaces in Go provide a way to specify the behavior of an\nobject: if something can do\nthis\n, then it can be used\nhere\n.  We've seen a couple of simple examples already;\ncustom printers can be implemented by a\nString\nmethod\nwhile\nFprintf\ncan generate output to anything\nwith a\nWrite\nmethod.\nInterfaces with only one or two methods are common in Go code, and are\nusually given a name derived from the method, such as\nio.Writer\nfor something that implements\nWrite\n.\nA type can implement multiple interfaces.\nFor instance, a collection can be sorted\nby the routines in package\nsort\nif it implements\nsort.Interface\n, which contains\nLen()\n,\nLess(i, j int) bool\n, and\nSwap(i, j int)\n,\nand it could also have a custom formatter.\nIn this contrived example\nSequence\nsatisfies both.\ntype Sequence []int\n// Methods required by sort.Interface.\nfunc (s Sequence) Len() int {\n    return len(s)\n}\nfunc (s Sequence) Less(i, j int) bool {\n    return s[i] < s[j]\n}\nfunc (s Sequence) Swap(i, j int) {\n    s[i], s[j] = s[j], s[i]\n}\n// Copy returns a copy of the Sequence.\nfunc (s Sequence) Copy() Sequence {\n    copy := make(Sequence, 0, len(s))\n    return append(copy, s...)\n}\n// Method for printing - sorts the elements before printing.\nfunc (s Sequence) String() string {\n    s = s.Copy()\n// Make a copy; don't overwrite argument.\nsort.Sort(s)\n    str := \"[\"\n    for i, elem := range s {\n// Loop is O(N); will fix that in next example.\nif i > 0 {\n            str += \" \"\n        }\n        str += fmt.Sprint(elem)\n    }\n    return str + \"]\"\n}\nConversions\nThe\nString\nmethod of\nSequence\nis recreating the\nwork that\nSprint\nalready does for slices.\n(It also has complexity O(N), which is poor.) We can share the\neffort (and also speed it up) if we convert the\nSequence\nto a plain\n[]int\nbefore calling\nSprint\n.\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.Sort(s)\n    return fmt.Sprint([]int(s))\n}\nThis method is another example of the conversion technique for calling\nSprintf\nsafely from a\nString\nmethod.\nBecause the two types (\nSequence\nand\n[]int\n)\nare the same if we ignore the type name, it's legal to convert between them.\nThe conversion doesn't create a new value, it just temporarily acts\nas though the existing value has a new type.\n(There are other legal conversions, such as from integer to floating point, that\ndo create a new value.)\nIt's an idiom in Go programs to convert the\ntype of an expression to access a different\nset of methods. As an example, we could use the existing\ntype\nsort.IntSlice\nto reduce the entire example\nto this:\ntype Sequence []int\n\n// Method for printing - sorts the elements before printing\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.IntSlice(s).Sort()\n    return fmt.Sprint([]int(s))\n}\nNow, instead of having\nSequence\nimplement multiple\ninterfaces (sorting and printing), we're using the ability of a data item to be\nconverted to multiple types (\nSequence\n,\nsort.IntSlice\nand\n[]int\n), each of which does some part of the job.\nThat's more unusual in practice but can be effective.\nInterface conversions and type assertions\nType switches\nare a form of conversion: they take an interface and, for\neach case in the switch, in a sense convert it to the type of that case.\nHere's a simplified version of how the code under\nfmt.Printf\nturns a value into\na string using a type switch.\nIf it's already a string, we want the actual string value held by the interface, while if it has a\nString\nmethod we want the result of calling the method.\ntype Stringer interface {\n    String() string\n}\n\nvar value interface{} // Value provided by caller.\nswitch str := value.(type) {\ncase string:\n    return str\ncase Stringer:\n    return str.String()\n}\nThe first case finds a concrete value; the second converts the interface into another interface.\nIt's perfectly fine to mix types this way.\nWhat if there's only one type we care about? If we know the value holds a\nstring\nand we just want to extract it?\nA one-case type switch would do, but so would a\ntype assertion\n.\nA type assertion takes an interface value and extracts from it a value of the specified explicit type.\nThe syntax borrows from the clause opening a type switch, but with an explicit\ntype rather than the\ntype\nkeyword:\nvalue.(typeName)\nand the result is a new value with the static type\ntypeName\n.\nThat type must either be the concrete type held by the interface, or a second interface\ntype that the value can be converted to.\nTo extract the string we know is in the value, we could write:\nstr := value.(string)\nBut if it turns out that the value does not contain a string, the program will crash with a run-time error.\nTo guard against that, use the \"comma, ok\" idiom to test, safely, whether the value is a string:\nstr, ok := value.(string)\nif ok {\n    fmt.Printf(\"string value is: %q\\n\", str)\n} else {\n    fmt.Printf(\"value is not a string\\n\")\n}\nIf the type assertion fails,\nstr\nwill still exist and be of type string, but it will have\nthe zero value, an empty string.\nAs an illustration of the capability, here's an\nif\n-\nelse\nstatement that's equivalent to the type switch that opened this section.\nif str, ok := value.(string); ok {\n    return str\n} else if str, ok := value.(Stringer); ok {\n    return str.String()\n}\nGenerality\nIf a type exists only to implement an interface and will\nnever have exported methods beyond that interface, there is\nno need to export the type itself.\nExporting just the interface makes it clear the value has no\ninteresting behavior beyond what is described in the\ninterface.\nIt also avoids the need to repeat the documentation\non every instance of a common method.\nIn such cases, the constructor should return an interface value\nrather than the implementing type.\nAs an example, in the hash libraries\nboth\ncrc32.NewIEEE\nand\nadler32.New\nreturn the interface type\nhash.Hash32\n.\nSubstituting the CRC-32 algorithm for Adler-32 in a Go program\nrequires only changing the constructor call;\nthe rest of the code is unaffected by the change of algorithm.\nA similar approach allows the streaming cipher algorithms\nin the various\ncrypto\npackages to be\nseparated from the block ciphers they chain together.\nThe\nBlock\ninterface\nin the\ncrypto/cipher\npackage specifies the\nbehavior of a block cipher, which provides encryption\nof a single block of data.\nThen, by analogy with the\nbufio\npackage,\ncipher packages that implement this interface\ncan be used to construct streaming ciphers, represented\nby the\nStream\ninterface, without\nknowing the details of the block encryption.\nThe\ncrypto/cipher\ninterfaces look like this:\ntype Block interface {\n    BlockSize() int\n    Encrypt(dst, src []byte)\n    Decrypt(dst, src []byte)\n}\n\ntype Stream interface {\n    XORKeyStream(dst, src []byte)\n}\nHere's the definition of the counter mode (CTR) stream,\nwhich turns a block cipher into a streaming cipher; notice\nthat the block cipher's details are abstracted away:\n// NewCTR returns a Stream that encrypts/decrypts using the given Block in\n// counter mode. The length of iv must be the same as the Block's block size.\nfunc NewCTR(block Block, iv []byte) Stream\nNewCTR\napplies not\njust to one specific encryption algorithm and data source but to any\nimplementation of the\nBlock\ninterface and any\nStream\n.  Because they return\ninterface values, replacing CTR\nencryption with other encryption modes is a localized change.  The constructor\ncalls must be edited, but because the surrounding code must treat the result only\nas a\nStream\n, it won't notice the difference.\nInterfaces and methods\nSince almost anything can have methods attached, almost anything can\nsatisfy an interface.  One illustrative example is in the\nhttp\npackage, which defines the\nHandler\ninterface.  Any object\nthat implements\nHandler\ncan serve HTTP requests.\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\nResponseWriter\nis itself an interface that provides access\nto the methods needed to return the response to the client.\nThose methods include the standard\nWrite\nmethod, so an\nhttp.ResponseWriter\ncan be used wherever an\nio.Writer\ncan be used.\nRequest\nis a struct containing a parsed representation\nof the request from the client.\nFor brevity, let's ignore POSTs and assume HTTP requests are always\nGETs; that simplification does not affect the way the handlers are set up.\nHere's a trivial implementation of a handler to count the number of times\nthe page is visited.\n// Simple counter server.\ntype Counter struct {\n    n int\n}\n\nfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    ctr.n++\n    fmt.Fprintf(w, \"counter = %d\\n\", ctr.n)\n}\n(Keeping with our theme, note how\nFprintf\ncan print to an\nhttp.ResponseWriter\n.)\nIn a real server, access to\nctr.n\nwould need protection from\nconcurrent access.\nSee the\nsync\nand\natomic\npackages for suggestions.\nFor reference, here's how to attach such a server to a node on the URL tree.\nimport \"net/http\"\n...\nctr := new(Counter)\nhttp.Handle(\"/counter\", ctr)\nBut why make\nCounter\na struct?  An integer is all that's needed.\n(The receiver needs to be a pointer so the increment is visible to the caller.)\n// Simpler counter server.\ntype Counter int\n\nfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    *ctr++\n    fmt.Fprintf(w, \"counter = %d\\n\", *ctr)\n}\nWhat if your program has some internal state that needs to be notified that a page\nhas been visited?  Tie a channel to the web page.\n// A channel that sends a notification on each visit.\n// (Probably want the channel to be buffered.)\ntype Chan chan *http.Request\n\nfunc (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    ch <- req\n    fmt.Fprint(w, \"notification sent\")\n}\nFinally, let's say we wanted to present on\n/args\nthe arguments\nused when invoking the server binary.\nIt's easy to write a function to print the arguments.\nfunc ArgServer() {\n    fmt.Println(os.Args)\n}\nHow do we turn that into an HTTP server?  We could make\nArgServer\na method of some type whose value we ignore, but there's a cleaner way.\nSince we can define a method for any type except pointers and interfaces,\nwe can write a method for a function.\nThe\nhttp\npackage contains this code:\n// The HandlerFunc type is an adapter to allow the use of\n// ordinary functions as HTTP handlers.  If f is a function\n// with the appropriate signature, HandlerFunc(f) is a\n// Handler object that calls f.\ntype HandlerFunc func(ResponseWriter, *Request)\n\n// ServeHTTP calls f(w, req).\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {\n    f(w, req)\n}\nHandlerFunc\nis a type with a method,\nServeHTTP\n,\nso values of that type can serve HTTP requests.  Look at the implementation\nof the method: the receiver is a function,\nf\n, and the method\ncalls\nf\n.  That may seem odd but it's not that different from, say,\nthe receiver being a channel and the method sending on the channel.\nTo make\nArgServer\ninto an HTTP server, we first modify it\nto have the right signature.\n// Argument server.\nfunc ArgServer(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(w, os.Args)\n}\nArgServer\nnow has the same signature as\nHandlerFunc\n,\nso it can be converted to that type to access its methods,\njust as we converted\nSequence\nto\nIntSlice\nto access\nIntSlice.Sort\n.\nThe code to set it up is concise:\nhttp.Handle(\"/args\", http.HandlerFunc(ArgServer))\nWhen someone visits the page\n/args\n,\nthe handler installed at that page has value\nArgServer\nand type\nHandlerFunc\n.\nThe HTTP server will invoke the method\nServeHTTP\nof that type, with\nArgServer\nas the receiver, which will in turn call\nArgServer\n(via the invocation\nf(w, req)\ninside\nHandlerFunc.ServeHTTP\n).\nThe arguments will then be displayed.\nIn this section we have made an HTTP server from a struct, an integer,\na channel, and a function, all because interfaces are just sets of\nmethods, which can be defined for (almost) any type.\nThe blank identifier\nWe've mentioned the blank identifier a couple of times now, in the context of\nfor\nrange\nloops\nand\nmaps\n.\nThe blank identifier can be assigned or declared with any value of any type, with the\nvalue discarded harmlessly.\nIt's a bit like writing to the Unix\n/dev/null\nfile:\nit represents a write-only value\nto be used as a place-holder\nwhere a variable is needed but the actual value is irrelevant.\nIt has uses beyond those we've seen already.\nThe blank identifier in multiple assignment\nThe use of a blank identifier in a\nfor\nrange\nloop is a\nspecial case of a general situation: multiple assignment.\nIf an assignment requires multiple values on the left side,\nbut one of the values will not be used by the program,\na blank identifier on the left-hand-side of\nthe assignment avoids the need\nto create a dummy variable and makes it clear that the\nvalue is to be discarded.\nFor instance, when calling a function that returns\na value and an error, but only the error is important,\nuse the blank identifier to discard the irrelevant value.\nif _, err := os.Stat(path); os.IsNotExist(err) {\n    fmt.Printf(\"%s does not exist\\n\", path)\n}\nOccasionally you'll see code that discards the error value in order\nto ignore the error; this is terrible practice. Always check error returns;\nthey're provided for a reason.\n// Bad! This code will crash if path does not exist.\nfi, _ := os.Stat(path)\nif fi.IsDir() {\n    fmt.Printf(\"%s is a directory\\n\", path)\n}\nUnused imports and variables\nIt is an error to import a package or to declare a variable without using it.\nUnused imports bloat the program and slow compilation,\nwhile a variable that is initialized but not used is at least\na wasted computation and perhaps indicative of a\nlarger bug.\nWhen a program is under active development, however,\nunused imports and variables often arise and it can\nbe annoying to delete them just to have the compilation proceed,\nonly to have them be needed again later.\nThe blank identifier provides a workaround.\nThis half-written program has two unused imports\n(\nfmt\nand\nio\n)\nand an unused variable (\nfd\n),\nso it will not compile, but it would be nice to see if the\ncode so far is correct.\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    fd, err := os.Open(\"test.go\")\n    if err != nil {\n        log.Fatal(err)\n    }\n// TODO: use fd.\n}\nTo silence complaints about the unused imports, use a\nblank identifier to refer to a symbol from the imported package.\nSimilarly, assigning the unused variable\nfd\nto the blank identifier will silence the unused variable error.\nThis version of the program does compile.\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nvar _ = fmt.Printf\n// For debugging; delete when done.\nvar _ io.Reader\n// For debugging; delete when done.\nfunc main() {\n    fd, err := os.Open(\"test.go\")\n    if err != nil {\n        log.Fatal(err)\n    }\n// TODO: use fd.\n_ = fd\n}\nBy convention, the global declarations to silence import errors\nshould come right after the imports and be commented,\nboth to make them easy to find and as a reminder to clean things up later.\nImport for side effect\nAn unused import like\nfmt\nor\nio\nin the\nprevious example should eventually be used or removed:\nblank assignments identify code as a work in progress.\nBut sometimes it is useful to import a package only for its\nside effects, without any explicit use.\nFor example, during its\ninit\nfunction,\nthe\nnet/http/pprof\npackage registers HTTP handlers that provide\ndebugging information. It has an exported API, but\nmost clients need only the handler registration and\naccess the data through a web page.\nTo import the package only for its side effects, rename the package\nto the blank identifier:\nimport _ \"net/http/pprof\"\nThis form of import makes clear that the package is being\nimported for its side effects, because there is no other possible\nuse of the package: in this file, it doesn't have a name.\n(If it did, and we didn't use that name, the compiler would reject the program.)\nInterface checks\nAs we saw in the discussion of\ninterfaces\nabove,\na type need not declare explicitly that it implements an interface.\nInstead, a type implements the interface just by implementing the interface's methods.\nIn practice, most interface conversions are static and therefore checked at compile time.\nFor example, passing an\n*os.File\nto a function\nexpecting an\nio.Reader\nwill not compile unless\n*os.File\nimplements the\nio.Reader\ninterface.\nSome interface checks do happen at run-time, though.\nOne instance is in the\nencoding/json\npackage, which defines a\nMarshaler\ninterface. When the JSON encoder receives a value that implements that interface,\nthe encoder invokes the value's marshaling method to convert it to JSON\ninstead of doing the standard conversion.\nThe encoder checks this property at run time with a\ntype assertion\nlike:\nm, ok := val.(json.Marshaler)\nIf it's necessary only to ask whether a type implements an interface, without\nactually using the interface itself, perhaps as part of an error check, use the blank\nidentifier to ignore the type-asserted value:\nif _, ok := val.(json.Marshaler); ok {\n    fmt.Printf(\"value %v of type %T implements json.Marshaler\\n\", val, val)\n}\nOne place this situation arises is when it is necessary to guarantee within the package implementing the type that\nit actually satisfies the interface.\nIf a typefor example,\njson.RawMessage\nneeds\na custom JSON representation, it should implement\njson.Marshaler\n, but there are no static conversions that would\ncause the compiler to verify this automatically.\nIf the type inadvertently fails to satisfy the interface, the JSON encoder will still work,\nbut will not use the custom implementation.\nTo guarantee that the implementation is correct,\na global declaration using the blank identifier can be used in the package:\nvar _ json.Marshaler = (*RawMessage)(nil)\nIn this declaration, the assignment involving a conversion of a\n*RawMessage\nto a\nMarshaler\nrequires that\n*RawMessage\nimplements\nMarshaler\n,\nand that property will be checked at compile time.\nShould the\njson.Marshaler\ninterface change, this package\nwill no longer compile and we will be on notice that it needs to be updated.\nThe appearance of the blank identifier in this construct indicates that\nthe declaration exists only for the type checking,\nnot to create a variable.\nDon't do this for every type that satisfies an interface, though.\nBy convention, such declarations are only used\nwhen there are no static conversions already present in the code,\nwhich is a rare event.\nEmbedding\nGo does not provide the typical, type-driven notion of subclassing,\nbut it does have the ability to borrow pieces of an\nimplementation by\nembedding\ntypes within a struct or\ninterface.\nInterface embedding is very simple.\nWe've mentioned the\nio.Reader\nand\nio.Writer\ninterfaces before;\nhere are their definitions.\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\nThe\nio\npackage also exports several other interfaces\nthat specify objects that can implement several such methods.\nFor instance, there is\nio.ReadWriter\n, an interface\ncontaining both\nRead\nand\nWrite\n.\nWe could specify\nio.ReadWriter\nby listing the\ntwo methods explicitly, but it's easier and more evocative\nto embed the two interfaces to form the new one, like this:\n// ReadWriter is the interface that combines the Reader and Writer interfaces.\ntype ReadWriter interface {\n    Reader\n    Writer\n}\nThis says just what it looks like: A\nReadWriter\ncan do\nwhat a\nReader\ndoes\nand\nwhat a\nWriter\ndoes; it is a union of the embedded interfaces.\nOnly interfaces can be embedded within interfaces.\nThe same basic idea applies to structs, but with more far-reaching\nimplications.  The\nbufio\npackage has two struct types,\nbufio.Reader\nand\nbufio.Writer\n, each of\nwhich of course implements the analogous interfaces from package\nio\n.\nAnd\nbufio\nalso implements a buffered reader/writer,\nwhich it does by combining a reader and a writer into one struct\nusing embedding: it lists the types within the struct\nbut does not give them field names.\n// ReadWriter stores pointers to a Reader and a Writer.\n// It implements io.ReadWriter.\ntype ReadWriter struct {\n    *Reader  // *bufio.Reader\n    *Writer  // *bufio.Writer\n}\nThe embedded elements are pointers to structs and of course\nmust be initialized to point to valid structs before they\ncan be used.\nThe\nReadWriter\nstruct could be written as\ntype ReadWriter struct {\n    reader *Reader\n    writer *Writer\n}\nbut then to promote the methods of the fields and to\nsatisfy the\nio\ninterfaces, we would also need\nto provide forwarding methods, like this:\nfunc (rw *ReadWriter) Read(p []byte) (n int, err error) {\n    return rw.reader.Read(p)\n}\nBy embedding the structs directly, we avoid this bookkeeping.\nThe methods of embedded types come along for free, which means that\nbufio.ReadWriter\nnot only has the methods of\nbufio.Reader\nand\nbufio.Writer\n,\nit also satisfies all three interfaces:\nio.Reader\n,\nio.Writer\n, and\nio.ReadWriter\n.\nThere's an important way in which embedding differs from subclassing.  When we embed a type,\nthe methods of that type become methods of the outer type,\nbut when they are invoked the receiver of the method is the inner type, not the outer one.\nIn our example, when the\nRead\nmethod of a\nbufio.ReadWriter\nis\ninvoked, it has exactly the same effect as the forwarding method written out above;\nthe receiver is the\nreader\nfield of the\nReadWriter\n, not the\nReadWriter\nitself.\nEmbedding can also be a simple convenience.\nThis example shows an embedded field alongside a regular, named field.\ntype Job struct {\n    Command string\n    *log.Logger\n}\nThe\nJob\ntype now has the\nPrint\n,\nPrintf\n,\nPrintln\nand other\nmethods of\n*log.Logger\n.  We could have given the\nLogger\na field name, of course, but it's not necessary to do so.  And now, once\ninitialized, we can\nlog to the\nJob\n:\njob.Println(\"starting now...\")\nThe\nLogger\nis a regular field of the\nJob\nstruct,\nso we can initialize it in the usual way inside the constructor for\nJob\n, like this,\nfunc NewJob(command string, logger *log.Logger) *Job {\n    return &Job{command, logger}\n}\nor with a composite literal,\njob := &Job{command, log.New(os.Stderr, \"Job: \", log.Ldate)}\nIf we need to refer to an embedded field directly, the type name of the field,\nignoring the package qualifier, serves as a field name, as it did\nin the\nRead\nmethod of our\nReadWriter\nstruct.\nHere, if we needed to access the\n*log.Logger\nof a\nJob\nvariable\njob\n,\nwe would write\njob.Logger\n,\nwhich would be useful if we wanted to refine the methods of\nLogger\n.\nfunc (job *Job) Printf(format string, args ...interface{}) {\n    job.Logger.Printf(\"%q: %s\", job.Command, fmt.Sprintf(format, args...))\n}\nEmbedding types introduces the problem of name conflicts but the rules to resolve\nthem are simple.\nFirst, a field or method\nX\nhides any other item\nX\nin a more deeply\nnested part of the type.\nIf\nlog.Logger\ncontained a field or method called\nCommand\n, the\nCommand\nfield\nof\nJob\nwould dominate it.\nSecond, if the same name appears at the same nesting level, it is usually an error;\nit would be erroneous to embed\nlog.Logger\nif the\nJob\nstruct\ncontained another field or method called\nLogger\n.\nHowever, if the duplicate name is never mentioned in the program outside the type definition, it is OK.\nThis qualification provides some protection against changes made to types embedded from outside; there\nis no problem if a field is added that conflicts with another field in another subtype if neither field\nis ever used.\nConcurrency\nShare by communicating\nConcurrent programming is a large topic and there is space only for some\nGo-specific highlights here.\nConcurrent programming in many environments is made difficult by the\nsubtleties required to implement correct access to shared variables.  Go encourages\na different approach in which shared values are passed around on channels\nand, in fact, never actively shared by separate threads of execution.\nOnly one goroutine has access to the value at any given time.\nData races cannot occur, by design.\nTo encourage this way of thinking we have reduced it to a slogan:\nDo not communicate by sharing memory;\ninstead, share memory by communicating.\nThis approach can be taken too far.  Reference counts may be best done\nby putting a mutex around an integer variable, for instance.  But as a\nhigh-level approach, using channels to control access makes it easier\nto write clear, correct programs.\nOne way to think about this model is to consider a typical single-threaded\nprogram running on one CPU. It has no need for synchronization primitives.\nNow run another such instance; it too needs no synchronization.  Now let those\ntwo communicate; if the communication is the synchronizer, there's still no need\nfor other synchronization.  Unix pipelines, for example, fit this model\nperfectly.  Although Go's approach to concurrency originates in Hoare's\nCommunicating Sequential Processes (CSP),\nit can also be seen as a type-safe generalization of Unix pipes.\nGoroutines\nThey're called\ngoroutines\nbecause the existing\ntermsthreads, coroutines, processes, and so onconvey\ninaccurate connotations.  A goroutine has a simple model: it is a\nfunction executing concurrently with other goroutines in the same\naddress space.  It is lightweight, costing little more than the\nallocation of stack space.\nAnd the stacks start small, so they are cheap, and grow\nby allocating (and freeing) heap storage as required.\nGoroutines are multiplexed onto multiple OS threads so if one should\nblock, such as while waiting for I/O, others continue to run.  Their\ndesign hides many of the complexities of thread creation and\nmanagement.\nPrefix a function or method call with the\ngo\nkeyword to run the call in a new goroutine.\nWhen the call completes, the goroutine\nexits, silently.  (The effect is similar to the Unix shell's\n&\nnotation for running a command in the\nbackground.)\ngo list.Sort()  // run list.Sort concurrently; don't wait for it.\nA function literal can be handy in a goroutine invocation.\nfunc Announce(message string, delay time.Duration) {\n    go func() {\n        time.Sleep(delay)\n        fmt.Println(message)\n    }()  // Note the parentheses - must call the function.\n}\nIn Go, function literals are closures: the implementation makes\nsure the variables referred to by the function survive as long as they are active.\nThese examples aren't too practical because the functions have no way of signaling\ncompletion.  For that, we need channels.\nChannels\nLike maps, channels are allocated with\nmake\n, and\nthe resulting value acts as a reference to an underlying data structure.\nIf an optional integer parameter is provided, it sets the buffer size for the channel.\nThe default is zero, for an unbuffered or synchronous channel.\nci := make(chan int)            // unbuffered channel of integers\ncj := make(chan int, 0)         // unbuffered channel of integers\ncs := make(chan *os.File, 100)  // buffered channel of pointers to Files\nUnbuffered channels combine communicationthe exchange of a valuewith\nsynchronizationguaranteeing that two calculations (goroutines) are in\na known state.\nThere are lots of nice idioms using channels.  Here's one to get us started.\nIn the previous section we launched a sort in the background. A channel\ncan allow the launching goroutine to wait for the sort to complete.\nc := make(chan int)  // Allocate a channel.\n// Start the sort in a goroutine; when it completes, signal on the channel.\ngo func() {\n    list.Sort()\n    c <- 1  // Send a signal; value does not matter.\n}()\ndoSomethingForAWhile()\n<-c   // Wait for sort to finish; discard sent value.\nReceivers always block until there is data to receive.\nIf the channel is unbuffered, the sender blocks until the receiver has\nreceived the value.\nIf the channel has a buffer, the sender blocks only until the\nvalue has been copied to the buffer; if the buffer is full, this\nmeans waiting until some receiver has retrieved a value.\nA buffered channel can be used like a semaphore, for instance to\nlimit throughput.  In this example, incoming requests are passed\nto\nhandle\n, which sends a value into the channel, processes\nthe request, and then receives a value from the channel\nto ready the semaphore for the next consumer.\nThe capacity of the channel buffer limits the number of\nsimultaneous calls to\nprocess\n.\nvar sem = make(chan int, MaxOutstanding)\n\nfunc handle(r *Request) {\n    sem <- 1    // Wait for active queue to drain.\n    process(r)  // May take a long time.\n    <-sem       // Done; enable next request to run.\n}\n\nfunc Serve(queue chan *Request) {\n    for {\n        req := <-queue\n        go handle(req)  // Don't wait for handle to finish.\n    }\n}\nOnce\nMaxOutstanding\nhandlers are executing\nprocess\n,\nany more will block trying to send into the filled channel buffer,\nuntil one of the existing handlers finishes and receives from the buffer.\nThis design has a problem, though:\nServe\ncreates a new goroutine for\nevery incoming request, even though only\nMaxOutstanding\nof them can run at any moment.\nAs a result, the program can consume unlimited resources if the requests come in too fast.\nWe can address that deficiency by changing\nServe\nto\ngate the creation of the goroutines:\nfunc Serve(queue chan *Request) {\n    for req := range queue {\n        sem <- 1\n        go func() {\n            process(req)\n            <-sem\n        }()\n    }\n}\n(Note that in Go versions before 1.22 this code has a bug: the loop\nvariable is shared across all goroutines.\nSee the\nGo wiki\nfor details.)\nAnother approach that manages resources well is to start a fixed\nnumber of\nhandle\ngoroutines all reading from the request\nchannel.\nThe number of goroutines limits the number of simultaneous\ncalls to\nprocess\n.\nThis\nServe\nfunction also accepts a channel on which\nit will be told to exit; after launching the goroutines it blocks\nreceiving from that channel.\nfunc handle(queue chan *Request) {\n    for r := range queue {\n        process(r)\n    }\n}\n\nfunc Serve(clientRequests chan *Request, quit chan bool) {\n    // Start handlers\n    for i := 0; i < MaxOutstanding; i++ {\n        go handle(clientRequests)\n    }\n    <-quit  // Wait to be told to exit.\n}\nChannels of channels\nOne of the most important properties of Go is that\na channel is a first-class value that can be allocated and passed\naround like any other.  A common use of this property is\nto implement safe, parallel demultiplexing.\nIn the example in the previous section,\nhandle\nwas\nan idealized handler for a request but we didn't define the\ntype it was handling.  If that type includes a channel on which\nto reply, each client can provide its own path for the answer.\nHere's a schematic definition of type\nRequest\n.\ntype Request struct {\n    args        []int\n    f           func([]int) int\n    resultChan  chan int\n}\nThe client provides a function and its arguments, as well as\na channel inside the request object on which to receive the answer.\nfunc sum(a []int) (s int) {\n    for _, v := range a {\n        s += v\n    }\n    return\n}\n\nrequest := &Request{[]int{3, 4, 5}, sum, make(chan int)}\n// Send request\nclientRequests <- request\n// Wait for response.\nfmt.Printf(\"answer: %d\\n\", <-request.resultChan)\nOn the server side, the handler function is the only thing that changes.\nfunc handle(queue chan *Request) {\n    for req := range queue {\n        req.resultChan <- req.f(req.args)\n    }\n}\nThere's clearly a lot more to do to make it realistic, but this\ncode is a framework for a rate-limited, parallel, non-blocking RPC\nsystem, and there's not a mutex in sight.\nParallelization\nAnother application of these ideas is to parallelize a calculation\nacross multiple CPU cores.  If the calculation can be broken into\nseparate pieces that can execute independently, it can be parallelized,\nwith a channel to signal when each piece completes.\nLet's say we have an expensive operation to perform on a vector of items,\nand that the value of the operation on each item is independent,\nas in this idealized example.\ntype Vector []float64\n\n// Apply the operation to v[i], v[i+1] ... up to v[n-1].\nfunc (v Vector) DoSome(i, n int, u Vector, c chan int) {\n    for ; i < n; i++ {\n        v[i] += u.Op(v[i])\n    }\n    c <- 1    // signal that this piece is done\n}\nWe launch the pieces independently in a loop, one per CPU.\nThey can complete in any order but it doesn't matter; we just\ncount the completion signals by draining the channel after\nlaunching all the goroutines.\nconst numCPU = 4 // number of CPU cores\n\nfunc (v Vector) DoAll(u Vector) {\n    c := make(chan int, numCPU)  // Buffering optional but sensible.\n    for i := 0; i < numCPU; i++ {\n        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)\n    }\n    // Drain the channel.\n    for i := 0; i < numCPU; i++ {\n        <-c    // wait for one task to complete\n    }\n    // All done.\n}\nRather than create a constant value for numCPU, we can ask the runtime what\nvalue is appropriate.\nThe function\nruntime.NumCPU\nreturns the number of hardware CPU cores in the machine, so we could write\nvar numCPU = runtime.NumCPU()\nThere is also a function\nruntime.GOMAXPROCS\n,\nwhich reports (or sets)\nthe user-specified number of cores that a Go program can have running\nsimultaneously.\nIt defaults to the value of\nruntime.NumCPU\nbut can be\noverridden by setting the similarly named shell environment variable\nor by calling the function with a positive number.  Calling it with\nzero just queries the value.\nTherefore if we want to honor the user's resource request, we should write\nvar numCPU = runtime.GOMAXPROCS(0)\nBe sure not to confuse the ideas of concurrencystructuring a program\nas independently executing componentsand parallelismexecuting\ncalculations in parallel for efficiency on multiple CPUs.\nAlthough the concurrency features of Go can make some problems easy\nto structure as parallel computations, Go is a concurrent language,\nnot a parallel one, and not all parallelization problems fit Go's model.\nFor a discussion of the distinction, see the talk cited in\nthis\nblog post\n.\nA leaky buffer\nThe tools of concurrent programming can even make non-concurrent\nideas easier to express.  Here's an example abstracted from an RPC\npackage.  The client goroutine loops receiving data from some source,\nperhaps a network.  To avoid allocating and freeing buffers, it keeps\na free list, and uses a buffered channel to represent it.  If the\nchannel is empty, a new buffer gets allocated.\nOnce the message buffer is ready, it's sent to the server on\nserverChan\n.\nvar freeList = make(chan *Buffer, 100)\nvar serverChan = make(chan *Buffer)\n\nfunc client() {\n    for {\n        var b *Buffer\n        // Grab a buffer if available; allocate if not.\n        select {\n        case b = <-freeList:\n            // Got one; nothing more to do.\n        default:\n            // None free, so allocate a new one.\n            b = new(Buffer)\n        }\n        load(b)              // Read next message from the net.\n        serverChan <- b      // Send to server.\n    }\n}\nThe server loop receives each message from the client, processes it,\nand returns the buffer to the free list.\nfunc server() {\n    for {\n        b := <-serverChan    // Wait for work.\n        process(b)\n        // Reuse buffer if there's room.\n        select {\n        case freeList <- b:\n            // Buffer on free list; nothing more to do.\n        default:\n            // Free list full, just carry on.\n        }\n    }\n}\nThe client attempts to retrieve a buffer from\nfreeList\n;\nif none is available, it allocates a fresh one.\nThe server's send to\nfreeList\nputs\nb\nback\non the free list unless the list is full, in which case the\nbuffer is dropped on the floor to be reclaimed by\nthe garbage collector.\n(The\ndefault\nclauses in the\nselect\nstatements execute when no other case is ready,\nmeaning that the\nselects\nnever block.)\nThis implementation builds a leaky bucket free list\nin just a few lines, relying on the buffered channel and\nthe garbage collector for bookkeeping.\nErrors\nLibrary routines must often return some sort of error indication to\nthe caller.\nAs mentioned earlier, Go's multivalue return makes it\neasy to return a detailed error description alongside the normal\nreturn value.\nIt is good style to use this feature to provide detailed error information.\nFor example, as we'll see,\nos.Open\ndoesn't\njust return a\nnil\npointer on failure, it also returns an\nerror value that describes what went wrong.\nBy convention, errors have type\nerror\n,\na simple built-in interface.\ntype error interface {\n    Error() string\n}\nA library writer is free to implement this interface with a\nricher model under the covers, making it possible not only\nto see the error but also to provide some context.\nAs mentioned, alongside the usual\n*os.File\nreturn value,\nos.Open\nalso returns an\nerror value.\nIf the file is opened successfully, the error will be\nnil\n,\nbut when there is a problem, it will hold an\nos.PathError\n:\n// PathError records an error and the operation and\n// file path that caused it.\ntype PathError struct {\n    Op string    // \"open\", \"unlink\", etc.\n    Path string  // The associated file.\n    Err error    // Returned by the system call.\n}\n\nfunc (e *PathError) Error() string {\n    return e.Op + \" \" + e.Path + \": \" + e.Err.Error()\n}\nPathError\n's\nError\ngenerates\na string like this:\nopen /etc/passwx: no such file or directory\nSuch an error, which includes the problematic file name, the\noperation, and the operating system error it triggered, is useful even\nif printed far from the call that caused it;\nit is much more informative than the plain\n\"no such file or directory\".\nWhen feasible, error strings should identify their origin, such as by having\na prefix naming the operation or package that generated the error.  For example, in package\nimage\n, the string representation for a decoding error due to an\nunknown format is \"image: unknown format\".\nCallers that care about the precise error details can\nuse a type switch or a type assertion to look for specific\nerrors and extract details.  For\nPathErrors\nthis might include examining the internal\nErr\nfield for recoverable failures.\nfor try := 0; try < 2; try++ {\n    file, err = os.Create(filename)\n    if err == nil {\n        return\n    }\n    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {\n        deleteTempFiles()  // Recover some space.\n        continue\n    }\n    return\n}\nThe second\nif\nstatement here is another\ntype assertion\n.\nIf it fails,\nok\nwill be false, and\ne\nwill be\nnil\n.\nIf it succeeds,\nok\nwill be true, which means the\nerror was of type\n*os.PathError\n, and then so is\ne\n,\nwhich we can examine for more information about the error.\nPanic\nThe usual way to report an error to a caller is to return an\nerror\nas an extra return value.  The canonical\nRead\nmethod is a well-known instance; it returns a byte\ncount and an\nerror\n.  But what if the error is\nunrecoverable?  Sometimes the program simply cannot continue.\nFor this purpose, there is a built-in function\npanic\nthat in effect creates a run-time error that will stop the program\n(but see the next section).  The function takes a single argument\nof arbitrary typeoften a stringto be printed as the\nprogram dies.  It's also a way to indicate that something impossible has\nhappened, such as exiting an infinite loop.\n// A toy implementation of cube root using Newton's method.\nfunc CubeRoot(x float64) float64 {\n    z := x/3   // Arbitrary initial value\n    for i := 0; i < 1e6; i++ {\n        prevz := z\n        z -= (z*z*z-x) / (3*z*z)\n        if veryClose(z, prevz) {\n            return z\n        }\n    }\n    // A million iterations has not converged; something is wrong.\n    panic(fmt.Sprintf(\"CubeRoot(%g) did not converge\", x))\n}\nThis is only an example but real library functions should\navoid\npanic\n.  If the problem can be masked or worked\naround, it's always better to let things continue to run rather\nthan taking down the whole program.  One possible counterexample\nis during initialization: if the library truly cannot set itself up,\nit might be reasonable to panic, so to speak.\nvar user = os.Getenv(\"USER\")\n\nfunc init() {\n    if user == \"\" {\n        panic(\"no value for $USER\")\n    }\n}\nRecover\nWhen\npanic\nis called, including implicitly for run-time\nerrors such as indexing a slice out of bounds or failing a type\nassertion, it immediately stops execution of the current function\nand begins unwinding the stack of the goroutine, running any deferred\nfunctions along the way.  If that unwinding reaches the top of the\ngoroutine's stack, the program dies.  However, it is possible to\nuse the built-in function\nrecover\nto regain control\nof the goroutine and resume normal execution.\nA call to\nrecover\nstops the unwinding and returns the\nargument passed to\npanic\n.  Because the only code that\nruns while unwinding is inside deferred functions,\nrecover\nis only useful inside deferred functions.\nOne application of\nrecover\nis to shut down a failing goroutine\ninside a server without killing the other executing goroutines.\nfunc server(workChan <-chan *Work) {\n    for work := range workChan {\n        go safelyDo(work)\n    }\n}\n\nfunc safelyDo(work *Work) {\n    defer func() {\n        if err := recover(); err != nil {\n            log.Println(\"work failed:\", err)\n        }\n    }()\n    do(work)\n}\nIn this example, if\ndo(work)\npanics, the result will be\nlogged and the goroutine will exit cleanly without disturbing the\nothers.  There's no need to do anything else in the deferred closure;\ncalling\nrecover\nhandles the condition completely.\nBecause\nrecover\nalways returns\nnil\nunless called directly\nfrom a deferred function, deferred code can call library routines that themselves\nuse\npanic\nand\nrecover\nwithout failing.  As an example,\nthe deferred function in\nsafelyDo\nmight call a logging function before\ncalling\nrecover\n, and that logging code would run unaffected\nby the panicking state.\nWith our recovery pattern in place, the\ndo\nfunction (and anything it calls) can get out of any bad situation\ncleanly by calling\npanic\n.  We can use that idea to\nsimplify error handling in complex software.  Let's look at an\nidealized version of a\nregexp\npackage, which reports\nparsing errors by calling\npanic\nwith a local\nerror type.  Here's the definition of\nError\n,\nan\nerror\nmethod, and the\nCompile\nfunction.\n// Error is the type of a parse error; it satisfies the error interface.\ntype Error string\nfunc (e Error) Error() string {\n    return string(e)\n}\n\n// error is a method of *Regexp that reports parsing errors by\n// panicking with an Error.\nfunc (regexp *Regexp) error(err string) {\n    panic(Error(err))\n}\n\n// Compile returns a parsed representation of the regular expression.\nfunc Compile(str string) (regexp *Regexp, err error) {\n    regexp = new(Regexp)\n    // doParse will panic if there is a parse error.\n    defer func() {\n        if e := recover(); e != nil {\n            regexp = nil    // Clear return value.\n            err = e.(Error) // Will re-panic if not a parse error.\n        }\n    }()\n    return regexp.doParse(str), nil\n}\nIf\ndoParse\npanics, the recovery block will set the\nreturn value to\nnil\ndeferred functions can modify\nnamed return values.  It will then check, in the assignment\nto\nerr\n, that the problem was a parse error by asserting\nthat it has the local type\nError\n.\nIf it does not, the type assertion will fail, causing a run-time error\nthat continues the stack unwinding as though nothing had interrupted\nit.\nThis check means that if something unexpected happens, such\nas an index out of bounds, the code will fail even though we\nare using\npanic\nand\nrecover\nto handle\nparse errors.\nWith error handling in place, the\nerror\nmethod (because it's a\nmethod bound to a type, it's fine, even natural, for it to have the same name\nas the builtin\nerror\ntype)\nmakes it easy to report parse errors without worrying about unwinding\nthe parse stack by hand:\nif pos == 0 {\n    re.error(\"'*' illegal at start of expression\")\n}\nUseful though this pattern is, it should be used only within a package.\nParse\nturns its internal\npanic\ncalls into\nerror\nvalues; it does not expose\npanics\nto its client.  That is a good rule to follow.\nBy the way, this re-panic idiom changes the panic value if an actual\nerror occurs.  However, both the original and new failures will be\npresented in the crash report, so the root cause of the problem will\nstill be visible.  Thus this simple re-panic approach is usually\nsufficientit's a crash after allbut if you want to\ndisplay only the original value, you can write a little more code to\nfilter unexpected problems and re-panic with the original error.\nThat's left as an exercise for the reader.\nA web server\nLet's finish with a complete Go program, a web server.\nThis one is actually a kind of web re-server.\nGoogle provides a service at\nchart.apis.google.com\nthat does automatic formatting of data into charts and graphs.\nIt's hard to use interactively, though,\nbecause you need to put the data into the URL as a query.\nThe program here provides a nicer interface to one form of data: given a short piece of text,\nit calls on the chart server to produce a QR code, a matrix of boxes that encode the\ntext.\nThat image can be grabbed with your cell phone's camera and interpreted as,\nfor instance, a URL, saving you typing the URL into the phone's tiny keyboard.\nHere's the complete program.\nAn explanation follows.\npackage main\n\nimport (\n    \"flag\"\n    \"html/template\"\n    \"log\"\n    \"net/http\"\n)\n\nvar addr = flag.String(\"addr\", \":1718\", \"http service address\")\n// Q=17, R=18\nvar templ = template.Must(template.New(\"qr\").Parse(templateStr))\n\nfunc main() {\n    flag.Parse()\n    http.Handle(\"/\", http.HandlerFunc(QR))\n    err := http.ListenAndServe(*addr, nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe:\", err)\n    }\n}\n\nfunc QR(w http.ResponseWriter, req *http.Request) {\n    templ.Execute(w, req.FormValue(\"s\"))\n}\n\nconst templateStr = `\n<html>\n<head>\n<title>QR Link Generator</title>\n</head>\n<body>\n{{if .}}\n<img src=\"http://chart.apis.google.com/chart?chs=300x300&cht=qr&choe=UTF-8&chl={{.}}\" />\n<br>\n{{.}}\n<br>\n<br>\n{{end}}\n<form action=\"/\" name=f method=\"GET\">\n    <input maxLength=1024 size=70 name=s value=\"\" title=\"Text to QR Encode\">\n    <input type=submit value=\"Show QR\" name=qr>\n</form>\n</body>\n</html>\n`\nThe pieces up to\nmain\nshould be easy to follow.\nThe one flag sets a default HTTP port for our server.  The template\nvariable\ntempl\nis where the fun happens. It builds an HTML template\nthat will be executed by the server to display the page; more about\nthat in a moment.\nThe\nmain\nfunction parses the flags and, using the mechanism\nwe talked about above, binds the function\nQR\nto the root path\nfor the server.  Then\nhttp.ListenAndServe\nis called to start the\nserver; it blocks while the server runs.\nQR\njust receives the request, which contains form data, and\nexecutes the template on the data in the form value named\ns\n.\nThe template package\nhtml/template\nis powerful;\nthis program just touches on its capabilities.\nIn essence, it rewrites a piece of HTML text on the fly by substituting elements derived\nfrom data items passed to\ntempl.Execute\n, in this case the\nform value.\nWithin the template text (\ntemplateStr\n),\ndouble-brace-delimited pieces denote template actions.\nThe piece from\n{{if .}}\nto\n{{end}}\nexecutes only if the value of the current data item, called\n.\n(dot),\nis non-empty.\nThat is, when the string is empty, this piece of the template is suppressed.\nThe two snippets\n{{.}}\nsay to show the data presented to\nthe templatethe query stringon the web page.\nThe HTML template package automatically provides appropriate escaping so the\ntext is safe to display.\nThe rest of the template string is just the HTML to show when the page loads.\nIf this is too quick an explanation, see the\ndocumentation\nfor the template package for a more thorough discussion.\nAnd there you have it: a useful web server in a few lines of code plus some\ndata-driven HTML text.\nGo is powerful enough to make a lot happen in a few lines.",
      "code_examples": [
        {
          "language": "",
          "code": "type T struct {\n    name string // name of the object\n    value int // its value\n}",
          "element": "<pre>\ntype T struct {\n    name string // name of the object\n    value int // its value\n}\n</pre>"
        },
        {
          "language": "",
          "code": "type T struct {\n    name    string // name of the object\n    value   int    // its value\n}",
          "element": "<pre>\ntype T struct {\n    name    string // name of the object\n    value   int    // its value\n}\n</pre>"
        },
        {
          "language": "",
          "code": "x<<8 + y<<16",
          "element": "<pre>\nx&lt;&lt;8 + y&lt;&lt;16\n</pre>"
        },
        {
          "language": "",
          "code": "import \"bytes\"",
          "element": "<pre>\nimport \"bytes\"\n</pre>"
        },
        {
          "language": "",
          "code": "bytes.Buffer",
          "element": "<code>bytes.Buffer</code>"
        },
        {
          "language": "",
          "code": "src/encoding/base64",
          "element": "<code>src/encoding/base64</code>"
        },
        {
          "language": "",
          "code": "\"encoding/base64\"",
          "element": "<code>\"encoding/base64\"</code>"
        },
        {
          "language": "",
          "code": "encoding_base64",
          "element": "<code>encoding_base64</code>"
        },
        {
          "language": "",
          "code": "encodingBase64",
          "element": "<code>encodingBase64</code>"
        },
        {
          "language": "",
          "code": "bufio.Reader",
          "element": "<code>bufio.Reader</code>"
        },
        {
          "language": "",
          "code": "bufio.Reader",
          "element": "<code>bufio.Reader</code>"
        },
        {
          "language": "",
          "code": "once.Do(setup)",
          "element": "<code>once.Do(setup)</code>"
        },
        {
          "language": "",
          "code": "once.DoOrWaitUntilDone(setup)",
          "element": "<code>once.DoOrWaitUntilDone(setup)</code>"
        },
        {
          "language": "",
          "code": "owner := obj.Owner()\nif owner != user {\n    obj.SetOwner(user)\n}",
          "element": "<pre>\nowner := obj.Owner()\nif owner != user {\n    obj.SetOwner(user)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "CloseNotifier",
          "element": "<code>CloseNotifier</code>"
        },
        {
          "language": "",
          "code": "break continue fallthrough return ++ -- ) }",
          "element": "<pre>\nbreak continue fallthrough return ++ -- ) }\n</pre>"
        },
        {
          "language": "",
          "code": "go func() { for { dst <- <-src } }()",
          "element": "<pre>\n    go func() { for { dst &lt;- &lt;-src } }()\n</pre>"
        },
        {
          "language": "",
          "code": "if i < f() {\n    g()\n}",
          "element": "<pre>\nif i &lt; f() {\n    g()\n}\n</pre>"
        },
        {
          "language": "",
          "code": "if i < f()  // wrong!\n{           // wrong!\n    g()\n}",
          "element": "<pre>\nif i &lt; f()  // wrong!\n{           // wrong!\n    g()\n}\n</pre>"
        },
        {
          "language": "",
          "code": "if x > 0 {\n    return y\n}",
          "element": "<pre>\nif x &gt; 0 {\n    return y\n}\n</pre>"
        },
        {
          "language": "",
          "code": "if err := file.Chmod(0664); err != nil {\n    log.Print(err)\n    return err\n}",
          "element": "<pre>\nif err := file.Chmod(0664); err != nil {\n    log.Print(err)\n    return err\n}\n</pre>"
        },
        {
          "language": "",
          "code": "f, err := os.Open(name)\nif err != nil {\n    return err\n}\ncodeUsing(f)",
          "element": "<pre>\nf, err := os.Open(name)\nif err != nil {\n    return err\n}\ncodeUsing(f)\n</pre>"
        },
        {
          "language": "",
          "code": "f, err := os.Open(name)\nif err != nil {\n    return err\n}\nd, err := f.Stat()\nif err != nil {\n    f.Close()\n    return err\n}\ncodeUsing(f, d)",
          "element": "<pre>\nf, err := os.Open(name)\nif err != nil {\n    return err\n}\nd, err := f.Stat()\nif err != nil {\n    f.Close()\n    return err\n}\ncodeUsing(f, d)\n</pre>"
        },
        {
          "language": "",
          "code": "f, err := os.Open(name)",
          "element": "<pre>\nf, err := os.Open(name)\n</pre>"
        },
        {
          "language": "",
          "code": "d, err := f.Stat()",
          "element": "<pre>\nd, err := f.Stat()\n</pre>"
        },
        {
          "language": "",
          "code": "// Like a C for\nfor init; condition; post { }\n\n// Like a C while\nfor condition { }\n\n// Like a C for(;;)\nfor { }",
          "element": "<pre>\n// Like a C for\nfor init; condition; post { }\n\n// Like a C while\nfor condition { }\n\n// Like a C for(;;)\nfor { }\n</pre>"
        },
        {
          "language": "",
          "code": "sum := 0\nfor i := 0; i < 10; i++ {\n    sum += i\n}",
          "element": "<pre>\nsum := 0\nfor i := 0; i &lt; 10; i++ {\n    sum += i\n}\n</pre>"
        },
        {
          "language": "",
          "code": "for key, value := range oldMap {\n    newMap[key] = value\n}",
          "element": "<pre>\nfor key, value := range oldMap {\n    newMap[key] = value\n}\n</pre>"
        },
        {
          "language": "",
          "code": "for key := range m {\n    if key.expired() {\n        delete(m, key)\n    }\n}",
          "element": "<pre>\nfor key := range m {\n    if key.expired() {\n        delete(m, key)\n    }\n}\n</pre>"
        },
        {
          "language": "",
          "code": "sum := 0\nfor _, value := range array {\n    sum += value\n}",
          "element": "<pre>\nsum := 0\nfor _, value := range array {\n    sum += value\n}\n</pre>"
        },
        {
          "language": "",
          "code": "for pos, char := range \"\\x80\" { // \\x80 is an illegal UTF-8 encoding\n    fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos)\n}",
          "element": "<pre>\nfor pos, char := range \"\\x80\" { // \\x80 is an illegal UTF-8 encoding\n    fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "character U+65E5 '' starts at byte position 0\ncharacter U+672C '' starts at byte position 3\ncharacter U+FFFD '' starts at byte position 6\ncharacter U+8A9E '' starts at byte position 7",
          "element": "<pre>\ncharacter U+65E5 '' starts at byte position 0\ncharacter U+672C '' starts at byte position 3\ncharacter U+FFFD '' starts at byte position 6\ncharacter U+8A9E '' starts at byte position 7\n</pre>"
        },
        {
          "language": "",
          "code": "// Reverse a\nfor i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {\n    a[i], a[j] = a[j], a[i]\n}",
          "element": "<pre>\n// Reverse a\nfor i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {\n    a[i], a[j] = a[j], a[i]\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func unhex(c byte) byte {\n    switch {\n    case '0' <= c && c <= '9':\n        return c - '0'\n    case 'a' <= c && c <= 'f':\n        return c - 'a' + 10\n    case 'A' <= c && c <= 'F':\n        return c - 'A' + 10\n    }\n    return 0\n}",
          "element": "<pre>\nfunc unhex(c byte) byte {\n    switch {\n    case '0' &lt;= c &amp;&amp; c &lt;= '9':\n        return c - '0'\n    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':\n        return c - 'a' + 10\n    case 'A' &..."
        },
        {
          "language": "",
          "code": "func shouldEscape(c byte) bool {\n    switch c {\n    case ' ', '?', '&', '=', '#', '+', '%':\n        return true\n    }\n    return false\n}",
          "element": "<pre>\nfunc shouldEscape(c byte) bool {\n    switch c {\n    case ' ', '?', '&amp;', '=', '#', '+', '%':\n        return true\n    }\n    return false\n}\n</pre>"
        },
        {
          "language": "",
          "code": "Loop:\n    for n := 0; n < len(src); n += size {\n        switch {\n        case src[n] < sizeOne:\n            if validateOnly {\n                break\n            }\n            size = 1\n            update(src[n])\n\n        case src[n] < sizeTwo:\n            if n+1 >= len(src) {\n                err = errShortInput\n                break Loop\n            }\n            if validateOnly {\n                break\n            }\n            size = 2\n            update(src[n] + src[n+1]<<shift)\n        }\n    }",
          "element": "<pre>\nLoop:\n    for n := 0; n &lt; len(src); n += size {\n        switch {\n        case src[n] &lt; sizeOne:\n            if validateOnly {\n                break\n            }\n            size = 1\n     ..."
        },
        {
          "language": "",
          "code": "// Compare returns an integer comparing the two byte slices,\n// lexicographically.\n// The result will be 0 if a == b, -1 if a < b, and +1 if a > b\nfunc Compare(a, b []byte) int {\n    for i := 0; i < len(a) && i < len(b); i++ {\n        switch {\n        case a[i] > b[i]:\n            return 1\n        case a[i] < b[i]:\n            return -1\n        }\n    }\n    switch {\n    case len(a) > len(b):\n        return 1\n    case len(a) < len(b):\n        return -1\n    }\n    return 0\n}",
          "element": "<pre>\n// Compare returns an integer comparing the two byte slices,\n// lexicographically.\n// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b\nfunc Compare(a, b []byte) int {\n    for i..."
        },
        {
          "language": "",
          "code": "var t interface{}\nt = functionOfSomeType()\nswitch t := t.(type) {\ndefault:\n    fmt.Printf(\"unexpected type %T\\n\", t)     // %T prints whatever type t has\ncase bool:\n    fmt.Printf(\"boolean %t\\n\", t)             // t has type bool\ncase int:\n    fmt.Printf(\"integer %d\\n\", t)             // t has type int\ncase *bool:\n    fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool\ncase *int:\n    fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int\n}",
          "element": "<pre>\nvar t interface{}\nt = functionOfSomeType()\nswitch t := t.(type) {\ndefault:\n    fmt.Printf(\"unexpected type %T\\n\", t)     // %T prints whatever type t has\ncase bool:\n    fmt.Printf(\"boolean %t\\n\"..."
        },
        {
          "language": "",
          "code": "func (file *File) Write(b []byte) (n int, err error)",
          "element": "<pre>\nfunc (file *File) Write(b []byte) (n int, err error)\n</pre>"
        },
        {
          "language": "",
          "code": "func nextInt(b []byte, i int) (int, int) {\n    for ; i < len(b) && !isDigit(b[i]); i++ {\n    }\n    x := 0\n    for ; i < len(b) && isDigit(b[i]); i++ {\n        x = x*10 + int(b[i]) - '0'\n    }\n    return x, i\n}",
          "element": "<pre>\nfunc nextInt(b []byte, i int) (int, int) {\n    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {\n    }\n    x := 0\n    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {\n        x = x*10 + in..."
        },
        {
          "language": "",
          "code": "for i := 0; i < len(b); {\n        x, i = nextInt(b, i)\n        fmt.Println(x)\n    }",
          "element": "<pre>\n    for i := 0; i &lt; len(b); {\n        x, i = nextInt(b, i)\n        fmt.Println(x)\n    }\n</pre>"
        },
        {
          "language": "",
          "code": "func nextInt(b []byte, pos int) (value, nextPos int) {",
          "element": "<pre>\nfunc nextInt(b []byte, pos int) (value, nextPos int) {\n</pre>"
        },
        {
          "language": "",
          "code": "io.ReadFull",
          "element": "<code>io.ReadFull</code>"
        },
        {
          "language": "",
          "code": "func ReadFull(r Reader, buf []byte) (n int, err error) {\n    for len(buf) > 0 && err == nil {\n        var nr int\n        nr, err = r.Read(buf)\n        n += nr\n        buf = buf[nr:]\n    }\n    return\n}",
          "element": "<pre>\nfunc ReadFull(r Reader, buf []byte) (n int, err error) {\n    for len(buf) &gt; 0 &amp;&amp; err == nil {\n        var nr int\n        nr, err = r.Read(buf)\n        n += nr\n        buf = buf[nr:]\n ..."
        },
        {
          "language": "",
          "code": "// Contents returns the file's contents as a string.\nfunc Contents(filename string) (string, error) {\n    f, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer f.Close()  // f.Close will run when we're finished.\n\n    var result []byte\n    buf := make([]byte, 100)\n    for {\n        n, err := f.Read(buf[0:])\n        result = append(result, buf[0:n]...) // append is discussed later.\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return \"\", err  // f will be closed if we return here.\n        }\n    }\n    return string(result), nil // f will be closed if we return here.\n}",
          "element": "<pre>\n// Contents returns the file's contents as a string.\nfunc Contents(filename string) (string, error) {\n    f, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer f..."
        },
        {
          "language": "",
          "code": "for i := 0; i < 5; i++ {\n    defer fmt.Printf(\"%d \", i)\n}",
          "element": "<pre>\nfor i := 0; i &lt; 5; i++ {\n    defer fmt.Printf(\"%d \", i)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func trace(s string)   { fmt.Println(\"entering:\", s) }\nfunc untrace(s string) { fmt.Println(\"leaving:\", s) }\n\n// Use them like this:\nfunc a() {\n    trace(\"a\")\n    defer untrace(\"a\")\n    // do something....\n}",
          "element": "<pre>\nfunc trace(s string)   { fmt.Println(\"entering:\", s) }\nfunc untrace(s string) { fmt.Println(\"leaving:\", s) }\n\n// Use them like this:\nfunc a() {\n    trace(\"a\")\n    defer untrace(\"a\")\n    // do so..."
        },
        {
          "language": "",
          "code": "func trace(s string) string {\n    fmt.Println(\"entering:\", s)\n    return s\n}\n\nfunc un(s string) {\n    fmt.Println(\"leaving:\", s)\n}\n\nfunc a() {\n    defer un(trace(\"a\"))\n    fmt.Println(\"in a\")\n}\n\nfunc b() {\n    defer un(trace(\"b\"))\n    fmt.Println(\"in b\")\n    a()\n}\n\nfunc main() {\n    b()\n}",
          "element": "<pre>\nfunc trace(s string) string {\n    fmt.Println(\"entering:\", s)\n    return s\n}\n\nfunc un(s string) {\n    fmt.Println(\"leaving:\", s)\n}\n\nfunc a() {\n    defer un(trace(\"a\"))\n    fmt.Println(\"in a\")\n}\n..."
        },
        {
          "language": "",
          "code": "entering: b\nin b\nentering: a\nin a\nleaving: a\nleaving: b",
          "element": "<pre>\nentering: b\nin b\nentering: a\nin a\nleaving: a\nleaving: b\n</pre>"
        },
        {
          "language": "",
          "code": "bytes.Buffer",
          "element": "<code>bytes.Buffer</code>"
        },
        {
          "language": "",
          "code": "type SyncedBuffer struct {\n    lock    sync.Mutex\n    buffer  bytes.Buffer\n}",
          "element": "<pre>\ntype SyncedBuffer struct {\n    lock    sync.Mutex\n    buffer  bytes.Buffer\n}\n</pre>"
        },
        {
          "language": "",
          "code": "SyncedBuffer",
          "element": "<code>SyncedBuffer</code>"
        },
        {
          "language": "",
          "code": "p := new(SyncedBuffer)  // type *SyncedBuffer\nvar v SyncedBuffer      // type  SyncedBuffer",
          "element": "<pre>\np := new(SyncedBuffer)  // type *SyncedBuffer\nvar v SyncedBuffer      // type  SyncedBuffer\n</pre>"
        },
        {
          "language": "",
          "code": "func NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := new(File)\n    f.fd = fd\n    f.name = name\n    f.dirinfo = nil\n    f.nepipe = 0\n    return f\n}",
          "element": "<pre>\nfunc NewFile(fd int, name string) *File {\n    if fd &lt; 0 {\n        return nil\n    }\n    f := new(File)\n    f.fd = fd\n    f.name = name\n    f.dirinfo = nil\n    f.nepipe = 0\n    return f\n}\n</pre..."
        },
        {
          "language": "",
          "code": "func NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := File{fd, name, nil, 0}\n    return &f\n}",
          "element": "<pre>\nfunc NewFile(fd int, name string) *File {\n    if fd &lt; 0 {\n        return nil\n    }\n    f := File{fd, name, nil, 0}\n    return &amp;f\n}\n</pre>"
        },
        {
          "language": "",
          "code": "return &File{fd, name, nil, 0}",
          "element": "<pre>\n    return &amp;File{fd, name, nil, 0}\n</pre>"
        },
        {
          "language": "",
          "code": "return &File{fd: fd, name: name}",
          "element": "<pre>\n    return &amp;File{fd: fd, name: name}\n</pre>"
        },
        {
          "language": "",
          "code": "a := [...]string   {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}\ns := []string      {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}\nm := map[int]string{Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}",
          "element": "<pre>\na := [...]string   {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}\ns := []string      {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"}\nm := map[int]string{Enone: \"no error..."
        },
        {
          "language": "",
          "code": "make([]int, 10, 100)",
          "element": "<pre>\nmake([]int, 10, 100)\n</pre>"
        },
        {
          "language": "",
          "code": "var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful\nvar v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints\n\n// Unnecessarily complex:\nvar p *[]int = new([]int)\n*p = make([]int, 100, 100)\n\n// Idiomatic:\nv := make([]int, 100)",
          "element": "<pre>\nvar p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful\nvar v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints\n\n// Unnecessarily comp..."
        },
        {
          "language": "",
          "code": "func Sum(a *[3]float64) (sum float64) {\n    for _, v := range *a {\n        sum += v\n    }\n    return\n}\n\narray := [...]float64{7.0, 8.5, 9.1}\nx := Sum(&array)  // Note the explicit address-of operator",
          "element": "<pre>\nfunc Sum(a *[3]float64) (sum float64) {\n    for _, v := range *a {\n        sum += v\n    }\n    return\n}\n\narray := [...]float64{7.0, 8.5, 9.1}\nx := Sum(&amp;array)  // Note the explicit address-of..."
        },
        {
          "language": "",
          "code": "func (f *File) Read(buf []byte) (n int, err error)",
          "element": "<pre>\nfunc (f *File) Read(buf []byte) (n int, err error)\n</pre>"
        },
        {
          "language": "",
          "code": "n, err := f.Read(buf[0:32])",
          "element": "<pre>\n    n, err := f.Read(buf[0:32])\n</pre>"
        },
        {
          "language": "",
          "code": "var n int\n    var err error\n    for i := 0; i < 32; i++ {\n        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.\n        n += nbytes\n        if nbytes == 0 || e != nil {\n            err = e\n            break\n        }\n    }",
          "element": "<pre>\n    var n int\n    var err error\n    for i := 0; i &lt; 32; i++ {\n        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.\n        n += nbytes\n        if nbytes == 0 || e != nil {\n            e..."
        },
        {
          "language": "",
          "code": "func Append(slice, data []byte) []byte {\n    l := len(slice)\n    if l + len(data) > cap(slice) {  // reallocate\n        // Allocate double what's needed, for future growth.\n        newSlice := make([]byte, (l+len(data))*2)\n        // The copy function is predeclared and works for any slice type.\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[0:l+len(data)]\n    copy(slice[l:], data)\n    return slice\n}",
          "element": "<pre>\nfunc Append(slice, data []byte) []byte {\n    l := len(slice)\n    if l + len(data) &gt; cap(slice) {  // reallocate\n        // Allocate double what's needed, for future growth.\n        newSlice :..."
        },
        {
          "language": "",
          "code": "type Transform [3][3]float64  // A 3x3 array, really an array of arrays.\ntype LinesOfText [][]byte     // A slice of byte slices.",
          "element": "<pre>\ntype Transform [3][3]float64  // A 3x3 array, really an array of arrays.\ntype LinesOfText [][]byte     // A slice of byte slices.\n</pre>"
        },
        {
          "language": "",
          "code": "LinesOfText",
          "element": "<code>LinesOfText</code>"
        },
        {
          "language": "",
          "code": "text := LinesOfText{\n    []byte(\"Now is the time\"),\n    []byte(\"for all good gophers\"),\n    []byte(\"to bring some fun to the party.\"),\n}",
          "element": "<pre>\ntext := LinesOfText{\n    []byte(\"Now is the time\"),\n    []byte(\"for all good gophers\"),\n    []byte(\"to bring some fun to the party.\"),\n}\n</pre>"
        },
        {
          "language": "",
          "code": "// Allocate the top-level slice.\npicture := make([][]uint8, YSize) // One row per unit of y.\n// Loop over the rows, allocating the slice for each row.\nfor i := range picture {\n    picture[i] = make([]uint8, XSize)\n}",
          "element": "<pre>\n// Allocate the top-level slice.\npicture := make([][]uint8, YSize) // One row per unit of y.\n// Loop over the rows, allocating the slice for each row.\nfor i := range picture {\n    picture[i] = m..."
        },
        {
          "language": "",
          "code": "// Allocate the top-level slice, the same as before.\npicture := make([][]uint8, YSize) // One row per unit of y.\n// Allocate one large slice to hold all the pixels.\npixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.\n// Loop over the rows, slicing each row from the front of the remaining pixels slice.\nfor i := range picture {\n    picture[i], pixels = pixels[:XSize], pixels[XSize:]\n}",
          "element": "<pre>\n// Allocate the top-level slice, the same as before.\npicture := make([][]uint8, YSize) // One row per unit of y.\n// Allocate one large slice to hold all the pixels.\npixels := make([]uint8, XSize..."
        },
        {
          "language": "",
          "code": "var timeZone = map[string]int{\n    \"UTC\":  0*60*60,\n    \"EST\": -5*60*60,\n    \"CST\": -6*60*60,\n    \"MST\": -7*60*60,\n    \"PST\": -8*60*60,\n}",
          "element": "<pre>\nvar timeZone = map[string]int{\n    \"UTC\":  0*60*60,\n    \"EST\": -5*60*60,\n    \"CST\": -6*60*60,\n    \"MST\": -7*60*60,\n    \"PST\": -8*60*60,\n}\n</pre>"
        },
        {
          "language": "",
          "code": "offset := timeZone[\"EST\"]",
          "element": "<pre>\noffset := timeZone[\"EST\"]\n</pre>"
        },
        {
          "language": "",
          "code": "attended := map[string]bool{\n    \"Ann\": true,\n    \"Joe\": true,\n    ...\n}\n\nif attended[person] { // will be false if person is not in the map\n    fmt.Println(person, \"was at the meeting\")\n}",
          "element": "<pre>\nattended := map[string]bool{\n    \"Ann\": true,\n    \"Joe\": true,\n    ...\n}\n\nif attended[person] { // will be false if person is not in the map\n    fmt.Println(person, \"was at the meeting\")\n}\n</pre..."
        },
        {
          "language": "",
          "code": "var seconds int\nvar ok bool\nseconds, ok = timeZone[tz]",
          "element": "<pre>\nvar seconds int\nvar ok bool\nseconds, ok = timeZone[tz]\n</pre>"
        },
        {
          "language": "",
          "code": "func offset(tz string) int {\n    if seconds, ok := timeZone[tz]; ok {\n        return seconds\n    }\n    log.Println(\"unknown time zone:\", tz)\n    return 0\n}",
          "element": "<pre>\nfunc offset(tz string) int {\n    if seconds, ok := timeZone[tz]; ok {\n        return seconds\n    }\n    log.Println(\"unknown time zone:\", tz)\n    return 0\n}\n</pre>"
        },
        {
          "language": "",
          "code": "_, present := timeZone[tz]",
          "element": "<pre>\n_, present := timeZone[tz]\n</pre>"
        },
        {
          "language": "",
          "code": "delete(timeZone, \"PDT\")  // Now on Standard Time",
          "element": "<pre>\ndelete(timeZone, \"PDT\")  // Now on Standard Time\n</pre>"
        },
        {
          "language": "",
          "code": "fmt.Fprintf",
          "element": "<code>fmt.Fprintf</code>"
        },
        {
          "language": "",
          "code": "fmt.Sprintf",
          "element": "<code>fmt.Sprintf</code>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"Hello %d\\n\", 23)\nfmt.Fprint(os.Stdout, \"Hello \", 23, \"\\n\")\nfmt.Println(\"Hello\", 23)\nfmt.Println(fmt.Sprint(\"Hello \", 23))",
          "element": "<pre>\nfmt.Printf(\"Hello %d\\n\", 23)\nfmt.Fprint(os.Stdout, \"Hello \", 23, \"\\n\")\nfmt.Println(\"Hello\", 23)\nfmt.Println(fmt.Sprint(\"Hello \", 23))\n</pre>"
        },
        {
          "language": "",
          "code": "var x uint64 = 1<<64 - 1\nfmt.Printf(\"%d %x; %d %x\\n\", x, x, int64(x), int64(x))",
          "element": "<pre>\nvar x uint64 = 1&lt;&lt;64 - 1\nfmt.Printf(\"%d %x; %d %x\\n\", x, x, int64(x), int64(x))\n</pre>"
        },
        {
          "language": "",
          "code": "18446744073709551615 ffffffffffffffff; -1 -1",
          "element": "<pre>\n18446744073709551615 ffffffffffffffff; -1 -1\n</pre>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"%v\\n\", timeZone)  // or just fmt.Println(timeZone)",
          "element": "<pre>\nfmt.Printf(\"%v\\n\", timeZone)  // or just fmt.Println(timeZone)\n</pre>"
        },
        {
          "language": "",
          "code": "map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]",
          "element": "<pre>\nmap[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]\n</pre>"
        },
        {
          "language": "",
          "code": "type T struct {\n    a int\n    b float64\n    c string\n}\nt := &T{ 7, -2.35, \"abc\\tdef\" }\nfmt.Printf(\"%v\\n\", t)\nfmt.Printf(\"%+v\\n\", t)\nfmt.Printf(\"%#v\\n\", t)\nfmt.Printf(\"%#v\\n\", timeZone)",
          "element": "<pre>\ntype T struct {\n    a int\n    b float64\n    c string\n}\nt := &amp;T{ 7, -2.35, \"abc\\tdef\" }\nfmt.Printf(\"%v\\n\", t)\nfmt.Printf(\"%+v\\n\", t)\nfmt.Printf(\"%#v\\n\", t)\nfmt.Printf(\"%#v\\n\", timeZone)\n</pre..."
        },
        {
          "language": "",
          "code": "&{7 -2.35 abc   def}\n&{a:7 b:-2.35 c:abc     def}\n&main.T{a:7, b:-2.35, c:\"abc\\tdef\"}\nmap[string]int{\"CST\":-21600, \"EST\":-18000, \"MST\":-25200, \"PST\":-28800, \"UTC\":0}",
          "element": "<pre>\n&amp;{7 -2.35 abc   def}\n&amp;{a:7 b:-2.35 c:abc     def}\n&amp;main.T{a:7, b:-2.35, c:\"abc\\tdef\"}\nmap[string]int{\"CST\":-21600, \"EST\":-18000, \"MST\":-25200, \"PST\":-28800, \"UTC\":0}\n</pre>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"%T\\n\", timeZone)",
          "element": "<pre>\nfmt.Printf(\"%T\\n\", timeZone)\n</pre>"
        },
        {
          "language": "",
          "code": "map[string]int",
          "element": "<pre>\nmap[string]int\n</pre>"
        },
        {
          "language": "",
          "code": "String() string",
          "element": "<code>String() string</code>"
        },
        {
          "language": "",
          "code": "func (t *T) String() string {\n    return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c)\n}\nfmt.Printf(\"%v\\n\", t)",
          "element": "<pre>\nfunc (t *T) String() string {\n    return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c)\n}\nfmt.Printf(\"%v\\n\", t)\n</pre>"
        },
        {
          "language": "",
          "code": "7/-2.35/\"abc\\tdef\"",
          "element": "<pre>\n7/-2.35/\"abc\\tdef\"\n</pre>"
        },
        {
          "language": "",
          "code": "type MyString string\n\nfunc (m MyString) String() string {\n    return fmt.Sprintf(\"MyString=%s\", m) // Error: will recur forever.\n}",
          "element": "<pre>\ntype MyString string\n\nfunc (m MyString) String() string {\n    return fmt.Sprintf(\"MyString=%s\", m) // Error: will recur forever.\n}\n</pre>"
        },
        {
          "language": "",
          "code": "type MyString string\nfunc (m MyString) String() string {\n    return fmt.Sprintf(\"MyString=%s\", string(m)) // OK: note conversion.\n}",
          "element": "<pre>\ntype MyString string\nfunc (m MyString) String() string {\n    return fmt.Sprintf(\"MyString=%s\", string(m)) // OK: note conversion.\n}\n</pre>"
        },
        {
          "language": "",
          "code": "...interface{}",
          "element": "<code>...interface{}</code>"
        },
        {
          "language": "",
          "code": "func Printf(format string, v ...interface{}) (n int, err error) {",
          "element": "<pre>\nfunc Printf(format string, v ...interface{}) (n int, err error) {\n</pre>"
        },
        {
          "language": "",
          "code": "[]interface{}",
          "element": "<code>[]interface{}</code>"
        },
        {
          "language": "",
          "code": "log.Println",
          "element": "<code>log.Println</code>"
        },
        {
          "language": "",
          "code": "fmt.Sprintln",
          "element": "<code>fmt.Sprintln</code>"
        },
        {
          "language": "",
          "code": "// Println prints to the standard logger in the manner of fmt.Println.\nfunc Println(v ...interface{}) {\n    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)\n}",
          "element": "<pre>\n// Println prints to the standard logger in the manner of fmt.Println.\nfunc Println(v ...interface{}) {\n    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func Min(a ...int) int {\n    min := int(^uint(0) >> 1)  // largest int\n    for _, i := range a {\n        if i < min {\n            min = i\n        }\n    }\n    return min\n}",
          "element": "<pre>\nfunc Min(a ...int) int {\n    min := int(^uint(0) &gt;&gt; 1)  // largest int\n    for _, i := range a {\n        if i &lt; min {\n            min = i\n        }\n    }\n    return min\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func append(slice []T, elements ...T) []T",
          "element": "<pre>\nfunc append(slice []<i>T</i>, elements ...<i>T</i>) []<i>T</i>\n</pre>"
        },
        {
          "language": "",
          "code": "x := []int{1,2,3}\nx = append(x, 4, 5, 6)\nfmt.Println(x)",
          "element": "<pre>\nx := []int{1,2,3}\nx = append(x, 4, 5, 6)\nfmt.Println(x)\n</pre>"
        },
        {
          "language": "",
          "code": "[1 2 3 4 5 6]",
          "element": "<code>[1 2 3 4 5 6]</code>"
        },
        {
          "language": "",
          "code": "x := []int{1,2,3}\ny := []int{4,5,6}\nx = append(x, y...)\nfmt.Println(x)",
          "element": "<pre>\nx := []int{1,2,3}\ny := []int{4,5,6}\nx = append(x, y...)\nfmt.Println(x)\n</pre>"
        },
        {
          "language": "",
          "code": "math.Sin(math.Pi/4)",
          "element": "<code>math.Sin(math.Pi/4)</code>"
        },
        {
          "language": "",
          "code": "type ByteSize float64\n\nconst (\n    _           = iota// ignore first value by assigning to blank identifierKB ByteSize = 1 << (10 * iota)\n    MB\n    GB\n    TB\n    PB\n    EB\n    ZB\n    YB\n)",
          "element": "<pre>type ByteSize float64\n\nconst (\n    _           = iota <span class=\"comment\">// ignore first value by assigning to blank identifier</span>\n    KB ByteSize = 1 &lt;&lt; (10 * iota)\n    MB\n    GB\n  ..."
        },
        {
          "language": "",
          "code": "func (b ByteSize) String() string {\n    switch {\n    case b >= YB:\n        return fmt.Sprintf(\"%.2fYB\", b/YB)\n    case b >= ZB:\n        return fmt.Sprintf(\"%.2fZB\", b/ZB)\n    case b >= EB:\n        return fmt.Sprintf(\"%.2fEB\", b/EB)\n    case b >= PB:\n        return fmt.Sprintf(\"%.2fPB\", b/PB)\n    case b >= TB:\n        return fmt.Sprintf(\"%.2fTB\", b/TB)\n    case b >= GB:\n        return fmt.Sprintf(\"%.2fGB\", b/GB)\n    case b >= MB:\n        return fmt.Sprintf(\"%.2fMB\", b/MB)\n    case b >= KB:\n        return fmt.Sprintf(\"%.2fKB\", b/KB)\n    }\n    return fmt.Sprintf(\"%.2fB\", b)\n}",
          "element": "<pre>func (b ByteSize) String() string {\n    switch {\n    case b &gt;= YB:\n        return fmt.Sprintf(\"%.2fYB\", b/YB)\n    case b &gt;= ZB:\n        return fmt.Sprintf(\"%.2fZB\", b/ZB)\n    case b &gt;= E..."
        },
        {
          "language": "",
          "code": "ByteSize(1e13)",
          "element": "<code>ByteSize(1e13)</code>"
        },
        {
          "language": "",
          "code": "var (\n    home   = os.Getenv(\"HOME\")\n    user   = os.Getenv(\"USER\")\n    gopath = os.Getenv(\"GOPATH\")\n)",
          "element": "<pre>\nvar (\n    home   = os.Getenv(\"HOME\")\n    user   = os.Getenv(\"USER\")\n    gopath = os.Getenv(\"GOPATH\")\n)\n</pre>"
        },
        {
          "language": "",
          "code": "func init() {\n    if user == \"\" {\n        log.Fatal(\"$USER not set\")\n    }\n    if home == \"\" {\n        home = \"/home/\" + user\n    }\n    if gopath == \"\" {\n        gopath = home + \"/go\"\n    }\n    // gopath may be overridden by --gopath flag on command line.\n    flag.StringVar(&gopath, \"gopath\", gopath, \"override default GOPATH\")\n}",
          "element": "<pre>\nfunc init() {\n    if user == \"\" {\n        log.Fatal(\"$USER not set\")\n    }\n    if home == \"\" {\n        home = \"/home/\" + user\n    }\n    if gopath == \"\" {\n        gopath = home + \"/go\"\n    }\n    ..."
        },
        {
          "language": "",
          "code": "type ByteSlice []byte\n\nfunc (slice ByteSlice) Append(data []byte) []byte {\n    // Body exactly the same as the Append function defined above.\n}",
          "element": "<pre>\ntype ByteSlice []byte\n\nfunc (slice ByteSlice) Append(data []byte) []byte {\n    // Body exactly the same as the Append function defined above.\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func (p *ByteSlice) Append(data []byte) {\n    slice := *p\n    // Body as above, without the return.\n    *p = slice\n}",
          "element": "<pre>\nfunc (p *ByteSlice) Append(data []byte) {\n    slice := *p\n    // Body as above, without the return.\n    *p = slice\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func (p *ByteSlice) Write(data []byte) (n int, err error) {\n    slice := *p\n    // Again as above.\n    *p = slice\n    return len(data), nil\n}",
          "element": "<pre>\nfunc (p *ByteSlice) Write(data []byte) (n int, err error) {\n    slice := *p\n    // Again as above.\n    *p = slice\n    return len(data), nil\n}\n</pre>"
        },
        {
          "language": "",
          "code": "var b ByteSlice\n    fmt.Fprintf(&b, \"This hour has %d days\\n\", 7)",
          "element": "<pre>\n    var b ByteSlice\n    fmt.Fprintf(&amp;b, \"This hour has %d days\\n\", 7)\n</pre>"
        },
        {
          "language": "",
          "code": "bytes.Buffer",
          "element": "<code>bytes.Buffer</code>"
        },
        {
          "language": "",
          "code": "sort.Interface",
          "element": "<code>sort.Interface</code>"
        },
        {
          "language": "",
          "code": "Less(i, j int) bool",
          "element": "<code>Less(i, j int) bool</code>"
        },
        {
          "language": "",
          "code": "Swap(i, j int)",
          "element": "<code>Swap(i, j int)</code>"
        },
        {
          "language": "",
          "code": "type Sequence []int// Methods required by sort.Interface.func (s Sequence) Len() int {\n    return len(s)\n}\nfunc (s Sequence) Less(i, j int) bool {\n    return s[i] < s[j]\n}\nfunc (s Sequence) Swap(i, j int) {\n    s[i], s[j] = s[j], s[i]\n}// Copy returns a copy of the Sequence.func (s Sequence) Copy() Sequence {\n    copy := make(Sequence, 0, len(s))\n    return append(copy, s...)\n}// Method for printing - sorts the elements before printing.func (s Sequence) String() string {\n    s = s.Copy()// Make a copy; don't overwrite argument.sort.Sort(s)\n    str := \"[\"\n    for i, elem := range s {// Loop is O(N); will fix that in next example.if i > 0 {\n            str += \" \"\n        }\n        str += fmt.Sprint(elem)\n    }\n    return str + \"]\"\n}",
          "element": "<pre>type Sequence []int\n\n<span class=\"comment\">// Methods required by sort.Interface.</span>\nfunc (s Sequence) Len() int {\n    return len(s)\n}\nfunc (s Sequence) Less(i, j int) bool {\n    return s[i] ..."
        },
        {
          "language": "",
          "code": "func (s Sequence) String() string {\n    s = s.Copy()\n    sort.Sort(s)\n    return fmt.Sprint([]int(s))\n}",
          "element": "<pre>\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.Sort(s)\n    return fmt.Sprint([]int(s))\n}\n</pre>"
        },
        {
          "language": "",
          "code": "sort.IntSlice",
          "element": "<code>sort.IntSlice</code>"
        },
        {
          "language": "",
          "code": "type Sequence []int\n\n// Method for printing - sorts the elements before printing\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.IntSlice(s).Sort()\n    return fmt.Sprint([]int(s))\n}",
          "element": "<pre>\ntype Sequence []int\n\n// Method for printing - sorts the elements before printing\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.IntSlice(s).Sort()\n    return fmt.Sprint([]int(s))\n..."
        },
        {
          "language": "",
          "code": "sort.IntSlice",
          "element": "<code>sort.IntSlice</code>"
        },
        {
          "language": "",
          "code": "type Stringer interface {\n    String() string\n}\n\nvar value interface{} // Value provided by caller.\nswitch str := value.(type) {\ncase string:\n    return str\ncase Stringer:\n    return str.String()\n}",
          "element": "<pre>\ntype Stringer interface {\n    String() string\n}\n\nvar value interface{} // Value provided by caller.\nswitch str := value.(type) {\ncase string:\n    return str\ncase Stringer:\n    return str.String(..."
        },
        {
          "language": "",
          "code": "value.(typeName)",
          "element": "<pre>\nvalue.(typeName)\n</pre>"
        },
        {
          "language": "",
          "code": "str := value.(string)",
          "element": "<pre>\nstr := value.(string)\n</pre>"
        },
        {
          "language": "",
          "code": "str, ok := value.(string)\nif ok {\n    fmt.Printf(\"string value is: %q\\n\", str)\n} else {\n    fmt.Printf(\"value is not a string\\n\")\n}",
          "element": "<pre>\nstr, ok := value.(string)\nif ok {\n    fmt.Printf(\"string value is: %q\\n\", str)\n} else {\n    fmt.Printf(\"value is not a string\\n\")\n}\n</pre>"
        },
        {
          "language": "",
          "code": "if str, ok := value.(string); ok {\n    return str\n} else if str, ok := value.(Stringer); ok {\n    return str.String()\n}",
          "element": "<pre>\nif str, ok := value.(string); ok {\n    return str\n} else if str, ok := value.(Stringer); ok {\n    return str.String()\n}\n</pre>"
        },
        {
          "language": "",
          "code": "crc32.NewIEEE",
          "element": "<code>crc32.NewIEEE</code>"
        },
        {
          "language": "",
          "code": "adler32.New",
          "element": "<code>adler32.New</code>"
        },
        {
          "language": "",
          "code": "hash.Hash32",
          "element": "<code>hash.Hash32</code>"
        },
        {
          "language": "",
          "code": "crypto/cipher",
          "element": "<code>crypto/cipher</code>"
        },
        {
          "language": "",
          "code": "crypto/cipher",
          "element": "<code>crypto/cipher</code>"
        },
        {
          "language": "",
          "code": "type Block interface {\n    BlockSize() int\n    Encrypt(dst, src []byte)\n    Decrypt(dst, src []byte)\n}\n\ntype Stream interface {\n    XORKeyStream(dst, src []byte)\n}",
          "element": "<pre>\ntype Block interface {\n    BlockSize() int\n    Encrypt(dst, src []byte)\n    Decrypt(dst, src []byte)\n}\n\ntype Stream interface {\n    XORKeyStream(dst, src []byte)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "// NewCTR returns a Stream that encrypts/decrypts using the given Block in\n// counter mode. The length of iv must be the same as the Block's block size.\nfunc NewCTR(block Block, iv []byte) Stream",
          "element": "<pre>\n// NewCTR returns a Stream that encrypts/decrypts using the given Block in\n// counter mode. The length of iv must be the same as the Block's block size.\nfunc NewCTR(block Block, iv []byte) Strea..."
        },
        {
          "language": "",
          "code": "type Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}",
          "element": "<pre>\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "ResponseWriter",
          "element": "<code>ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "http.ResponseWriter",
          "element": "<code>http.ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "// Simple counter server.\ntype Counter struct {\n    n int\n}\n\nfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    ctr.n++\n    fmt.Fprintf(w, \"counter = %d\\n\", ctr.n)\n}",
          "element": "<pre>\n// Simple counter server.\ntype Counter struct {\n    n int\n}\n\nfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    ctr.n++\n    fmt.Fprintf(w, \"counter = %d\\n\", ctr.n)\n}\n<..."
        },
        {
          "language": "",
          "code": "http.ResponseWriter",
          "element": "<code>http.ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "import \"net/http\"\n...\nctr := new(Counter)\nhttp.Handle(\"/counter\", ctr)",
          "element": "<pre>\nimport \"net/http\"\n...\nctr := new(Counter)\nhttp.Handle(\"/counter\", ctr)\n</pre>"
        },
        {
          "language": "",
          "code": "// Simpler counter server.\ntype Counter int\n\nfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    *ctr++\n    fmt.Fprintf(w, \"counter = %d\\n\", *ctr)\n}",
          "element": "<pre>\n// Simpler counter server.\ntype Counter int\n\nfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    *ctr++\n    fmt.Fprintf(w, \"counter = %d\\n\", *ctr)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "// A channel that sends a notification on each visit.\n// (Probably want the channel to be buffered.)\ntype Chan chan *http.Request\n\nfunc (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    ch <- req\n    fmt.Fprint(w, \"notification sent\")\n}",
          "element": "<pre>\n// A channel that sends a notification on each visit.\n// (Probably want the channel to be buffered.)\ntype Chan chan *http.Request\n\nfunc (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Reque..."
        },
        {
          "language": "",
          "code": "func ArgServer() {\n    fmt.Println(os.Args)\n}",
          "element": "<pre>\nfunc ArgServer() {\n    fmt.Println(os.Args)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "// The HandlerFunc type is an adapter to allow the use of\n// ordinary functions as HTTP handlers.  If f is a function\n// with the appropriate signature, HandlerFunc(f) is a\n// Handler object that calls f.\ntype HandlerFunc func(ResponseWriter, *Request)\n\n// ServeHTTP calls f(w, req).\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {\n    f(w, req)\n}",
          "element": "<pre>\n// The HandlerFunc type is an adapter to allow the use of\n// ordinary functions as HTTP handlers.  If f is a function\n// with the appropriate signature, HandlerFunc(f) is a\n// Handler object tha..."
        },
        {
          "language": "",
          "code": "HandlerFunc",
          "element": "<code>HandlerFunc</code>"
        },
        {
          "language": "",
          "code": "// Argument server.\nfunc ArgServer(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(w, os.Args)\n}",
          "element": "<pre>\n// Argument server.\nfunc ArgServer(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(w, os.Args)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "HandlerFunc",
          "element": "<code>HandlerFunc</code>"
        },
        {
          "language": "",
          "code": "IntSlice.Sort",
          "element": "<code>IntSlice.Sort</code>"
        },
        {
          "language": "",
          "code": "http.Handle(\"/args\", http.HandlerFunc(ArgServer))",
          "element": "<pre>\nhttp.Handle(\"/args\", http.HandlerFunc(ArgServer))\n</pre>"
        },
        {
          "language": "",
          "code": "HandlerFunc",
          "element": "<code>HandlerFunc</code>"
        },
        {
          "language": "",
          "code": "HandlerFunc.ServeHTTP",
          "element": "<code>HandlerFunc.ServeHTTP</code>"
        },
        {
          "language": "",
          "code": "if _, err := os.Stat(path); os.IsNotExist(err) {\n    fmt.Printf(\"%s does not exist\\n\", path)\n}",
          "element": "<pre>\nif _, err := os.Stat(path); os.IsNotExist(err) {\n    fmt.Printf(\"%s does not exist\\n\", path)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "// Bad! This code will crash if path does not exist.\nfi, _ := os.Stat(path)\nif fi.IsDir() {\n    fmt.Printf(\"%s is a directory\\n\", path)\n}",
          "element": "<pre>\n// Bad! This code will crash if path does not exist.\nfi, _ := os.Stat(path)\nif fi.IsDir() {\n    fmt.Printf(\"%s is a directory\\n\", path)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    fd, err := os.Open(\"test.go\")\n    if err != nil {\n        log.Fatal(err)\n    }// TODO: use fd.}",
          "element": "<pre>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    fd, err := os.Open(\"test.go\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    <span class=\"comment\">// TODO:..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nvar _ = fmt.Printf// For debugging; delete when done.var _ io.Reader// For debugging; delete when done.func main() {\n    fd, err := os.Open(\"test.go\")\n    if err != nil {\n        log.Fatal(err)\n    }// TODO: use fd._ = fd\n}",
          "element": "<pre>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nvar _ = fmt.Printf <span class=\"comment\">// For debugging; delete when done.</span>\nvar _ io.Reader    <span class=\"comment\">// For..."
        },
        {
          "language": "",
          "code": "net/http/pprof",
          "element": "<code><a href=\"/pkg/net/http/pprof/\">net/http/pprof</a></code>"
        },
        {
          "language": "",
          "code": "import _ \"net/http/pprof\"",
          "element": "<pre>\nimport _ \"net/http/pprof\"\n</pre>"
        },
        {
          "language": "",
          "code": "encoding/json",
          "element": "<code><a href=\"/pkg/encoding/json/\">encoding/json</a></code>"
        },
        {
          "language": "",
          "code": "m, ok := val.(json.Marshaler)",
          "element": "<pre>\nm, ok := val.(json.Marshaler)\n</pre>"
        },
        {
          "language": "",
          "code": "if _, ok := val.(json.Marshaler); ok {\n    fmt.Printf(\"value %v of type %T implements json.Marshaler\\n\", val, val)\n}",
          "element": "<pre>\nif _, ok := val.(json.Marshaler); ok {\n    fmt.Printf(\"value %v of type %T implements json.Marshaler\\n\", val, val)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "json.RawMessage",
          "element": "<code><a href=\"/pkg/encoding/json/#RawMessage\">json.RawMessage</a></code>"
        },
        {
          "language": "",
          "code": "json.Marshaler",
          "element": "<code>json.Marshaler</code>"
        },
        {
          "language": "",
          "code": "var _ json.Marshaler = (*RawMessage)(nil)",
          "element": "<pre>\nvar _ json.Marshaler = (*RawMessage)(nil)\n</pre>"
        },
        {
          "language": "",
          "code": "*RawMessage",
          "element": "<code>*RawMessage</code>"
        },
        {
          "language": "",
          "code": "*RawMessage",
          "element": "<code>*RawMessage</code>"
        },
        {
          "language": "",
          "code": "json.Marshaler",
          "element": "<code>json.Marshaler</code>"
        },
        {
          "language": "",
          "code": "type Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}",
          "element": "<pre>\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "io.ReadWriter",
          "element": "<code>io.ReadWriter</code>"
        },
        {
          "language": "",
          "code": "io.ReadWriter",
          "element": "<code>io.ReadWriter</code>"
        },
        {
          "language": "",
          "code": "// ReadWriter is the interface that combines the Reader and Writer interfaces.\ntype ReadWriter interface {\n    Reader\n    Writer\n}",
          "element": "<pre>\n// ReadWriter is the interface that combines the Reader and Writer interfaces.\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n</pre>"
        },
        {
          "language": "",
          "code": "bufio.Reader",
          "element": "<code>bufio.Reader</code>"
        },
        {
          "language": "",
          "code": "bufio.Writer",
          "element": "<code>bufio.Writer</code>"
        },
        {
          "language": "",
          "code": "// ReadWriter stores pointers to a Reader and a Writer.\n// It implements io.ReadWriter.\ntype ReadWriter struct {\n    *Reader  // *bufio.Reader\n    *Writer  // *bufio.Writer\n}",
          "element": "<pre>\n// ReadWriter stores pointers to a Reader and a Writer.\n// It implements io.ReadWriter.\ntype ReadWriter struct {\n    *Reader  // *bufio.Reader\n    *Writer  // *bufio.Writer\n}\n</pre>"
        },
        {
          "language": "",
          "code": "type ReadWriter struct {\n    reader *Reader\n    writer *Writer\n}",
          "element": "<pre>\ntype ReadWriter struct {\n    reader *Reader\n    writer *Writer\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func (rw *ReadWriter) Read(p []byte) (n int, err error) {\n    return rw.reader.Read(p)\n}",
          "element": "<pre>\nfunc (rw *ReadWriter) Read(p []byte) (n int, err error) {\n    return rw.reader.Read(p)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "bufio.ReadWriter",
          "element": "<code>bufio.ReadWriter</code>"
        },
        {
          "language": "",
          "code": "bufio.Reader",
          "element": "<code>bufio.Reader</code>"
        },
        {
          "language": "",
          "code": "bufio.Writer",
          "element": "<code>bufio.Writer</code>"
        },
        {
          "language": "",
          "code": "io.ReadWriter",
          "element": "<code>io.ReadWriter</code>"
        },
        {
          "language": "",
          "code": "bufio.ReadWriter",
          "element": "<code>bufio.ReadWriter</code>"
        },
        {
          "language": "",
          "code": "type Job struct {\n    Command string\n    *log.Logger\n}",
          "element": "<pre>\ntype Job struct {\n    Command string\n    *log.Logger\n}\n</pre>"
        },
        {
          "language": "",
          "code": "*log.Logger",
          "element": "<code>*log.Logger</code>"
        },
        {
          "language": "",
          "code": "job.Println(\"starting now...\")",
          "element": "<pre>\njob.Println(\"starting now...\")\n</pre>"
        },
        {
          "language": "",
          "code": "func NewJob(command string, logger *log.Logger) *Job {\n    return &Job{command, logger}\n}",
          "element": "<pre>\nfunc NewJob(command string, logger *log.Logger) *Job {\n    return &amp;Job{command, logger}\n}\n</pre>"
        },
        {
          "language": "",
          "code": "job := &Job{command, log.New(os.Stderr, \"Job: \", log.Ldate)}",
          "element": "<pre>\njob := &amp;Job{command, log.New(os.Stderr, \"Job: \", log.Ldate)}\n</pre>"
        },
        {
          "language": "",
          "code": "*log.Logger",
          "element": "<code>*log.Logger</code>"
        },
        {
          "language": "",
          "code": "func (job *Job) Printf(format string, args ...interface{}) {\n    job.Logger.Printf(\"%q: %s\", job.Command, fmt.Sprintf(format, args...))\n}",
          "element": "<pre>\nfunc (job *Job) Printf(format string, args ...interface{}) {\n    job.Logger.Printf(\"%q: %s\", job.Command, fmt.Sprintf(format, args...))\n}\n</pre>"
        },
        {
          "language": "",
          "code": "go list.Sort()  // run list.Sort concurrently; don't wait for it.",
          "element": "<pre>\ngo list.Sort()  // run list.Sort concurrently; don't wait for it.\n</pre>"
        },
        {
          "language": "",
          "code": "func Announce(message string, delay time.Duration) {\n    go func() {\n        time.Sleep(delay)\n        fmt.Println(message)\n    }()  // Note the parentheses - must call the function.\n}",
          "element": "<pre>\nfunc Announce(message string, delay time.Duration) {\n    go func() {\n        time.Sleep(delay)\n        fmt.Println(message)\n    }()  // Note the parentheses - must call the function.\n}\n</pre>"
        },
        {
          "language": "",
          "code": "ci := make(chan int)            // unbuffered channel of integers\ncj := make(chan int, 0)         // unbuffered channel of integers\ncs := make(chan *os.File, 100)  // buffered channel of pointers to Files",
          "element": "<pre>\nci := make(chan int)            // unbuffered channel of integers\ncj := make(chan int, 0)         // unbuffered channel of integers\ncs := make(chan *os.File, 100)  // buffered channel of pointer..."
        },
        {
          "language": "",
          "code": "c := make(chan int)  // Allocate a channel.\n// Start the sort in a goroutine; when it completes, signal on the channel.\ngo func() {\n    list.Sort()\n    c <- 1  // Send a signal; value does not matter.\n}()\ndoSomethingForAWhile()\n<-c   // Wait for sort to finish; discard sent value.",
          "element": "<pre>\nc := make(chan int)  // Allocate a channel.\n// Start the sort in a goroutine; when it completes, signal on the channel.\ngo func() {\n    list.Sort()\n    c &lt;- 1  // Send a signal; value does no..."
        },
        {
          "language": "",
          "code": "var sem = make(chan int, MaxOutstanding)\n\nfunc handle(r *Request) {\n    sem <- 1    // Wait for active queue to drain.\n    process(r)  // May take a long time.\n    <-sem       // Done; enable next request to run.\n}\n\nfunc Serve(queue chan *Request) {\n    for {\n        req := <-queue\n        go handle(req)  // Don't wait for handle to finish.\n    }\n}",
          "element": "<pre>\nvar sem = make(chan int, MaxOutstanding)\n\nfunc handle(r *Request) {\n    sem &lt;- 1    // Wait for active queue to drain.\n    process(r)  // May take a long time.\n    &lt;-sem       // Done; ena..."
        },
        {
          "language": "",
          "code": "MaxOutstanding",
          "element": "<code>MaxOutstanding</code>"
        },
        {
          "language": "",
          "code": "MaxOutstanding",
          "element": "<code>MaxOutstanding</code>"
        },
        {
          "language": "",
          "code": "func Serve(queue chan *Request) {\n    for req := range queue {\n        sem <- 1\n        go func() {\n            process(req)\n            <-sem\n        }()\n    }\n}",
          "element": "<pre>\nfunc Serve(queue chan *Request) {\n    for req := range queue {\n        sem &lt;- 1\n        go func() {\n            process(req)\n            &lt;-sem\n        }()\n    }\n}</pre>"
        },
        {
          "language": "",
          "code": "func handle(queue chan *Request) {\n    for r := range queue {\n        process(r)\n    }\n}\n\nfunc Serve(clientRequests chan *Request, quit chan bool) {\n    // Start handlers\n    for i := 0; i < MaxOutstanding; i++ {\n        go handle(clientRequests)\n    }\n    <-quit  // Wait to be told to exit.\n}",
          "element": "<pre>\nfunc handle(queue chan *Request) {\n    for r := range queue {\n        process(r)\n    }\n}\n\nfunc Serve(clientRequests chan *Request, quit chan bool) {\n    // Start handlers\n    for i := 0; i &lt; ..."
        },
        {
          "language": "",
          "code": "type Request struct {\n    args        []int\n    f           func([]int) int\n    resultChan  chan int\n}",
          "element": "<pre>\ntype Request struct {\n    args        []int\n    f           func([]int) int\n    resultChan  chan int\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func sum(a []int) (s int) {\n    for _, v := range a {\n        s += v\n    }\n    return\n}\n\nrequest := &Request{[]int{3, 4, 5}, sum, make(chan int)}\n// Send request\nclientRequests <- request\n// Wait for response.\nfmt.Printf(\"answer: %d\\n\", <-request.resultChan)",
          "element": "<pre>\nfunc sum(a []int) (s int) {\n    for _, v := range a {\n        s += v\n    }\n    return\n}\n\nrequest := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}\n// Send request\nclientRequests &lt;- request..."
        },
        {
          "language": "",
          "code": "func handle(queue chan *Request) {\n    for req := range queue {\n        req.resultChan <- req.f(req.args)\n    }\n}",
          "element": "<pre>\nfunc handle(queue chan *Request) {\n    for req := range queue {\n        req.resultChan &lt;- req.f(req.args)\n    }\n}\n</pre>"
        },
        {
          "language": "",
          "code": "type Vector []float64\n\n// Apply the operation to v[i], v[i+1] ... up to v[n-1].\nfunc (v Vector) DoSome(i, n int, u Vector, c chan int) {\n    for ; i < n; i++ {\n        v[i] += u.Op(v[i])\n    }\n    c <- 1    // signal that this piece is done\n}",
          "element": "<pre>\ntype Vector []float64\n\n// Apply the operation to v[i], v[i+1] ... up to v[n-1].\nfunc (v Vector) DoSome(i, n int, u Vector, c chan int) {\n    for ; i &lt; n; i++ {\n        v[i] += u.Op(v[i])\n    ..."
        },
        {
          "language": "",
          "code": "const numCPU = 4 // number of CPU cores\n\nfunc (v Vector) DoAll(u Vector) {\n    c := make(chan int, numCPU)  // Buffering optional but sensible.\n    for i := 0; i < numCPU; i++ {\n        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)\n    }\n    // Drain the channel.\n    for i := 0; i < numCPU; i++ {\n        <-c    // wait for one task to complete\n    }\n    // All done.\n}",
          "element": "<pre>\nconst numCPU = 4 // number of CPU cores\n\nfunc (v Vector) DoAll(u Vector) {\n    c := make(chan int, numCPU)  // Buffering optional but sensible.\n    for i := 0; i &lt; numCPU; i++ {\n        go v...."
        },
        {
          "language": "",
          "code": "runtime.NumCPU",
          "element": "<code><a href=\"/pkg/runtime#NumCPU\">runtime.NumCPU</a></code>"
        },
        {
          "language": "",
          "code": "var numCPU = runtime.NumCPU()",
          "element": "<pre>\nvar numCPU = runtime.NumCPU()\n</pre>"
        },
        {
          "language": "",
          "code": "runtime.GOMAXPROCS",
          "element": "<code><a href=\"/pkg/runtime#GOMAXPROCS\">runtime.GOMAXPROCS</a></code>"
        },
        {
          "language": "",
          "code": "runtime.NumCPU",
          "element": "<code>runtime.NumCPU</code>"
        },
        {
          "language": "",
          "code": "var numCPU = runtime.GOMAXPROCS(0)",
          "element": "<pre>\nvar numCPU = runtime.GOMAXPROCS(0)\n</pre>"
        },
        {
          "language": "",
          "code": "var freeList = make(chan *Buffer, 100)\nvar serverChan = make(chan *Buffer)\n\nfunc client() {\n    for {\n        var b *Buffer\n        // Grab a buffer if available; allocate if not.\n        select {\n        case b = <-freeList:\n            // Got one; nothing more to do.\n        default:\n            // None free, so allocate a new one.\n            b = new(Buffer)\n        }\n        load(b)              // Read next message from the net.\n        serverChan <- b      // Send to server.\n    }\n}",
          "element": "<pre>\nvar freeList = make(chan *Buffer, 100)\nvar serverChan = make(chan *Buffer)\n\nfunc client() {\n    for {\n        var b *Buffer\n        // Grab a buffer if available; allocate if not.\n        select..."
        },
        {
          "language": "",
          "code": "func server() {\n    for {\n        b := <-serverChan    // Wait for work.\n        process(b)\n        // Reuse buffer if there's room.\n        select {\n        case freeList <- b:\n            // Buffer on free list; nothing more to do.\n        default:\n            // Free list full, just carry on.\n        }\n    }\n}",
          "element": "<pre>\nfunc server() {\n    for {\n        b := &lt;-serverChan    // Wait for work.\n        process(b)\n        // Reuse buffer if there's room.\n        select {\n        case freeList &lt;- b:\n          ..."
        },
        {
          "language": "",
          "code": "type error interface {\n    Error() string\n}",
          "element": "<pre>\ntype error interface {\n    Error() string\n}\n</pre>"
        },
        {
          "language": "",
          "code": "os.PathError",
          "element": "<code>os.PathError</code>"
        },
        {
          "language": "",
          "code": "// PathError records an error and the operation and\n// file path that caused it.\ntype PathError struct {\n    Op string    // \"open\", \"unlink\", etc.\n    Path string  // The associated file.\n    Err error    // Returned by the system call.\n}\n\nfunc (e *PathError) Error() string {\n    return e.Op + \" \" + e.Path + \": \" + e.Err.Error()\n}",
          "element": "<pre>\n// PathError records an error and the operation and\n// file path that caused it.\ntype PathError struct {\n    Op string    // \"open\", \"unlink\", etc.\n    Path string  // The associated file.\n    E..."
        },
        {
          "language": "",
          "code": "open /etc/passwx: no such file or directory",
          "element": "<pre>\nopen /etc/passwx: no such file or directory\n</pre>"
        },
        {
          "language": "",
          "code": "for try := 0; try < 2; try++ {\n    file, err = os.Create(filename)\n    if err == nil {\n        return\n    }\n    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {\n        deleteTempFiles()  // Recover some space.\n        continue\n    }\n    return\n}",
          "element": "<pre>\nfor try := 0; try &lt; 2; try++ {\n    file, err = os.Create(filename)\n    if err == nil {\n        return\n    }\n    if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {\n      ..."
        },
        {
          "language": "",
          "code": "*os.PathError",
          "element": "<code>*os.PathError</code>"
        },
        {
          "language": "",
          "code": "// A toy implementation of cube root using Newton's method.\nfunc CubeRoot(x float64) float64 {\n    z := x/3   // Arbitrary initial value\n    for i := 0; i < 1e6; i++ {\n        prevz := z\n        z -= (z*z*z-x) / (3*z*z)\n        if veryClose(z, prevz) {\n            return z\n        }\n    }\n    // A million iterations has not converged; something is wrong.\n    panic(fmt.Sprintf(\"CubeRoot(%g) did not converge\", x))\n}",
          "element": "<pre>\n// A toy implementation of cube root using Newton's method.\nfunc CubeRoot(x float64) float64 {\n    z := x/3   // Arbitrary initial value\n    for i := 0; i &lt; 1e6; i++ {\n        prevz := z\n    ..."
        },
        {
          "language": "",
          "code": "var user = os.Getenv(\"USER\")\n\nfunc init() {\n    if user == \"\" {\n        panic(\"no value for $USER\")\n    }\n}",
          "element": "<pre>\nvar user = os.Getenv(\"USER\")\n\nfunc init() {\n    if user == \"\" {\n        panic(\"no value for $USER\")\n    }\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func server(workChan <-chan *Work) {\n    for work := range workChan {\n        go safelyDo(work)\n    }\n}\n\nfunc safelyDo(work *Work) {\n    defer func() {\n        if err := recover(); err != nil {\n            log.Println(\"work failed:\", err)\n        }\n    }()\n    do(work)\n}",
          "element": "<pre>\nfunc server(workChan &lt;-chan *Work) {\n    for work := range workChan {\n        go safelyDo(work)\n    }\n}\n\nfunc safelyDo(work *Work) {\n    defer func() {\n        if err := recover(); err != nil..."
        },
        {
          "language": "",
          "code": "// Error is the type of a parse error; it satisfies the error interface.\ntype Error string\nfunc (e Error) Error() string {\n    return string(e)\n}\n\n// error is a method of *Regexp that reports parsing errors by\n// panicking with an Error.\nfunc (regexp *Regexp) error(err string) {\n    panic(Error(err))\n}\n\n// Compile returns a parsed representation of the regular expression.\nfunc Compile(str string) (regexp *Regexp, err error) {\n    regexp = new(Regexp)\n    // doParse will panic if there is a parse error.\n    defer func() {\n        if e := recover(); e != nil {\n            regexp = nil    // Clear return value.\n            err = e.(Error) // Will re-panic if not a parse error.\n        }\n    }()\n    return regexp.doParse(str), nil\n}",
          "element": "<pre>\n// Error is the type of a parse error; it satisfies the error interface.\ntype Error string\nfunc (e Error) Error() string {\n    return string(e)\n}\n\n// error is a method of *Regexp that reports pa..."
        },
        {
          "language": "",
          "code": "if pos == 0 {\n    re.error(\"'*' illegal at start of expression\")\n}",
          "element": "<pre>\nif pos == 0 {\n    re.error(\"'*' illegal at start of expression\")\n}\n</pre>"
        },
        {
          "language": "",
          "code": "chart.apis.google.com",
          "element": "<code>chart.apis.google.com</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"flag\"\n    \"html/template\"\n    \"log\"\n    \"net/http\"\n)\n\nvar addr = flag.String(\"addr\", \":1718\", \"http service address\")// Q=17, R=18var templ = template.Must(template.New(\"qr\").Parse(templateStr))\n\nfunc main() {\n    flag.Parse()\n    http.Handle(\"/\", http.HandlerFunc(QR))\n    err := http.ListenAndServe(*addr, nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe:\", err)\n    }\n}\n\nfunc QR(w http.ResponseWriter, req *http.Request) {\n    templ.Execute(w, req.FormValue(\"s\"))\n}\n\nconst templateStr = `\n<html>\n<head>\n<title>QR Link Generator</title>\n</head>\n<body>\n{{if .}}\n<img src=\"http://chart.apis.google.com/chart?chs=300x300&cht=qr&choe=UTF-8&chl={{.}}\" />\n<br>\n{{.}}\n<br>\n<br>\n{{end}}\n<form action=\"/\" name=f method=\"GET\">\n    <input maxLength=1024 size=70 name=s value=\"\" title=\"Text to QR Encode\">\n    <input type=submit value=\"Show QR\" name=qr>\n</form>\n</body>\n</html>\n`",
          "element": "<pre>package main\n\nimport (\n    \"flag\"\n    \"html/template\"\n    \"log\"\n    \"net/http\"\n)\n\nvar addr = flag.String(\"addr\", \":1718\", \"http service address\") <span class=\"comment\">// Q=17, R=18</span>\n\nvar t..."
        },
        {
          "language": "",
          "code": "http.ListenAndServe",
          "element": "<code>http.ListenAndServe</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "templ.Execute",
          "element": "<code>templ.Execute</code>"
        },
        {
          "language": "",
          "code": "templateStr",
          "element": "<code>templateStr</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Effective Go",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 2,
          "text": "Formatting",
          "id": "formatting"
        },
        {
          "level": 2,
          "text": "Commentary",
          "id": "commentary"
        },
        {
          "level": 2,
          "text": "Names",
          "id": "names"
        },
        {
          "level": 2,
          "text": "Semicolons",
          "id": "semicolons"
        },
        {
          "level": 2,
          "text": "Control structures",
          "id": "control-structures"
        },
        {
          "level": 2,
          "text": "Functions",
          "id": "functions"
        },
        {
          "level": 2,
          "text": "Data",
          "id": "data"
        },
        {
          "level": 2,
          "text": "Initialization",
          "id": "initialization"
        },
        {
          "level": 2,
          "text": "Methods",
          "id": "methods"
        },
        {
          "level": 2,
          "text": "Interfaces and other types",
          "id": "interfaces_and_types"
        },
        {
          "level": 2,
          "text": "The blank identifier",
          "id": "blank"
        },
        {
          "level": 2,
          "text": "Embedding",
          "id": "embedding"
        },
        {
          "level": 2,
          "text": "Concurrency",
          "id": "concurrency"
        },
        {
          "level": 2,
          "text": "Errors",
          "id": "errors"
        },
        {
          "level": 2,
          "text": "A web server",
          "id": "web_server"
        },
        {
          "level": 3,
          "text": "Examples",
          "id": "examples"
        },
        {
          "level": 3,
          "text": "Package names",
          "id": "package-names"
        },
        {
          "level": 3,
          "text": "Getters",
          "id": "Getters"
        },
        {
          "level": 3,
          "text": "Interface names",
          "id": "interface-names"
        },
        {
          "level": 3,
          "text": "MixedCaps",
          "id": "mixed-caps"
        },
        {
          "level": 3,
          "text": "If",
          "id": "if"
        },
        {
          "level": 3,
          "text": "Redeclaration and reassignment",
          "id": "redeclaration"
        },
        {
          "level": 3,
          "text": "For",
          "id": "for"
        },
        {
          "level": 3,
          "text": "Switch",
          "id": "switch"
        },
        {
          "level": 3,
          "text": "Type switch",
          "id": "type_switch"
        },
        {
          "level": 3,
          "text": "Multiple return values",
          "id": "multiple-returns"
        },
        {
          "level": 3,
          "text": "Named result parameters",
          "id": "named-results"
        },
        {
          "level": 3,
          "text": "Defer",
          "id": "defer"
        },
        {
          "level": 3,
          "text": "Allocation withnew",
          "id": "allocation_new"
        },
        {
          "level": 3,
          "text": "Constructors and composite literals",
          "id": "composite_literals"
        },
        {
          "level": 3,
          "text": "Allocation withmake",
          "id": "allocation_make"
        },
        {
          "level": 3,
          "text": "Arrays",
          "id": "arrays"
        },
        {
          "level": 3,
          "text": "Slices",
          "id": "slices"
        },
        {
          "level": 3,
          "text": "Two-dimensional slices",
          "id": "two_dimensional_slices"
        },
        {
          "level": 3,
          "text": "Maps",
          "id": "maps"
        },
        {
          "level": 3,
          "text": "Printing",
          "id": "printing"
        },
        {
          "level": 3,
          "text": "Append",
          "id": "append"
        },
        {
          "level": 3,
          "text": "Constants",
          "id": "constants"
        },
        {
          "level": 3,
          "text": "Variables",
          "id": "variables"
        },
        {
          "level": 3,
          "text": "The init function",
          "id": "init"
        },
        {
          "level": 3,
          "text": "Pointers vs. Values",
          "id": "pointers_vs_values"
        },
        {
          "level": 3,
          "text": "Interfaces",
          "id": "interfaces"
        },
        {
          "level": 3,
          "text": "Conversions",
          "id": "conversions"
        },
        {
          "level": 3,
          "text": "Interface conversions and type assertions",
          "id": "interface_conversions"
        },
        {
          "level": 3,
          "text": "Generality",
          "id": "generality"
        },
        {
          "level": 3,
          "text": "Interfaces and methods",
          "id": "interface_methods"
        },
        {
          "level": 3,
          "text": "The blank identifier in multiple assignment",
          "id": "blank_assign"
        },
        {
          "level": 3,
          "text": "Unused imports and variables",
          "id": "blank_unused"
        },
        {
          "level": 3,
          "text": "Import for side effect",
          "id": "blank_import"
        },
        {
          "level": 3,
          "text": "Interface checks",
          "id": "blank_implements"
        },
        {
          "level": 3,
          "text": "Share by communicating",
          "id": "sharing"
        },
        {
          "level": 3,
          "text": "Goroutines",
          "id": "goroutines"
        },
        {
          "level": 3,
          "text": "Channels",
          "id": "channels"
        },
        {
          "level": 3,
          "text": "Channels of channels",
          "id": "chan_of_chan"
        },
        {
          "level": 3,
          "text": "Parallelization",
          "id": "parallel"
        },
        {
          "level": 3,
          "text": "A leaky buffer",
          "id": "leaky_buffer"
        },
        {
          "level": 3,
          "text": "Panic",
          "id": "panic"
        },
        {
          "level": 3,
          "text": "Recover",
          "id": "recover"
        }
      ],
      "timestamp": 1750757565.332543
    },
    {
      "url": "https://golang.org/doc/install",
      "title": "Download and install - The Go Programming Language",
      "content": "Documentation\nDownload and install\nDownload and install\nDownload and install Go quickly with the steps described here.\nFor other content on installing, you might be interested in:\nManaging Go installations\n-- How to\n    install multiple versions and uninstall.\nInstalling Go from source\n-- How to\n    check out the sources, build them on your own machine, and run them.\nDownload\nGo installation\nSelect the tab for your computer's operating system below, then follow its\n  installation instructions.\nLinux\nMac\nWindows\nRemove any previous Go installation\nby deleting the /usr/local/go folder\n\t\t(if it exists), then extract the archive you just downloaded into /usr/local, creating a fresh\n\t\tGo tree in /usr/local/go:\n$ rm -rf /usr/local/go && tar -C /usr/local -xzf\ngo1.14.3.linux-amd64.tar.gz\n(You may need to run each command separately with the necessary permissions, as root or through\nsudo\n.)\nDo not\nuntar the archive into an existing /usr/local/go tree. This is known to\n\t\t  produce broken Go installations.\nAdd /usr/local/go/bin to the\nPATH\nenvironment variable.\nYou can do this by adding the following line to your $HOME/.profile or\n          /etc/profile (for a system-wide installation):\nexport PATH=$PATH:/usr/local/go/bin\nNote:\nChanges made to a profile file may not apply\n          until the next time you log into your computer. To apply the changes\n          immediately, just run the shell commands directly or execute them from\n          the profile using a command such as\nsource $HOME/.profile\n.\nVerify that you've installed Go by opening a command prompt and typing\n        the following command:\n$ go version\nConfirm that the command prints the installed version of Go.\nOpen the package file you downloaded and follow the prompts to install\n        Go.\nThe package installs the Go distribution to /usr/local/go. The package\n          should put the /usr/local/go/bin directory in your\nPATH\nenvironment variable. You may need to restart any\n          open Terminal sessions for the change to take effect.\nVerify that you've installed Go by opening a command prompt and typing\n        the following command:\n$ go version\nConfirm that the command prints the installed version of Go.\nOpen the MSI file you downloaded and follow the prompts to install Go.\nBy default, the installer will install Go to\nProgram Files\nor\nProgram Files (x86)\n. You can change the\n          location as needed. After installing, you will need to close and\n          reopen any open command prompts so that changes to the environment\n          made by the installer are reflected at the command prompt.\nVerify that you've installed Go.\nIn\nWindows\n, click the\nStart\nmenu.\nIn the menu's search box, type\ncmd\n, then press the\nEnter\nkey.\nIn the Command Prompt window that appears, type the following\n            command:\n$ go version\nConfirm that the command prints the installed version of Go.\nYou're all set!\nVisit the\nGetting Started tutorial\nto write\n  some simple Go code. It takes about 10 minutes to complete.\nReport Issues\nIf you spot bugs, mistakes, or inconsistencies in the Go project's code or documentation, please let us know by filing a ticket on our\nissue tracker.\nOf course, you should check it's not an existing issue before creating a new one.\nFiling a ticket",
      "code_examples": [
        {
          "language": "CopyPaste",
          "code": "$ rm -rf /usr/local/go && tar -C /usr/local -xzfgo1.14.3.linux-amd64.tar.gz",
          "element": "<pre class=\"CopyPaste\">\n      <span>$ rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf <span id=\"linux-filename\">go1.14.3.linux-amd64.tar.gz</span></span>\n      <button aria-label=\"Copy and past..."
        },
        {
          "language": "CopyPaste",
          "code": "export PATH=$PATH:/usr/local/go/bin",
          "element": "<pre class=\"CopyPaste\">\n          <span>export PATH=$PATH:/usr/local/go/bin</span>\n          <button aria-label=\"Copy and paste the code.\">\n            <img class=\"CopyPaste-icon\" src=\"/images/icons/c..."
        },
        {
          "language": "",
          "code": "source $HOME/.profile",
          "element": "<code>source $HOME/.profile</code>"
        },
        {
          "language": "CopyPaste",
          "code": "$ go version",
          "element": "<pre class=\"CopyPaste\">\n          <span>$ go version</span>\n          <button aria-label=\"Copy and paste the code.\">\n            <img class=\"CopyPaste-icon\" src=\"/images/icons/copy-paste.svg\"/>\n      ..."
        },
        {
          "language": "CopyPaste",
          "code": "$ go version",
          "element": "<pre class=\"CopyPaste\">\n          <span>$ go version</span>\n          <button aria-label=\"Copy and paste the code.\">\n            <img class=\"CopyPaste-icon\" src=\"/images/icons/copy-paste.svg\"/>\n      ..."
        },
        {
          "language": "",
          "code": "Program Files",
          "element": "<code>Program Files</code>"
        },
        {
          "language": "",
          "code": "Program Files (x86)",
          "element": "<code>Program Files (x86)</code>"
        },
        {
          "language": "CopyPaste",
          "code": "$ go version",
          "element": "<pre class=\"CopyPaste\">\n              <span>$ go version</span>\n              <button aria-label=\"Copy and paste the code.\">\n                <img class=\"CopyPaste-icon\" src=\"/images/icons/copy-paste.s..."
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Download and install",
          "id": ""
        },
        {
          "level": 2,
          "text": "Go installation",
          "id": "install"
        },
        {
          "level": 2,
          "text": "You're all set!",
          "id": "code"
        },
        {
          "level": 4,
          "text": "Report Issues",
          "id": ""
        }
      ],
      "timestamp": 1750757569.0240169
    },
    {
      "url": "https://golang.org/doc/tutorial/getting-started.html",
      "title": "Tutorial: Get started with Go - The Go Programming Language",
      "content": "Documentation\nTutorials\nTutorial: Get started with Go\nTutorial: Get started with Go\nIn this tutorial, you'll get a brief introduction to Go programming. Along the\n  way, you will:\nInstall Go (if you haven't already).\nWrite some simple \"Hello, world\" code.\nUse the\ngo\ncommand to run your code.\nUse the Go package discovery tool to find packages you can use in your own\n    code.\nCall functions of an external module.\nNote:\nFor other tutorials, see\nTutorials\n.\nPrerequisites\nSome programming experience.\nThe code here is pretty\n    simple, but it helps to know something about functions.\nA tool to edit your code.\nAny text editor you have will\n    work fine. Most text editors have good support for Go. The most popular are\n    VSCode (free), GoLand (paid), and Vim (free).\nA command terminal.\nGo works well using any terminal on\n    Linux and Mac, and on PowerShell or cmd in Windows.\nInstall Go\nJust use the\nDownload and install\nsteps.\nWrite some code\nGet started with Hello, World.\nOpen a command prompt and cd to your home directory.\nOn Linux or Mac:\ncd\nOn Windows:\ncd %HOMEPATH%\nCreate a hello directory for your first Go source code.\nFor example, use the following commands:\nmkdir hello\ncd hello\nEnable dependency tracking for your code.\nWhen your code imports packages contained in other modules, you manage\n      those dependencies through your code's own module. That module is defined\n      by a go.mod file that tracks the modules that provide those packages. That\n      go.mod file stays with your code, including in your source code\n      repository.\nTo enable dependency tracking for your code by creating a go.mod file, run\n      the\ngo mod init\ncommand,\n        giving it the name of the module your code will be in. The name is the\n        module's module path.\nIn actual development, the module path will typically be the repository\n        location where your source code will be kept. For example, the module\n        path might be\ngithub.com/mymodule\n. If you plan to publish\n        your module for others to use, the module path\nmust\nbe a\n        location from which Go tools can download your module. For more about\n        naming a module with a module path, see\nManaging\n            dependencies\n.\nFor the purposes of this tutorial, just use\nexample/hello\n.\n$ go mod init example/hello\ngo: creating new go.mod: module example/hello\nIn your text editor, create a file hello.go in which to write your code.\nPaste the following code into your hello.go file and save the file.\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}\nThis is your Go code. In this code, you:\nDeclare a\nmain\npackage (a package is a way to group\n        functions, and it's made up of all the files in the same directory).\nImport the popular\nfmt\npackage\n,\n        which contains functions for formatting text, including printing to the\n        console. This package is one of the\nstandard library\npackages you got\n        when you installed Go.\nImplement a\nmain\nfunction to print a message to the\n        console. A\nmain\nfunction executes by default when you run\n        the\nmain\npackage.\nRun your code to see the greeting.\n$ go run .\nHello, World!\nThe\ngo run\ncommand\n      is one of many\ngo\ncommands you'll use to get things done with\n      Go. Use the following command to get a list of the others:\n$ go help\nCall code in an external package\nWhen you need your code to do something that might have been implemented by\n  someone else, you can look for a package that has functions you can use in\n  your code.\nMake your printed message a little more interesting with a function from an\n    external module.\nVisit pkg.go.dev and\nsearch for a \"quote\" package\n.\nIn the search results, locate and click on the v1 of the\nrsc.io/quote\npackage\n        (it should be listed with the \"Other major versions\" of\nrsc.io/quote/v4\n).\nIn the\nDocumentation\nsection, under\nIndex\n, note the\n        list of functions you can call from your code. You'll use the\nGo\nfunction.\nAt the top of this page, note that package\nquote\nis\n        included in the\nrsc.io/quote\nmodule.\nYou can use the pkg.go.dev site to find published modules whose packages\n      have functions you can use in your own code. Packages are published in\n      modules -- like\nrsc.io/quote\n-- where others can use them.\n      Modules are improved with new versions over time, and you can upgrade your\n      code to use the improved versions.\nIn your Go code, import the\nrsc.io/quote\npackage and add a call\n    to its\nGo\nfunction.\nAfter adding the highlighted lines, your code should include the\n      following:\npackage main\n\nimport \"fmt\"\nimport \"rsc.io/quote\"\nfunc main() {\nfmt.Println(quote.Go())\n}\nAdd new module requirements and sums.\nGo will add the\nquote\nmodule as a requirement, as well as a\n      go.sum file for use in authenticating the module. For more, see\nAuthenticating modules\nin the Go\n      Modules Reference.\n$ go mod tidy\ngo: finding module for package rsc.io/quote\ngo: found rsc.io/quote in rsc.io/quote v1.5.2\nRun your code to see the message generated by the function you're calling.\n$ go run .\nDon't communicate by sharing memory, share memory by communicating.\nNotice that your code calls the\nGo\nfunction, printing a\n      clever message about communication.\nWhen you ran\ngo mod tidy\n, it located and downloaded the\nrsc.io/quote\nmodule that contains the package you imported.\n      By default, it downloaded the latest version -- v1.5.2.\nWrite more code\nWith this quick introduction, you got Go installed and learned some of the\n  basics. To write some more code with another tutorial, take a look at\nCreate a Go module\n.",
      "code_examples": [
        {
          "language": "",
          "code": "cd %HOMEPATH%",
          "element": "<pre>\ncd %HOMEPATH%\n</pre>"
        },
        {
          "language": "",
          "code": "mkdir hello\ncd hello",
          "element": "<pre>\nmkdir hello\ncd hello\n</pre>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "github.com/mymodule",
          "element": "<code>github.com/mymodule</code>"
        },
        {
          "language": "",
          "code": "example/hello",
          "element": "<code>example/hello</code>"
        },
        {
          "language": "",
          "code": "$ go mod init example/hello\ngo: creating new go.mod: module example/hello",
          "element": "<pre>\n$ go mod init example/hello\ngo: creating new go.mod: module example/hello\n</pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
          "element": "<pre>\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}\n</pre>"
        },
        {
          "language": "",
          "code": "$ go run .\nHello, World!",
          "element": "<pre>\n$ go run .\nHello, World!\n</pre>"
        },
        {
          "language": "",
          "code": "rsc.io/quote",
          "element": "<code>rsc.io/quote</code>"
        },
        {
          "language": "",
          "code": "rsc.io/quote/v4",
          "element": "<code>rsc.io/quote/v4</code>"
        },
        {
          "language": "",
          "code": "rsc.io/quote",
          "element": "<code>rsc.io/quote</code>"
        },
        {
          "language": "",
          "code": "rsc.io/quote",
          "element": "<code>rsc.io/quote</code>"
        },
        {
          "language": "",
          "code": "rsc.io/quote",
          "element": "<code>rsc.io/quote</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"import \"rsc.io/quote\"func main() {fmt.Println(quote.Go())}",
          "element": "<pre>\npackage main\n\nimport \"fmt\"\n\n<ins>import \"rsc.io/quote\"</ins>\n\nfunc main() {\n    <ins>fmt.Println(quote.Go())</ins>\n}\n</pre>"
        },
        {
          "language": "",
          "code": "$ go mod tidy\ngo: finding module for package rsc.io/quote\ngo: found rsc.io/quote in rsc.io/quote v1.5.2",
          "element": "<pre>\n$ go mod tidy\ngo: finding module for package rsc.io/quote\ngo: found rsc.io/quote in rsc.io/quote v1.5.2\n</pre>"
        },
        {
          "language": "",
          "code": "$ go run .\nDon't communicate by sharing memory, share memory by communicating.",
          "element": "<pre>\n$ go run .\nDon't communicate by sharing memory, share memory by communicating.\n</pre>"
        },
        {
          "language": "",
          "code": "go mod tidy",
          "element": "<code>go mod tidy</code>"
        },
        {
          "language": "",
          "code": "rsc.io/quote",
          "element": "<code>rsc.io/quote</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Tutorial: Get started with Go",
          "id": ""
        },
        {
          "level": 2,
          "text": "Prerequisites",
          "id": "prerequisites"
        },
        {
          "level": 2,
          "text": "Install Go",
          "id": "install"
        },
        {
          "level": 2,
          "text": "Write some code",
          "id": "code"
        },
        {
          "level": 2,
          "text": "Call code in an external package",
          "id": "call"
        },
        {
          "level": 2,
          "text": "Write more code",
          "id": "write-more"
        }
      ],
      "timestamp": 1750757573.223676
    },
    {
      "url": "https://golang.org/doc/tutorial/create-module.html",
      "title": "Tutorial: Create a Go module - The Go Programming Language",
      "content": "Documentation\nTutorials\nTutorial: Create a Go module\nTutorial: Create a Go module\nThis is the first part of a tutorial that introduces a few fundamental\n  features of the Go language. If you're just getting started with Go, be sure\n  to take a look at\nTutorial: Get started with Go\n, which introduces\n  the\ngo\ncommand, Go modules, and very simple Go code.\nIn this tutorial you'll create two modules. The first is a library which is\n  intended to be imported by other libraries or applications. The second is a\n  caller application which will use the first.\nThis tutorial's sequence includes seven brief topics that each illustrate a\n  different part of the language.\nCreate a module -- Write a small module with functions you can call from\n    another module.\nCall your code from another module\n--\n    Import and use your new module.\nReturn and handle an error\n-- Add simple\n    error handling.\nReturn a random greeting\n-- Handle data\n    in slices (Go's dynamically-sized arrays).\nReturn greetings for multiple people\n-- Store key/value pairs in a map.\nAdd a test\n-- Use Go's built-in unit testing\n    features to test your code.\nCompile and install the application\n--\n    Compile and install your code locally.\nNote:\nFor other tutorials, see\nTutorials\n.\nPrerequisites\nSome programming experience.\nThe code here is pretty\n    simple, but it helps to know something about functions, loops, and arrays.\nA tool to edit your code.\nAny text editor you have will\n    work fine. Most text editors have good support for Go. The most popular are\n    VSCode (free), GoLand (paid), and Vim (free).\nA command terminal.\nGo works well using any terminal on\n    Linux and Mac, and on PowerShell or cmd in Windows.\nStart a module that others can use\nStart by creating a Go module. In a\n  module, you collect one or more related packages for a discrete and useful set\n  of functions. For example, you might create a module with packages that have\n  functions for doing financial analysis so that others writing financial\n  applications can use your work. For more about developing modules, see\nDeveloping and publishing modules\n.\nGo code is grouped into packages, and packages are grouped into modules. Your\n  module specifies dependencies needed to run your code, including the Go\n  version and the set of other modules it requires.\nAs you add or improve functionality in your module, you publish new versions\n  of the module. Developers writing code that calls functions in your module can\n  import the module's updated packages and test with the new version before\n  putting it into production use.\nOpen a command prompt and\ncd\nto your home directory.\nOn Linux or Mac:\ncd\nOn Windows:\ncd %HOMEPATH%\nCreate a\ngreetings\ndirectory for your Go module source code.\nFor example, from your home directory use the following commands:\nmkdir greetings\ncd greetings\nStart your module using the\ngo mod init\ncommand\n.\nRun the\ngo mod init\ncommand, giving it your module path --\n      here, use\nexample.com/greetings\n. If you publish a module,\n      this\nmust\nbe a path from which your module can be downloaded by\n      Go tools. That would be your code's repository.\nFor more on naming your module with a module path, see\nManaging\n        dependencies\n.\n$ go mod init example.com/greetings\ngo: creating new go.mod: module example.com/greetings\nThe\ngo mod init\ncommand creates a go.mod file to track your\n      code's dependencies. So far, the file includes only the name of your\n      module and the Go version your code supports. But as you add dependencies,\n      the go.mod file will list the versions your code depends on. This keeps\n      builds reproducible and gives you direct control over which module\n      versions to use.\nIn your text editor, create a file in which to write your code and call it\n    greetings.go.\nPaste the following code into your greetings.go file and save the file.\npackage greetings\n\nimport \"fmt\"\n\n// Hello returns a greeting for the named person.\nfunc Hello(name string) string {\n    // Return a greeting that embeds the name in a message.\n    message := fmt.Sprintf(\"Hi, %v. Welcome!\", name)\n    return message\n}\nThis is the first code for your module. It returns a greeting to any\n      caller that asks for one. You'll write code that calls this function in\n      the next step.\nIn this code, you:\nDeclare a\ngreetings\npackage to collect related functions.\nImplement a\nHello\nfunction to return the greeting.\nThis function takes a\nname\nparameter whose type is\nstring\n. The function also returns a\nstring\n.\n          In Go, a function whose name starts with a capital letter can be\n          called by a function not in the same package. This is known in Go as\n          an exported name. For more about exported names, see\nExported names\nin the\n          Go tour.\nDeclare a\nmessage\nvariable to hold your greeting.\nIn Go, the\n:=\noperator is a shortcut for declaring and\n          initializing a variable in one line (Go uses the value on the right to\n          determine the variable's type). Taking the long way, you might have\n          written this as:\nvar message string\nmessage = fmt.Sprintf(\"Hi, %v. Welcome!\", name)\nUse the\nfmt\npackage's\nSprintf\nfunction\nto create a greeting message. The\n        first argument is a format string, and\nSprintf\nsubstitutes\n        the\nname\nparameter's value for the\n%v\nformat\n        verb. Inserting the value of the\nname\nparameter completes\n        the greeting text.\nReturn the formatted greeting text to the caller.\nIn the next step, you'll call this function from another module.\nCall your code from another module >",
      "code_examples": [
        {
          "language": "",
          "code": "cd %HOMEPATH%",
          "element": "<pre>\ncd %HOMEPATH%\n</pre>"
        },
        {
          "language": "",
          "code": "mkdir greetings\ncd greetings",
          "element": "<pre>\nmkdir greetings\ncd greetings\n</pre>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "example.com/greetings",
          "element": "<code>example.com/greetings</code>"
        },
        {
          "language": "",
          "code": "$ go mod init example.com/greetings\ngo: creating new go.mod: module example.com/greetings",
          "element": "<pre>\n$ go mod init example.com/greetings\ngo: creating new go.mod: module example.com/greetings\n</pre>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "package greetings\n\nimport \"fmt\"\n\n// Hello returns a greeting for the named person.\nfunc Hello(name string) string {\n    // Return a greeting that embeds the name in a message.\n    message := fmt.Sprintf(\"Hi, %v. Welcome!\", name)\n    return message\n}",
          "element": "<pre>\npackage greetings\n\nimport \"fmt\"\n\n// Hello returns a greeting for the named person.\nfunc Hello(name string) string {\n    // Return a greeting that embeds the name in a message.\n    message := fmt..."
        },
        {
          "language": "",
          "code": "var message string\nmessage = fmt.Sprintf(\"Hi, %v. Welcome!\", name)",
          "element": "<pre>\nvar message string\nmessage = fmt.Sprintf(\"Hi, %v. Welcome!\", name)\n</pre>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Tutorial: Create a Go module",
          "id": ""
        },
        {
          "level": 2,
          "text": "Prerequisites",
          "id": "prerequisites"
        },
        {
          "level": 2,
          "text": "Start a module that others can use",
          "id": "start"
        }
      ],
      "timestamp": 1750757577.176739
    },
    {
      "url": "https://golang.org/doc/tutorial/workspaces.html",
      "title": "Tutorial: Getting started with multi-module workspaces - The Go Programming Language",
      "content": "Documentation\nTutorials\nTutorial: Getting started with multi-module workspaces\nTutorial: Getting started with multi-module workspaces\nThis tutorial introduces the basics of multi-module workspaces in Go.\nWith multi-module workspaces, you can tell the Go command that youre\nwriting code in multiple modules at the same time and easily build and\nrun code in those modules.\nIn this tutorial, youll create two modules in a shared multi-module\nworkspace, make changes across those modules, and see the results\nof those changes in a build.\nNote:\nFor other tutorials, see\nTutorials\n.\nPrerequisites\nAn installation of Go 1.18 or later.\nA tool to edit your code.\nAny text editor you have will work fine.\nA command terminal.\nGo works well using any terminal on Linux and Mac,\nand on PowerShell or cmd in Windows.\nThis tutorial requires go1.18 or later. Make sure youve installed Go at Go 1.18 or later using the\nlinks at\ngo.dev/dl\n.\nCreate a module for your code\nTo begin, create a module for the code youll write.\nOpen a command prompt and change to your home directory.\nOn Linux or Mac:\n$ cd\nOn Windows:\nC:\\> cd %HOMEPATH%\nThe rest of the tutorial will show a $ as the prompt. The commands you use\nwill work on Windows too.\nFrom the command prompt, create a directory for your code called workspace.\n$ mkdir workspace\n$ cd workspace\nInitialize the module\nOur example will create a new module\nhello\nthat will depend on the golang.org/x/example module.\nCreate the hello module:\n$ mkdir hello\n$ cd hello\n$ go mod init example.com/hello\ngo: creating new go.mod: module example.com/hello\nAdd a dependency on the golang.org/x/example/hello/reverse package by using\ngo get\n.\n$ go get golang.org/x/example/hello/reverse\nCreate hello.go in the hello directory with the following contents:\npackage main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"))\n}\nNow, run the hello program:\n$ go run .\nolleH\nCreate the workspace\nIn this step, well create a\ngo.work\nfile to specify a workspace with the module.\nInitialize the workspace\nIn the\nworkspace\ndirectory, run:\n$ go work init ./hello\nThe\ngo work init\ncommand tells\ngo\nto create a\ngo.work\nfile\nfor a workspace containing the modules in the\n./hello\ndirectory.\nThe\ngo\ncommand produces a\ngo.work\nfile that looks like this:\ngo 1.18\n\nuse ./hello\nThe\ngo.work\nfile has similar syntax to\ngo.mod\n.\nThe\ngo\ndirective tells Go which version of Go the file should be\ninterpreted with. Its similar to the\ngo\ndirective in the\ngo.mod\nfile.\nThe\nuse\ndirective tells Go that the module in the\nhello\ndirectory should be main modules when doing a build.\nSo in any subdirectory of\nworkspace\nthe module will be active.\nRun the program in the workspace directory\nIn the\nworkspace\ndirectory, run:\n$ go run ./hello\nolleH\nThe Go command includes all the modules in the workspace as main modules. This allows us\nto refer to a package in the module, even outside the module. Running the\ngo run\ncommand\noutside the module or the workspace would result in an error because the\ngo\ncommand\nwouldnt know which modules to use.\nNext, well add a local copy of the\ngolang.org/x/example/hello\nmodule to the workspace.\nThat module is stored in a subdirectory of the\ngo.googlesource.com/example\nGit repository.\nWell then add a new function to the\nreverse\npackage that we can use instead of\nString\n.\nDownload and modify the\ngolang.org/x/example/hello\nmodule\nIn this step, well download a copy of the Git repo containing the\ngolang.org/x/example/hello\nmodule,\nadd it to the workspace, and then add a new function to it that we will use from the hello program.\nClone the repository\nFrom the workspace directory, run the\ngit\ncommand to clone the repository:\n$ git clone https://go.googlesource.com/example\nCloning into 'example'...\nremote: Total 165 (delta 27), reused 165 (delta 27)\nReceiving objects: 100% (165/165), 434.18 KiB | 1022.00 KiB/s, done.\nResolving deltas: 100% (27/27), done.\nAdd the module to the workspace\nThe Git repo was just checked out into\n./example\n.\nThe source code for the\ngolang.org/x/example/hello\nmodule is in\n./example/hello\n.\nAdd it to the workspace:\n$ go work use ./example/hello\nThe\ngo work use\ncommand adds a new module to the go.work file. It will now look like this:\ngo 1.18\n\nuse (\n    ./hello\n    ./example/hello\n)\nThe workspace now includes both the\nexample.com/hello\nmodule and the\ngolang.org/x/example/hello\nmodule,\nwhich provides the\ngolang.org/x/example/hello/reverse\npackage.\nThis will allow us to use the new code we will write in our copy of the\nreverse\npackage\ninstead of the version of the package in the module cache\nthat we downloaded with the\ngo get\ncommand.\nAdd the new function.\nWell add a new function to reverse a number to the\ngolang.org/x/example/hello/reverse\npackage.\nCreate a new file named\nint.go\nin the\nworkspace/example/hello/reverse\ndirectory containing the following contents:\npackage reverse\n\nimport \"strconv\"\n\n// Int returns the decimal reversal of the integer i.\nfunc Int(i int) int {\n    i, _ = strconv.Atoi(String(strconv.Itoa(i)))\n    return i\n}\nModify the hello program to use the function.\nModify the contents of\nworkspace/hello/hello.go\nto contain the following contents:\npackage main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"), reverse.Int(24601))\n}\nRun the code in the workspace\nFrom the workspace directory, run\n$ go run ./hello\nolleH 10642\nThe Go command finds the\nexample.com/hello\nmodule specified in the\ncommand line in the\nhello\ndirectory specified by the\ngo.work\nfile, and similarly resolves the\ngolang.org/x/example/hello/reverse\nimport using\nthe\ngo.work\nfile.\ngo.work\ncan be used instead of adding\nreplace\ndirectives to work across multiple modules.\nSince the two modules are in the same workspace its easy\nto make a change in one module and use it in another.\nFuture step\nNow, to properly release these modules wed need to make a release of the\ngolang.org/x/example/hello\nmodule, for example at\nv0.1.0\n. This is usually done by tagging a commit on the modules version\ncontrol repository. See the\nmodule release workflow documentation\nfor more details. Once the release is done, we can increase the requirement on the\ngolang.org/x/example/hello\nmodule in\nhello/go.mod\n:\ncd hello\ngo get golang.org/x/example/hello@v0.1.0\nThat way, the\ngo\ncommand can properly resolve the modules outside the workspace.\nLearn more about workspaces\nThe\ngo\ncommand has a couple of subcommands for working with workspaces in addition to\ngo work init\nwhich\nwe saw earlier in the tutorial:\ngo work use [-r] [dir]\nadds a\nuse\ndirective to the\ngo.work\nfile for\ndir\n,\nif it exists, and removes the\nuse\ndirectory if the argument directory doesnt exist. The\n-r\nflag examines subdirectories of\ndir\nrecursively.\ngo work edit\nedits the\ngo.work\nfile similarly to\ngo mod edit\ngo work sync\nsyncs dependencies from the workspaces build list into each of the workspace modules.\nSee\nWorkspaces\nin the Go Modules Reference for more detail on\nworkspaces and\ngo.work\nfiles.",
      "code_examples": [
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<pre><code>C:\\&gt; cd %HOMEPATH%\n</code></pre>"
        },
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<code>C:\\&gt; cd %HOMEPATH%\n</code>"
        },
        {
          "language": "",
          "code": "$ mkdir workspace\n$ cd workspace",
          "element": "<pre><code>$ mkdir workspace\n$ cd workspace\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ mkdir workspace\n$ cd workspace",
          "element": "<code>$ mkdir workspace\n$ cd workspace\n</code>"
        },
        {
          "language": "",
          "code": "$ mkdir hello\n$ cd hello\n$ go mod init example.com/hello\ngo: creating new go.mod: module example.com/hello",
          "element": "<pre><code>$ mkdir hello\n$ cd hello\n$ go mod init example.com/hello\ngo: creating new go.mod: module example.com/hello\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ mkdir hello\n$ cd hello\n$ go mod init example.com/hello\ngo: creating new go.mod: module example.com/hello",
          "element": "<code>$ mkdir hello\n$ cd hello\n$ go mod init example.com/hello\ngo: creating new go.mod: module example.com/hello\n</code>"
        },
        {
          "language": "",
          "code": "$ go get golang.org/x/example/hello/reverse",
          "element": "<pre><code>$ go get golang.org/x/example/hello/reverse\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get golang.org/x/example/hello/reverse",
          "element": "<code>$ go get golang.org/x/example/hello/reverse\n</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"))\n}",
          "element": "<pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"))\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"))\n}",
          "element": "<code>package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"))\n}\n</code>"
        },
        {
          "language": "",
          "code": "$ go run .\nolleH",
          "element": "<pre><code>$ go run .\nolleH\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go run .\nolleH",
          "element": "<code>$ go run .\nolleH\n</code>"
        },
        {
          "language": "",
          "code": "$ go work init ./hello",
          "element": "<pre><code>$ go work init ./hello\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go work init ./hello",
          "element": "<code>$ go work init ./hello\n</code>"
        },
        {
          "language": "",
          "code": "go work init",
          "element": "<code>go work init</code>"
        },
        {
          "language": "",
          "code": "go 1.18\n\nuse ./hello",
          "element": "<pre><code>go 1.18\n\nuse ./hello\n</code></pre>"
        },
        {
          "language": "",
          "code": "go 1.18\n\nuse ./hello",
          "element": "<code>go 1.18\n\nuse ./hello\n</code>"
        },
        {
          "language": "",
          "code": "$ go run ./hello\nolleH",
          "element": "<pre><code>$ go run ./hello\nolleH\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go run ./hello\nolleH",
          "element": "<code>$ go run ./hello\nolleH\n</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello",
          "element": "<code>golang.org/x/example/hello</code>"
        },
        {
          "language": "",
          "code": "go.googlesource.com/example",
          "element": "<code>go.googlesource.com/example</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello",
          "element": "<code>golang.org/x/example/hello</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello",
          "element": "<code>golang.org/x/example/hello</code>"
        },
        {
          "language": "",
          "code": "$ git clone https://go.googlesource.com/example\nCloning into 'example'...\nremote: Total 165 (delta 27), reused 165 (delta 27)\nReceiving objects: 100% (165/165), 434.18 KiB | 1022.00 KiB/s, done.\nResolving deltas: 100% (27/27), done.",
          "element": "<pre><code>$ git clone https://go.googlesource.com/example\nCloning into 'example'...\nremote: Total 165 (delta 27), reused 165 (delta 27)\nReceiving objects: 100% (165/165), 434.18 KiB | 1022.00 KiB/s, ..."
        },
        {
          "language": "",
          "code": "$ git clone https://go.googlesource.com/example\nCloning into 'example'...\nremote: Total 165 (delta 27), reused 165 (delta 27)\nReceiving objects: 100% (165/165), 434.18 KiB | 1022.00 KiB/s, done.\nResolving deltas: 100% (27/27), done.",
          "element": "<code>$ git clone https://go.googlesource.com/example\nCloning into 'example'...\nremote: Total 165 (delta 27), reused 165 (delta 27)\nReceiving objects: 100% (165/165), 434.18 KiB | 1022.00 KiB/s, done...."
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello",
          "element": "<code>golang.org/x/example/hello</code>"
        },
        {
          "language": "",
          "code": "./example/hello",
          "element": "<code>./example/hello</code>"
        },
        {
          "language": "",
          "code": "$ go work use ./example/hello",
          "element": "<pre><code>$ go work use ./example/hello\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go work use ./example/hello",
          "element": "<code>$ go work use ./example/hello\n</code>"
        },
        {
          "language": "",
          "code": "go work use",
          "element": "<code>go work use</code>"
        },
        {
          "language": "",
          "code": "go 1.18\n\nuse (\n    ./hello\n    ./example/hello\n)",
          "element": "<pre><code>go 1.18\n\nuse (\n    ./hello\n    ./example/hello\n)\n</code></pre>"
        },
        {
          "language": "",
          "code": "go 1.18\n\nuse (\n    ./hello\n    ./example/hello\n)",
          "element": "<code>go 1.18\n\nuse (\n    ./hello\n    ./example/hello\n)\n</code>"
        },
        {
          "language": "",
          "code": "example.com/hello",
          "element": "<code>example.com/hello</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello",
          "element": "<code>golang.org/x/example/hello</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello/reverse",
          "element": "<code>golang.org/x/example/hello/reverse</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello/reverse",
          "element": "<code>golang.org/x/example/hello/reverse</code>"
        },
        {
          "language": "",
          "code": "workspace/example/hello/reverse",
          "element": "<code>workspace/example/hello/reverse</code>"
        },
        {
          "language": "",
          "code": "package reverse\n\nimport \"strconv\"\n\n// Int returns the decimal reversal of the integer i.\nfunc Int(i int) int {\n    i, _ = strconv.Atoi(String(strconv.Itoa(i)))\n    return i\n}",
          "element": "<pre><code>package reverse\n\nimport \"strconv\"\n\n// Int returns the decimal reversal of the integer i.\nfunc Int(i int) int {\n    i, _ = strconv.Atoi(String(strconv.Itoa(i)))\n    return i\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "package reverse\n\nimport \"strconv\"\n\n// Int returns the decimal reversal of the integer i.\nfunc Int(i int) int {\n    i, _ = strconv.Atoi(String(strconv.Itoa(i)))\n    return i\n}",
          "element": "<code>package reverse\n\nimport \"strconv\"\n\n// Int returns the decimal reversal of the integer i.\nfunc Int(i int) int {\n    i, _ = strconv.Atoi(String(strconv.Itoa(i)))\n    return i\n}\n</code>"
        },
        {
          "language": "",
          "code": "workspace/hello/hello.go",
          "element": "<code>workspace/hello/hello.go</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"), reverse.Int(24601))\n}",
          "element": "<pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"), reverse.Int(24601))\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"), reverse.Int(24601))\n}",
          "element": "<code>package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/example/hello/reverse\"\n)\n\nfunc main() {\n    fmt.Println(reverse.String(\"Hello\"), reverse.Int(24601))\n}\n</code>"
        },
        {
          "language": "",
          "code": "$ go run ./hello\nolleH 10642",
          "element": "<pre><code>$ go run ./hello\nolleH 10642\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go run ./hello\nolleH 10642",
          "element": "<code>$ go run ./hello\nolleH 10642\n</code>"
        },
        {
          "language": "",
          "code": "example.com/hello",
          "element": "<code>example.com/hello</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello/reverse",
          "element": "<code>golang.org/x/example/hello/reverse</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello",
          "element": "<code>golang.org/x/example/hello</code>"
        },
        {
          "language": "",
          "code": "golang.org/x/example/hello",
          "element": "<code>golang.org/x/example/hello</code>"
        },
        {
          "language": "",
          "code": "hello/go.mod",
          "element": "<code>hello/go.mod</code>"
        },
        {
          "language": "",
          "code": "cd hello\ngo get golang.org/x/example/hello@v0.1.0",
          "element": "<pre><code>cd hello\ngo get golang.org/x/example/hello@v0.1.0\n</code></pre>"
        },
        {
          "language": "",
          "code": "cd hello\ngo get golang.org/x/example/hello@v0.1.0",
          "element": "<code>cd hello\ngo get golang.org/x/example/hello@v0.1.0\n</code>"
        },
        {
          "language": "",
          "code": "go work init",
          "element": "<code>go work init</code>"
        },
        {
          "language": "",
          "code": "go work use [-r] [dir]",
          "element": "<code>go work use [-r] [dir]</code>"
        },
        {
          "language": "",
          "code": "go work edit",
          "element": "<code>go work edit</code>"
        },
        {
          "language": "",
          "code": "go mod edit",
          "element": "<code>go mod edit</code>"
        },
        {
          "language": "",
          "code": "go work sync",
          "element": "<code>go work sync</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Tutorial: Getting started with multi-module workspaces",
          "id": ""
        },
        {
          "level": 2,
          "text": "Prerequisites",
          "id": "prerequisites"
        },
        {
          "level": 2,
          "text": "Create a module for your code",
          "id": "create_folder"
        },
        {
          "level": 2,
          "text": "Create the workspace",
          "id": "create-the-workspace"
        },
        {
          "level": 2,
          "text": "Download and modify thegolang.org/x/example/hellomodule",
          "id": "download-and-modify-the-golangorgxexamplehello-module"
        },
        {
          "level": 2,
          "text": "Learn more about workspaces",
          "id": "learn-more-about-workspaces"
        },
        {
          "level": 4,
          "text": "Initialize the workspace",
          "id": "initialize-the-workspace"
        },
        {
          "level": 4,
          "text": "Run the program in the workspace directory",
          "id": "run-the-program-in-the-workspace-directory"
        },
        {
          "level": 4,
          "text": "Run the code in the workspace",
          "id": "run-the-code-in-the-workspace"
        },
        {
          "level": 4,
          "text": "Future step",
          "id": "future-step"
        }
      ],
      "timestamp": 1750757581.5246432
    },
    {
      "url": "https://golang.org/doc/tutorial/web-service-gin.html",
      "title": "Tutorial: Developing a RESTful API with Go and Gin - The Go Programming Language",
      "content": "Documentation\nTutorials\nTutorial: Developing a RESTful API with Go and Gin\nTutorial: Developing a RESTful API with Go and Gin\nThis tutorial introduces the basics of writing a RESTful web service API with Go\nand the\nGin Web Framework\n(Gin).\nYoull get the most out of this tutorial if you have a basic familiarity with Go\nand its tooling. If this is your first exposure to Go, please see\nTutorial: Get started with Go\nfor a quick introduction.\nGin simplifies many coding tasks associated with building web applications,\nincluding web services. In this tutorial, youll use Gin to route requests,\nretrieve request details, and marshal JSON for responses.\nIn this tutorial, you will build a RESTful API server with two endpoints. Your\nexample project will be a repository of data about vintage jazz records.\nThe tutorial includes the following sections:\nDesign API endpoints.\nCreate a folder for your code.\nCreate the data.\nWrite a handler to return all items.\nWrite a handler to add a new item.\nWrite a handler to return a specific item.\nNote:\nFor other tutorials, see\nTutorials\n.\nTo try this as an interactive tutorial you complete in Google Cloud Shell,\nclick the button below.\nPrerequisites\nAn installation of Go 1.16 or later.\nFor installation instructions, see\nInstalling Go\n.\nA tool to edit your code.\nAny text editor you have will work fine.\nA command terminal.\nGo works well using any terminal on Linux and Mac,\nand on PowerShell or cmd in Windows.\nThe curl tool.\nOn Linux and Mac, this should already be installed. On\nWindows, its included on Windows 10 Insider build 17063 and later. For earlier\nWindows versions, you might need to install it. For more, see\nTar and Curl Come to Windows\n.\nDesign API endpoints\nYoull build an API that provides access to a store selling vintage recordings\non vinyl. So youll need to provide endpoints through which a client can get\nand add albums for users.\nWhen developing an API, you typically begin by designing the endpoints. Your\nAPIs users will have more success if the endpoints are easy to understand.\nHere are the endpoints youll create in this tutorial.\n/albums\nGET\n Get a list of all albums, returned as JSON.\nPOST\n Add a new album from request data sent as JSON.\n/albums/:id\nGET\n Get an album by its ID, returning the album data as JSON.\nNext, youll create a folder for your code.\nCreate a folder for your code\nTo begin, create a project for the code youll write.\nOpen a command prompt and change to your home directory.\nOn Linux or Mac:\n$ cd\nOn Windows:\nC:\\> cd %HOMEPATH%\nUsing the command prompt, create a directory for your code called\nweb-service-gin.\n$ mkdir web-service-gin\n$ cd web-service-gin\nCreate a module in which you can manage dependencies.\nRun the\ngo mod init\ncommand, giving it the path of the module your code\nwill be in.\n$ go mod init example/web-service-gin\ngo: creating new go.mod: module example/web-service-gin\nThis command creates a go.mod file in which dependencies you add will be\nlisted for tracking. For more about naming a module with a module path, see\nManaging dependencies\n.\nNext, youll design data structures for handling data.\nCreate the data\nTo keep things simple for the tutorial, youll store data in memory. A more\ntypical API would interact with a database.\nNote that storing data in memory means that the set of albums will be lost each\ntime you stop the server, then recreated when you start it.\nWrite the code\nUsing your text editor, create a file called main.go in the web-service\ndirectory. Youll write your Go code in this file.\nInto main.go, at the top of the file, paste the following package declaration.\npackage main\nA standalone program (as opposed to a library) is always in package\nmain\n.\nBeneath the package declaration, paste the following declaration of an\nalbum\nstruct. Youll use this to store album data in memory.\nStruct tags such as\njson:\"artist\"\nspecify what a fields name should be\nwhen the structs contents are serialized into JSON. Without them, the JSON\nwould use the structs capitalized field names  a style not as common in\nJSON.\n// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `json:\"price\"`\n}\nBeneath the struct declaration you just added, paste the following slice of\nalbum\nstructs containing data youll use to start.\n// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulligan\", Price: 17.99},\n    {ID: \"3\", Title: \"Sarah Vaughan and Clifford Brown\", Artist: \"Sarah Vaughan\", Price: 39.99},\n}\nNext, youll write code to implement your first endpoint.\nWrite a handler to return all items\nWhen the client makes a request at\nGET /albums\n, you want to return all the\nalbums as JSON.\nTo do this, youll write the following:\nLogic to prepare a response\nCode to map the request path to your logic\nNote that this is the reverse of how theyll be executed at runtime, but youre\nadding dependencies first, then the code that depends on them.\nWrite the code\nBeneath the struct code you added in the preceding section, paste the\nfollowing code to get the album list.\nThis\ngetAlbums\nfunction creates JSON from the slice of\nalbum\nstructs,\nwriting the JSON into the response.\n// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}\nIn this code, you:\nWrite a\ngetAlbums\nfunction that takes a\ngin.Context\nparameter. Note that you could have given this function any name  neither\nGin nor Go require a particular function name format.\ngin.Context\nis the most important part of Gin. It carries request\ndetails, validates and serializes JSON, and more. (Despite the similar\nname, this is different from Gos built-in\ncontext\npackage.)\nCall\nContext.IndentedJSON\nto serialize the struct into JSON and add it to the response.\nThe functions first argument is the HTTP status code you want to send to\nthe client. Here, youre passing the\nStatusOK\nconstant from the\nnet/http\npackage to indicate\n200 OK\n.\nNote that you can replace\nContext.IndentedJSON\nwith a call to\nContext.JSON\nto send more compact JSON. In practice, the indented form is much easier to\nwork with when debugging and the size difference is usually small.\nNear the top of main.go, just beneath the\nalbums\nslice declaration, paste\nthe code below to assign the handler function to an endpoint path.\nThis sets up an association in which\ngetAlbums\nhandles requests to the\n/albums\nendpoint path.\nfunc main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n\n    router.Run(\"localhost:8080\")\n}\nIn this code, you:\nInitialize a Gin router using\nDefault\n.\nUse the\nGET\nfunction to associate the\nGET\nHTTP method and\n/albums\npath with a handler\nfunction.\nNote that youre passing the\nname\nof the\ngetAlbums\nfunction. This is\ndifferent from passing the\nresult\nof the function, which you would do by\npassing\ngetAlbums()\n(note the parenthesis).\nUse the\nRun\nfunction to attach the router to an\nhttp.Server\nand start the server.\nNear the top of main.go, just beneath the package declaration, import the\npackages youll need to support the code youve just written.\nThe first lines of code should look like this:\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\nSave main.go.\nRun the code\nBegin tracking the Gin module as a dependency.\nAt the command line, use\ngo get\nto add the github.com/gin-gonic/gin module as a dependency for your module.\nUse a dot argument to mean get dependencies for code in the current\ndirectory.\n$ go get .\ngo get: added github.com/gin-gonic/gin v1.7.2\nGo resolved and downloaded this dependency to satisfy the\nimport\ndeclaration you added in the previous step.\nFrom the command line in the directory containing main.go, run the code.\nUse a dot argument to mean run code in the current directory.\n$ go run .\nOnce the code is running, you have a running HTTP server to which you can\nsend requests.\nFrom a new command line window, use\ncurl\nto make a request to your running\nweb service.\n$ curl http://localhost:8080/albums\nThe command should display the data you seeded the service with.\n[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\": \"2\",\n                \"title\": \"Jeru\",\n                \"artist\": \"Gerry Mulligan\",\n                \"price\": 17.99\n        },\n        {\n                \"id\": \"3\",\n                \"title\": \"Sarah Vaughan and Clifford Brown\",\n                \"artist\": \"Sarah Vaughan\",\n                \"price\": 39.99\n        }\n]\nYouve started an API! In the next section, youll create another endpoint with\ncode to handle a\nPOST\nrequest to add an item.\nWrite a handler to add a new item\nWhen the client makes a\nPOST\nrequest at\n/albums\n, you want to add the album\ndescribed in the request body to the existing albums data.\nTo do this, youll write the following:\nLogic to add the new album to the existing list.\nA bit of code to route the\nPOST\nrequest to your logic.\nWrite the code\nAdd code to add albums data to the list of albums.\nSomewhere after the\nimport\nstatements, paste the following code. (The end\nof the file is a good place for this code, but Go doesnt enforce the order\nin which you declare functions.)\n// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlbum.\n    if err := c.BindJSON(&newAlbum); err != nil {\n        return\n    }\n\n    // Add the new album to the slice.\n    albums = append(albums, newAlbum)\n    c.IndentedJSON(http.StatusCreated, newAlbum)\n}\nIn this code, you:\nUse\nContext.BindJSON\nto bind the request body to\nnewAlbum\n.\nAppend the\nalbum\nstruct initialized from the JSON to the\nalbums\nslice.\nAdd a\n201\nstatus code to the response, along with JSON representing\nthe album you added.\nChange your\nmain\nfunction so that it includes the\nrouter.POST\nfunction,\nas in the following.\nfunc main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}\nIn this code, you:\nAssociate the\nPOST\nmethod at the\n/albums\npath with the\npostAlbums\nfunction.\nWith Gin, you can associate a handler with an HTTP method-and-path\ncombination. In this way, you can separately route requests sent to a\nsingle path based on the method the client is using.\nRun the code\nIf the server is still running from the last section, stop it.\nFrom the command line in the directory containing main.go, run the code.\n$ go run .\nFrom a different command line window, use\ncurl\nto make a request to your\nrunning web service.\n$ curl http://localhost:8080/albums \\\n    --include \\\n    --header \"Content-Type: application/json\" \\\n    --request \"POST\" \\\n    --data '{\"id\": \"4\",\"title\": \"The Modern Sound of Betty Carter\",\"artist\": \"Betty Carter\",\"price\": 49.99}'\nThe command should display headers and JSON for the added album.\nHTTP/1.1 201 Created\nContent-Type: application/json; charset=utf-8\nDate: Wed, 02 Jun 2021 00:34:12 GMT\nContent-Length: 116\n\n{\n    \"id\": \"4\",\n    \"title\": \"The Modern Sound of Betty Carter\",\n    \"artist\": \"Betty Carter\",\n    \"price\": 49.99\n}\nAs in the previous section, use\ncurl\nto retrieve the full list of albums,\nwhich you can use to confirm that the new album was added.\n$ curl http://localhost:8080/albums \\\n    --header \"Content-Type: application/json\" \\\n    --request \"GET\"\nThe command should display the album list.\n[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\": \"2\",\n                \"title\": \"Jeru\",\n                \"artist\": \"Gerry Mulligan\",\n                \"price\": 17.99\n        },\n        {\n                \"id\": \"3\",\n                \"title\": \"Sarah Vaughan and Clifford Brown\",\n                \"artist\": \"Sarah Vaughan\",\n                \"price\": 39.99\n        },\n        {\n                \"id\": \"4\",\n                \"title\": \"The Modern Sound of Betty Carter\",\n                \"artist\": \"Betty Carter\",\n                \"price\": 49.99\n        }\n]\nIn the next section, youll add code to handle a\nGET\nfor a specific item.\nWrite a handler to return a specific item\nWhen the client makes a request to\nGET /albums/[id]\n, you want to return the\nalbum whose ID matches the\nid\npath parameter.\nTo do this, you will:\nAdd logic to retrieve the requested album.\nMap the path to the logic.\nWrite the code\nBeneath the\npostAlbums\nfunction you added in the preceding section, paste\nthe following code to retrieve a specific album.\nThis\ngetAlbumByID\nfunction will extract the ID in the request path, then\nlocate an album that matches.\n// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param(\"id\")\n\n    // Loop over the list of albums, looking for\n    // an album whose ID value matches the parameter.\n    for _, a := range albums {\n        if a.ID == id {\n            c.IndentedJSON(http.StatusOK, a)\n            return\n        }\n    }\n    c.IndentedJSON(http.StatusNotFound, gin.H{\"message\": \"album not found\"})\n}\nIn this code, you:\nUse\nContext.Param\nto retrieve the\nid\npath parameter from the URL. When you map this\nhandler to a path, youll include a placeholder for the parameter in the\npath.\nLoop over the\nalbum\nstructs in the slice, looking for one whose\nID\nfield value matches the\nid\nparameter value. If its found, you serialize\nthat\nalbum\nstruct to JSON and return it as a response with a\n200 OK\nHTTP code.\nAs mentioned above, a real-world service would likely use a database\nquery to perform this lookup.\nReturn an HTTP\n404\nerror with\nhttp.StatusNotFound\nif the album isnt found.\nFinally, change your\nmain\nso that it includes a new call to\nrouter.GET\n,\nwhere the path is now\n/albums/:id\n, as shown in the following example.\nfunc main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}\nIn this code, you:\nAssociate the\n/albums/:id\npath with the\ngetAlbumByID\nfunction. In\nGin, the colon preceding an item in the path signifies that the item is\na path parameter.\nRun the code\nIf the server is still running from the last section, stop it.\nFrom the command line in the directory containing main.go, run the code to\nstart the server.\n$ go run .\nFrom a different command line window, use\ncurl\nto make a request to your\nrunning web service.\n$ curl http://localhost:8080/albums/2\nThe command should display JSON for the album whose ID you used. If the\nalbum wasnt found, youll get JSON with an error message.\n{\n        \"id\": \"2\",\n        \"title\": \"Jeru\",\n        \"artist\": \"Gerry Mulligan\",\n        \"price\": 17.99\n}\nConclusion\nCongratulations! Youve just used Go and Gin to write a simple RESTful web\nservice.\nSuggested next topics:\nIf youre new to Go, youll find useful best practices described in\nEffective Go\nand\nHow to write Go code\n.\nThe\nGo Tour\nis a great step-by-step\nintroduction to Go fundamentals.\nFor more about Gin, see the\nGin Web Framework package documentation\nor the\nGin Web Framework docs\n.\nCompleted code\nThis section contains the code for the application you build with this tutorial.\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\n\n// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `json:\"price\"`\n}\n\n// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulligan\", Price: 17.99},\n    {ID: \"3\", Title: \"Sarah Vaughan and Clifford Brown\", Artist: \"Sarah Vaughan\", Price: 39.99},\n}\n\nfunc main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}\n\n// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}\n\n// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlbum.\n    if err := c.BindJSON(&newAlbum); err != nil {\n        return\n    }\n\n    // Add the new album to the slice.\n    albums = append(albums, newAlbum)\n    c.IndentedJSON(http.StatusCreated, newAlbum)\n}\n\n// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param(\"id\")\n\n    // Loop through the list of albums, looking for\n    // an album whose ID value matches the parameter.\n    for _, a := range albums {\n        if a.ID == id {\n            c.IndentedJSON(http.StatusOK, a)\n            return\n        }\n    }\n    c.IndentedJSON(http.StatusNotFound, gin.H{\"message\": \"album not found\"})\n}",
      "code_examples": [
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<pre><code>C:\\&gt; cd %HOMEPATH%\n</code></pre>"
        },
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<code>C:\\&gt; cd %HOMEPATH%\n</code>"
        },
        {
          "language": "",
          "code": "$ mkdir web-service-gin\n$ cd web-service-gin",
          "element": "<pre><code>$ mkdir web-service-gin\n$ cd web-service-gin\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ mkdir web-service-gin\n$ cd web-service-gin",
          "element": "<code>$ mkdir web-service-gin\n$ cd web-service-gin\n</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "$ go mod init example/web-service-gin\ngo: creating new go.mod: module example/web-service-gin",
          "element": "<pre><code>$ go mod init example/web-service-gin\ngo: creating new go.mod: module example/web-service-gin\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod init example/web-service-gin\ngo: creating new go.mod: module example/web-service-gin",
          "element": "<code>$ go mod init example/web-service-gin\ngo: creating new go.mod: module example/web-service-gin\n</code>"
        },
        {
          "language": "",
          "code": "package main",
          "element": "<pre><code>package main\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main",
          "element": "<code>package main\n</code>"
        },
        {
          "language": "",
          "code": "json:\"artist\"",
          "element": "<code>json:\"artist\"</code>"
        },
        {
          "language": "",
          "code": "// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `json:\"price\"`\n}",
          "element": "<pre><code>// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `js..."
        },
        {
          "language": "",
          "code": "// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `json:\"price\"`\n}",
          "element": "<code>// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `json:\"p..."
        },
        {
          "language": "",
          "code": "// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulligan\", Price: 17.99},\n    {ID: \"3\", Title: \"Sarah Vaughan and Clifford Brown\", Artist: \"Sarah Vaughan\", Price: 39.99},\n}",
          "element": "<pre><code>// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulli..."
        },
        {
          "language": "",
          "code": "// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulligan\", Price: 17.99},\n    {ID: \"3\", Title: \"Sarah Vaughan and Clifford Brown\", Artist: \"Sarah Vaughan\", Price: 39.99},\n}",
          "element": "<code>// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulligan\",..."
        },
        {
          "language": "",
          "code": "GET /albums",
          "element": "<code>GET /albums</code>"
        },
        {
          "language": "",
          "code": "// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}",
          "element": "<pre><code>// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}",
          "element": "<code>// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}\n</code>"
        },
        {
          "language": "",
          "code": "gin.Context",
          "element": "<code>gin.Context</code>"
        },
        {
          "language": "",
          "code": "gin.Context",
          "element": "<code>gin.Context</code>"
        },
        {
          "language": "",
          "code": "Context.IndentedJSON",
          "element": "<code>Context.IndentedJSON</code>"
        },
        {
          "language": "",
          "code": "Context.IndentedJSON",
          "element": "<code>Context.IndentedJSON</code>"
        },
        {
          "language": "",
          "code": "Context.JSON",
          "element": "<code>Context.JSON</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n\n    router.Run(\"localhost:8080\")\n}",
          "element": "<pre><code>func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n\n    router.Run(\"localhost:8080\")\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n\n    router.Run(\"localhost:8080\")\n}",
          "element": "<code>func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n\n    router.Run(\"localhost:8080\")\n}\n</code>"
        },
        {
          "language": "",
          "code": "getAlbums()",
          "element": "<code>getAlbums()</code>"
        },
        {
          "language": "",
          "code": "http.Server",
          "element": "<code>http.Server</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)",
          "element": "<pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)",
          "element": "<code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\n</code>"
        },
        {
          "language": "",
          "code": "$ go get .\ngo get: added github.com/gin-gonic/gin v1.7.2",
          "element": "<pre><code>$ go get .\ngo get: added github.com/gin-gonic/gin v1.7.2\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get .\ngo get: added github.com/gin-gonic/gin v1.7.2",
          "element": "<code>$ go get .\ngo get: added github.com/gin-gonic/gin v1.7.2\n</code>"
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums",
          "element": "<pre><code>$ curl http://localhost:8080/albums\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums",
          "element": "<code>$ curl http://localhost:8080/albums\n</code>"
        },
        {
          "language": "",
          "code": "[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\": \"2\",\n                \"title\": \"Jeru\",\n                \"artist\": \"Gerry Mulligan\",\n                \"price\": 17.99\n        },\n        {\n                \"id\": \"3\",\n                \"title\": \"Sarah Vaughan and Clifford Brown\",\n                \"artist\": \"Sarah Vaughan\",\n                \"price\": 39.99\n        }\n]",
          "element": "<pre><code>[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                ..."
        },
        {
          "language": "",
          "code": "[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\": \"2\",\n                \"title\": \"Jeru\",\n                \"artist\": \"Gerry Mulligan\",\n                \"price\": 17.99\n        },\n        {\n                \"id\": \"3\",\n                \"title\": \"Sarah Vaughan and Clifford Brown\",\n                \"artist\": \"Sarah Vaughan\",\n                \"price\": 39.99\n        }\n]",
          "element": "<code>[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\":..."
        },
        {
          "language": "",
          "code": "// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlbum.\n    if err := c.BindJSON(&newAlbum); err != nil {\n        return\n    }\n\n    // Add the new album to the slice.\n    albums = append(albums, newAlbum)\n    c.IndentedJSON(http.StatusCreated, newAlbum)\n}",
          "element": "<pre><code>// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlb..."
        },
        {
          "language": "",
          "code": "// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlbum.\n    if err := c.BindJSON(&newAlbum); err != nil {\n        return\n    }\n\n    // Add the new album to the slice.\n    albums = append(albums, newAlbum)\n    c.IndentedJSON(http.StatusCreated, newAlbum)\n}",
          "element": "<code>// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlbum.\n ..."
        },
        {
          "language": "",
          "code": "Context.BindJSON",
          "element": "<code>Context.BindJSON</code>"
        },
        {
          "language": "",
          "code": "router.POST",
          "element": "<code>router.POST</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}",
          "element": "<pre><code>func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}",
          "element": "<code>func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}\n</code>"
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums \\\n    --include \\\n    --header \"Content-Type: application/json\" \\\n    --request \"POST\" \\\n    --data '{\"id\": \"4\",\"title\": \"The Modern Sound of Betty Carter\",\"artist\": \"Betty Carter\",\"price\": 49.99}'",
          "element": "<pre><code>$ curl http://localhost:8080/albums \\\n    --include \\\n    --header \"Content-Type: application/json\" \\\n    --request \"POST\" \\\n    --data '{\"id\": \"4\",\"title\": \"The Modern Sound of Betty Carte..."
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums \\\n    --include \\\n    --header \"Content-Type: application/json\" \\\n    --request \"POST\" \\\n    --data '{\"id\": \"4\",\"title\": \"The Modern Sound of Betty Carter\",\"artist\": \"Betty Carter\",\"price\": 49.99}'",
          "element": "<code>$ curl http://localhost:8080/albums \\\n    --include \\\n    --header \"Content-Type: application/json\" \\\n    --request \"POST\" \\\n    --data '{\"id\": \"4\",\"title\": \"The Modern Sound of Betty Carter\",\"a..."
        },
        {
          "language": "",
          "code": "HTTP/1.1 201 Created\nContent-Type: application/json; charset=utf-8\nDate: Wed, 02 Jun 2021 00:34:12 GMT\nContent-Length: 116\n\n{\n    \"id\": \"4\",\n    \"title\": \"The Modern Sound of Betty Carter\",\n    \"artist\": \"Betty Carter\",\n    \"price\": 49.99\n}",
          "element": "<pre><code>HTTP/1.1 201 Created\nContent-Type: application/json; charset=utf-8\nDate: Wed, 02 Jun 2021 00:34:12 GMT\nContent-Length: 116\n\n{\n    \"id\": \"4\",\n    \"title\": \"The Modern Sound of Betty Carter\",..."
        },
        {
          "language": "",
          "code": "HTTP/1.1 201 Created\nContent-Type: application/json; charset=utf-8\nDate: Wed, 02 Jun 2021 00:34:12 GMT\nContent-Length: 116\n\n{\n    \"id\": \"4\",\n    \"title\": \"The Modern Sound of Betty Carter\",\n    \"artist\": \"Betty Carter\",\n    \"price\": 49.99\n}",
          "element": "<code>HTTP/1.1 201 Created\nContent-Type: application/json; charset=utf-8\nDate: Wed, 02 Jun 2021 00:34:12 GMT\nContent-Length: 116\n\n{\n    \"id\": \"4\",\n    \"title\": \"The Modern Sound of Betty Carter\",\n    ..."
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums \\\n    --header \"Content-Type: application/json\" \\\n    --request \"GET\"",
          "element": "<pre><code>$ curl http://localhost:8080/albums \\\n    --header \"Content-Type: application/json\" \\\n    --request \"GET\"\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums \\\n    --header \"Content-Type: application/json\" \\\n    --request \"GET\"",
          "element": "<code>$ curl http://localhost:8080/albums \\\n    --header \"Content-Type: application/json\" \\\n    --request \"GET\"\n</code>"
        },
        {
          "language": "",
          "code": "[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\": \"2\",\n                \"title\": \"Jeru\",\n                \"artist\": \"Gerry Mulligan\",\n                \"price\": 17.99\n        },\n        {\n                \"id\": \"3\",\n                \"title\": \"Sarah Vaughan and Clifford Brown\",\n                \"artist\": \"Sarah Vaughan\",\n                \"price\": 39.99\n        },\n        {\n                \"id\": \"4\",\n                \"title\": \"The Modern Sound of Betty Carter\",\n                \"artist\": \"Betty Carter\",\n                \"price\": 49.99\n        }\n]",
          "element": "<pre><code>[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                ..."
        },
        {
          "language": "",
          "code": "[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\": \"2\",\n                \"title\": \"Jeru\",\n                \"artist\": \"Gerry Mulligan\",\n                \"price\": 17.99\n        },\n        {\n                \"id\": \"3\",\n                \"title\": \"Sarah Vaughan and Clifford Brown\",\n                \"artist\": \"Sarah Vaughan\",\n                \"price\": 39.99\n        },\n        {\n                \"id\": \"4\",\n                \"title\": \"The Modern Sound of Betty Carter\",\n                \"artist\": \"Betty Carter\",\n                \"price\": 49.99\n        }\n]",
          "element": "<code>[\n        {\n                \"id\": \"1\",\n                \"title\": \"Blue Train\",\n                \"artist\": \"John Coltrane\",\n                \"price\": 56.99\n        },\n        {\n                \"id\":..."
        },
        {
          "language": "",
          "code": "GET /albums/[id]",
          "element": "<code>GET /albums/[id]</code>"
        },
        {
          "language": "",
          "code": "getAlbumByID",
          "element": "<code>getAlbumByID</code>"
        },
        {
          "language": "",
          "code": "// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param(\"id\")\n\n    // Loop over the list of albums, looking for\n    // an album whose ID value matches the parameter.\n    for _, a := range albums {\n        if a.ID == id {\n            c.IndentedJSON(http.StatusOK, a)\n            return\n        }\n    }\n    c.IndentedJSON(http.StatusNotFound, gin.H{\"message\": \"album not found\"})\n}",
          "element": "<pre><code>// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param..."
        },
        {
          "language": "",
          "code": "// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param(\"id\")\n\n    // Loop over the list of albums, looking for\n    // an album whose ID value matches the parameter.\n    for _, a := range albums {\n        if a.ID == id {\n            c.IndentedJSON(http.StatusOK, a)\n            return\n        }\n    }\n    c.IndentedJSON(http.StatusNotFound, gin.H{\"message\": \"album not found\"})\n}",
          "element": "<code>// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param(\"id\"..."
        },
        {
          "language": "",
          "code": "Context.Param",
          "element": "<code>Context.Param</code>"
        },
        {
          "language": "",
          "code": "http.StatusNotFound",
          "element": "<code>http.StatusNotFound</code>"
        },
        {
          "language": "",
          "code": "/albums/:id",
          "element": "<code>/albums/:id</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}",
          "element": "<pre><code>func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:..."
        },
        {
          "language": "",
          "code": "func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}",
          "element": "<code>func main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\"..."
        },
        {
          "language": "",
          "code": "/albums/:id",
          "element": "<code>/albums/:id</code>"
        },
        {
          "language": "",
          "code": "getAlbumByID",
          "element": "<code>getAlbumByID</code>"
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums/2",
          "element": "<pre><code>$ curl http://localhost:8080/albums/2\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ curl http://localhost:8080/albums/2",
          "element": "<code>$ curl http://localhost:8080/albums/2\n</code>"
        },
        {
          "language": "",
          "code": "{\n        \"id\": \"2\",\n        \"title\": \"Jeru\",\n        \"artist\": \"Gerry Mulligan\",\n        \"price\": 17.99\n}",
          "element": "<pre><code>{\n        \"id\": \"2\",\n        \"title\": \"Jeru\",\n        \"artist\": \"Gerry Mulligan\",\n        \"price\": 17.99\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "{\n        \"id\": \"2\",\n        \"title\": \"Jeru\",\n        \"artist\": \"Gerry Mulligan\",\n        \"price\": 17.99\n}",
          "element": "<code>{\n        \"id\": \"2\",\n        \"title\": \"Jeru\",\n        \"artist\": \"Gerry Mulligan\",\n        \"price\": 17.99\n}\n</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\n\n// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `json:\"price\"`\n}\n\n// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulligan\", Price: 17.99},\n    {ID: \"3\", Title: \"Sarah Vaughan and Clifford Brown\", Artist: \"Sarah Vaughan\", Price: 39.99},\n}\n\nfunc main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}\n\n// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}\n\n// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlbum.\n    if err := c.BindJSON(&newAlbum); err != nil {\n        return\n    }\n\n    // Add the new album to the slice.\n    albums = append(albums, newAlbum)\n    c.IndentedJSON(http.StatusCreated, newAlbum)\n}\n\n// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param(\"id\")\n\n    // Loop through the list of albums, looking for\n    // an album whose ID value matches the parameter.\n    for _, a := range albums {\n        if a.ID == id {\n            c.IndentedJSON(http.StatusOK, a)\n            return\n        }\n    }\n    c.IndentedJSON(http.StatusNotFound, gin.H{\"message\": \"album not found\"})\n}",
          "element": "<pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\n\n// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string ..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\n\n// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `json:\"title\"`\n    Artist string  `json:\"artist\"`\n    Price  float64 `json:\"price\"`\n}\n\n// albums slice to seed record album data.\nvar albums = []album{\n    {ID: \"1\", Title: \"Blue Train\", Artist: \"John Coltrane\", Price: 56.99},\n    {ID: \"2\", Title: \"Jeru\", Artist: \"Gerry Mulligan\", Price: 17.99},\n    {ID: \"3\", Title: \"Sarah Vaughan and Clifford Brown\", Artist: \"Sarah Vaughan\", Price: 39.99},\n}\n\nfunc main() {\n    router := gin.Default()\n    router.GET(\"/albums\", getAlbums)\n    router.GET(\"/albums/:id\", getAlbumByID)\n    router.POST(\"/albums\", postAlbums)\n\n    router.Run(\"localhost:8080\")\n}\n\n// getAlbums responds with the list of all albums as JSON.\nfunc getAlbums(c *gin.Context) {\n    c.IndentedJSON(http.StatusOK, albums)\n}\n\n// postAlbums adds an album from JSON received in the request body.\nfunc postAlbums(c *gin.Context) {\n    var newAlbum album\n\n    // Call BindJSON to bind the received JSON to\n    // newAlbum.\n    if err := c.BindJSON(&newAlbum); err != nil {\n        return\n    }\n\n    // Add the new album to the slice.\n    albums = append(albums, newAlbum)\n    c.IndentedJSON(http.StatusCreated, newAlbum)\n}\n\n// getAlbumByID locates the album whose ID value matches the id\n// parameter sent by the client, then returns that album as a response.\nfunc getAlbumByID(c *gin.Context) {\n    id := c.Param(\"id\")\n\n    // Loop through the list of albums, looking for\n    // an album whose ID value matches the parameter.\n    for _, a := range albums {\n        if a.ID == id {\n            c.IndentedJSON(http.StatusOK, a)\n            return\n        }\n    }\n    c.IndentedJSON(http.StatusNotFound, gin.H{\"message\": \"album not found\"})\n}",
          "element": "<code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n)\n\n// album represents data about a record album.\ntype album struct {\n    ID     string  `json:\"id\"`\n    Title  string  `jso..."
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Tutorial: Developing a RESTful API with Go and Gin",
          "id": ""
        },
        {
          "level": 2,
          "text": "Prerequisites",
          "id": "prerequisites"
        },
        {
          "level": 2,
          "text": "Design API endpoints",
          "id": "design_endpoints"
        },
        {
          "level": 2,
          "text": "Create a folder for your code",
          "id": "create_folder"
        },
        {
          "level": 2,
          "text": "Create the data",
          "id": "create_data"
        },
        {
          "level": 2,
          "text": "Write a handler to return all items",
          "id": "all_items"
        },
        {
          "level": 2,
          "text": "Write a handler to add a new item",
          "id": "add_item"
        },
        {
          "level": 2,
          "text": "Write a handler to return a specific item",
          "id": "specific_item"
        },
        {
          "level": 2,
          "text": "Conclusion",
          "id": "conclusion"
        },
        {
          "level": 2,
          "text": "Completed code",
          "id": "completed_code"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-1"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-2"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-1"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-3"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-2"
        }
      ],
      "timestamp": 1750757585.6391768
    },
    {
      "url": "https://golang.org/doc/tutorial/generics.html",
      "title": "Tutorial: Getting started with generics - The Go Programming Language",
      "content": "Documentation\nTutorials\nTutorial: Getting started with generics\nTutorial: Getting started with generics\nThis tutorial introduces the basics of generics in Go. With generics, you can\ndeclare and use functions or types that are written to work with any of a set\nof types provided by calling code.\nIn this tutorial, youll declare two simple non-generic functions, then capture\nthe same logic in a single generic function.\nYoull progress through the following sections:\nCreate a folder for your code.\nAdd non-generic functions.\nAdd a generic function to handle multiple types.\nRemove type arguments when calling the generic function.\nDeclare a type constraint.\nNote:\nFor other tutorials, see\nTutorials\n.\nNote:\nIf you prefer, you can use\nthe Go playground in Go dev branch mode\nto edit and run your program instead.\nPrerequisites\nAn installation of Go 1.18 or later.\nFor installation instructions, see\nInstalling Go\n.\nA tool to edit your code.\nAny text editor you have will work fine.\nA command terminal.\nGo works well using any terminal on Linux and Mac,\nand on PowerShell or cmd in Windows.\nCreate a folder for your code\nTo begin, create a folder for the code youll write.\nOpen a command prompt and change to your home directory.\nOn Linux or Mac:\n$ cd\nOn Windows:\nC:\\> cd %HOMEPATH%\nThe rest of the tutorial will show a $ as the prompt. The commands you use\nwill work on Windows too.\nFrom the command prompt, create a directory for your code called generics.\n$ mkdir generics\n$ cd generics\nCreate a module to hold your code.\nRun the\ngo mod init\ncommand, giving it your new codes module path.\n$ go mod init example/generics\ngo: creating new go.mod: module example/generics\nNote:\nFor production code, youd specify a module path thats more specific\nto your own needs. For more, be sure to see\nManaging dependencies\n.\nNext, youll add some simple code to work with maps.\nAdd non-generic functions\nIn this step, youll add two functions that each add together the values of a\nmap and return the total.\nYoure declaring two functions instead of one because youre working with two\ndifferent types of maps: one that stores\nint64\nvalues, and one that stores\nfloat64\nvalues.\nWrite the code\nUsing your text editor, create a file called main.go in the generics\ndirectory. Youll write your Go code in this file.\nInto main.go, at the top of the file, paste the following package\ndeclaration.\npackage main\nA standalone program (as opposed to a library) is always in package\nmain\n.\nBeneath the package declaration, paste the following two function\ndeclarations.\n// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together the values of m.\nfunc SumFloats(m map[string]float64) float64 {\n    var s float64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\nIn this code, you:\nDeclare two functions to add together the values of a map and return\nthe sum.\nSumFloats\ntakes a map of\nstring\nto\nfloat64\nvalues.\nSumInts\ntakes a map of\nstring\nto\nint64\nvalues.\nAt the top of main.go, beneath the package declaration, paste the following\nmain\nfunction to initialize the two maps and use them as arguments when\ncalling the functions you declared in the preceding step.\nfunc main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\":  34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n    floats := map[string]float64{\n        \"first\":  35.98,\n        \"second\": 26.99,\n    }\n\n    fmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\n        SumInts(ints),\n        SumFloats(floats))\n}\nIn this code, you:\nInitialize a map of\nfloat64\nvalues and a map of\nint64\nvalues, each\nwith two entries.\nCall the two functions you declared earlier to find the sum of each\nmaps values.\nPrint the result.\nNear the top of main.go, just beneath the package declaration, import the\npackage youll need to support the code youve just written.\nThe first lines of code should look like this:\npackage main\n\nimport \"fmt\"\nSave main.go.\nRun the code\nFrom the command line in the directory containing main.go, run the code.\n$ go run .\nNon-Generic Sums: 46 and 62.97\nWith generics, you can write one function here instead of two. Next, youll\nadd a single generic function for maps containing either integer or float values.\nAdd a generic function to handle multiple types\nIn this section, youll add a single generic function that can receive a map\ncontaining either integer or float values, effectively replacing the two\nfunctions you just wrote with a single function.\nTo support values of either type, that single function will need a way to\ndeclare what types it supports. Calling code, on the other hand, will need a\nway to specify whether it is calling with an integer or float map.\nTo support this, youll write a function that declares\ntype parameters\nin\naddition to its ordinary function parameters. These type parameters make the\nfunction generic, enabling it to work with arguments of different types. Youll\ncall the function with\ntype arguments\nand ordinary function arguments.\nEach type parameter has a\ntype constraint\nthat acts as a kind of meta-type\nfor the type parameter. Each type constraint specifies the permissible type\narguments that calling code can use for the respective type parameter.\nWhile a type parameters constraint typically represents a set of types, at\ncompile time the type parameter stands for a single type  the type provided\nas a type argument by the calling code. If the type arguments type isnt\nallowed by the type parameters constraint, the code wont compile.\nKeep in mind that a type parameter must support all the operations the generic\ncode is performing on it. For example, if your functions code were to try to\nperform\nstring\noperations (such as indexing) on a type parameter whose\nconstraint included numeric types, the code wouldnt compile.\nIn the code youre about to write, youll use a constraint that allows either\ninteger or float types.\nWrite the code\nBeneath the two functions you added previously, paste the following generic\nfunction.\n// SumIntsOrFloats sums the values of map m. It supports both int64 and float64\n// as types for map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\nIn this code, you:\nDeclare a\nSumIntsOrFloats\nfunction with two type parameters (inside\nthe square brackets),\nK\nand\nV\n, and one argument that uses the type\nparameters,\nm\nof type\nmap[K]V\n. The function returns a value of\ntype\nV\n.\nSpecify for the\nK\ntype parameter the type constraint\ncomparable\n.\nIntended specifically for cases like these, the\ncomparable\nconstraint\nis predeclared in Go. It allows any type whose values may be used as an\noperand of the comparison operators\n==\nand\n!=\n. Go requires that map\nkeys be comparable. So declaring\nK\nas\ncomparable\nis necessary so you\ncan use\nK\nas the key in the map variable. It also ensures that calling\ncode uses an allowable type for map keys.\nSpecify for the\nV\ntype parameter a constraint that is a union of two\ntypes:\nint64\nand\nfloat64\n. Using\n|\nspecifies a union of the two\ntypes, meaning that this constraint allows either type. Either type\nwill be permitted by the compiler as an argument in the calling code.\nSpecify that the\nm\nargument is of type\nmap[K]V\n, where\nK\nand\nV\nare the types already specified for the type parameters. Note that we\nknow\nmap[K]V\nis a valid map type because\nK\nis a comparable type. If\nwe hadnt declared\nK\ncomparable, the compiler would reject the\nreference to\nmap[K]V\n.\nIn main.go, beneath the code you already have, paste the following code.\nfmt.Printf(\"Generic Sums: %v and %v\\n\",\n    SumIntsOrFloats[string, int64](ints),\n    SumIntsOrFloats[string, float64](floats))\nIn this code, you:\nCall the generic function you just declared, passing each of the maps\nyou created.\nSpecify type arguments  the type names in square brackets  to be\nclear about the types that should replace type parameters in the\nfunction youre calling.\nAs youll see in the next section, you can often omit the type\narguments in the function call. Go can often infer them from your code.\nPrint the sums returned by the function.\nRun the code\nFrom the command line in the directory containing main.go, run the code.\n$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nTo run your code, in each call the compiler replaced the type parameters with\nthe concrete types specified in that call.\nIn calling the generic function you wrote, you specified type arguments that\ntold the compiler what types to use in place of the functions type parameters.\nAs youll see in the next section, in many cases you can omit these type\narguments because the compiler can infer them.\nRemove type arguments when calling the generic function\nIn this section, youll add a modified version of the generic function call,\nmaking a small change to simplify the calling code. Youll remove the type\narguments, which arent needed in this case.\nYou can omit type arguments in calling code when the Go compiler can infer the\ntypes you want to use. The compiler infers type arguments from the types of\nfunction arguments.\nNote that this isnt always possible. For example, if you needed to call a\ngeneric function that had no arguments, you would need to include the type\narguments in the function call.\nWrite the code\nIn main.go, beneath the code you already have, paste the following code.\nfmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n    SumIntsOrFloats(ints),\n    SumIntsOrFloats(floats))\nIn this code, you:\nCall the generic function, omitting the type arguments.\nRun the code\nFrom the command line in the directory containing main.go, run the code.\n$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\nNext, youll further simplify the function by capturing the union of integers\nand floats into a type constraint you can reuse, such as from other code.\nDeclare a type constraint\nIn this last section, youll move the constraint you defined earlier into its\nown interface so that you can reuse it in multiple places. Declaring\nconstraints in this way helps streamline code, such as when a constraint is\nmore complex.\nYou declare a\ntype constraint\nas an interface. The constraint allows any\ntype implementing the interface. For example, if you declare a type constraint\ninterface with three methods, then use it with a type parameter in a generic\nfunction, type arguments used to call the function must have all of those\nmethods.\nConstraint interfaces can also refer to specific types, as youll see in this\nsection.\nWrite the code\nJust above\nmain\n, immediately after the import statements, paste the\nfollowing code to declare a type constraint.\ntype Number interface {\n    int64 | float64\n}\nIn this code, you:\nDeclare the\nNumber\ninterface type to use as a type constraint.\nDeclare a union of\nint64\nand\nfloat64\ninside the interface.\nEssentially, youre moving the union from the function declaration\ninto a new type constraint. That way, when you want to constrain a type\nparameter to either\nint64\nor\nfloat64\n, you can use this\nNumber\ntype constraint instead of writing out\nint64 | float64\n.\nBeneath the functions you already have, paste the following generic\nSumNumbers\nfunction.\n// SumNumbers sums the values of map m. It supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\nIn this code, you:\nDeclare a generic function with the same logic as the generic function\nyou declared previously, but with the new interface type instead of the\nunion as the type constraint. As before, you use the type parameters\nfor the argument and return types.\nIn main.go, beneath the code you already have, paste the following code.\nfmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n    SumNumbers(ints),\n    SumNumbers(floats))\nIn this code, you:\nCall\nSumNumbers\nwith each map, printing the sum from the values of\neach.\nAs in the preceding section, you omit the type arguments (the type\nnames in square brackets) in calls to the generic function. The Go\ncompiler can infer the type argument from other arguments.\nRun the code\nFrom the command line in the directory containing main.go, run the code.\n$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\nGeneric Sums with Constraint: 46 and 62.97\nConclusion\nNicely done! Youve just introduced yourself to generics in Go.\nSuggested next topics:\nThe\nGo Tour\nis a great step-by-step\nintroduction to Go fundamentals.\nYoull find useful Go best practices described in\nEffective Go\nand\nHow to write Go code\n.\nCompleted code\nYou can run this program in the\nGo playground\n. On the\nplayground simply click the\nRun\nbutton.\npackage main\n\nimport \"fmt\"\n\ntype Number interface {\n    int64 | float64\n}\n\nfunc main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\": 34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n    floats := map[string]float64{\n        \"first\": 35.98,\n        \"second\": 26.99,\n    }\n\n    fmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\n        SumInts(ints),\n        SumFloats(floats))\n\n    fmt.Printf(\"Generic Sums: %v and %v\\n\",\n        SumIntsOrFloats[string, int64](ints),\n        SumIntsOrFloats[string, float64](floats))\n\n    fmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n        SumIntsOrFloats(ints),\n        SumIntsOrFloats(floats))\n\n    fmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n        SumNumbers(ints),\n        SumNumbers(floats))\n}\n\n// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together the values of m.\nfunc SumFloats(m map[string]float64) float64 {\n    var s float64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumIntsOrFloats sums the values of map m. It supports both floats and integers\n// as map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumNumbers sums the values of map m. Its supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
      "code_examples": [
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<pre><code>C:\\&gt; cd %HOMEPATH%\n</code></pre>"
        },
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<code>C:\\&gt; cd %HOMEPATH%\n</code>"
        },
        {
          "language": "",
          "code": "$ mkdir generics\n$ cd generics",
          "element": "<pre><code>$ mkdir generics\n$ cd generics\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ mkdir generics\n$ cd generics",
          "element": "<code>$ mkdir generics\n$ cd generics\n</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "$ go mod init example/generics\ngo: creating new go.mod: module example/generics",
          "element": "<pre><code>$ go mod init example/generics\ngo: creating new go.mod: module example/generics\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod init example/generics\ngo: creating new go.mod: module example/generics",
          "element": "<code>$ go mod init example/generics\ngo: creating new go.mod: module example/generics\n</code>"
        },
        {
          "language": "",
          "code": "package main",
          "element": "<pre><code>package main\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main",
          "element": "<code>package main\n</code>"
        },
        {
          "language": "",
          "code": "// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together the values of m.\nfunc SumFloats(m map[string]float64) float64 {\n    var s float64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<pre><code>// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together ..."
        },
        {
          "language": "",
          "code": "// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together the values of m.\nfunc SumFloats(m map[string]float64) float64 {\n    var s float64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<code>// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together the v..."
        },
        {
          "language": "",
          "code": "func main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\":  34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n    floats := map[string]float64{\n        \"first\":  35.98,\n        \"second\": 26.99,\n    }\n\n    fmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\n        SumInts(ints),\n        SumFloats(floats))\n}",
          "element": "<pre><code>func main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\":  34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n  ..."
        },
        {
          "language": "",
          "code": "func main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\":  34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n    floats := map[string]float64{\n        \"first\":  35.98,\n        \"second\": 26.99,\n    }\n\n    fmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\n        SumInts(ints),\n        SumFloats(floats))\n}",
          "element": "<code>func main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\":  34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n    flo..."
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"",
          "element": "<pre><code>package main\n\nimport \"fmt\"\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"",
          "element": "<code>package main\n\nimport \"fmt\"\n</code>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97",
          "element": "<pre><code>$ go run .\nNon-Generic Sums: 46 and 62.97\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97",
          "element": "<code>$ go run .\nNon-Generic Sums: 46 and 62.97\n</code>"
        },
        {
          "language": "",
          "code": "// SumIntsOrFloats sums the values of map m. It supports both int64 and float64\n// as types for map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<pre><code>// SumIntsOrFloats sums the values of map m. It supports both int64 and float64\n// as types for map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n..."
        },
        {
          "language": "",
          "code": "// SumIntsOrFloats sums the values of map m. It supports both int64 and float64\n// as types for map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<code>// SumIntsOrFloats sums the values of map m. It supports both int64 and float64\n// as types for map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n    f..."
        },
        {
          "language": "",
          "code": "SumIntsOrFloats",
          "element": "<code>SumIntsOrFloats</code>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"Generic Sums: %v and %v\\n\",\n    SumIntsOrFloats[string, int64](ints),\n    SumIntsOrFloats[string, float64](floats))",
          "element": "<pre><code>fmt.Printf(\"Generic Sums: %v and %v\\n\",\n    SumIntsOrFloats[string, int64](ints),\n    SumIntsOrFloats[string, float64](floats))\n</code></pre>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"Generic Sums: %v and %v\\n\",\n    SumIntsOrFloats[string, int64](ints),\n    SumIntsOrFloats[string, float64](floats))",
          "element": "<code>fmt.Printf(\"Generic Sums: %v and %v\\n\",\n    SumIntsOrFloats[string, int64](ints),\n    SumIntsOrFloats[string, float64](floats))\n</code>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97",
          "element": "<pre><code>$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97",
          "element": "<code>$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\n</code>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n    SumIntsOrFloats(ints),\n    SumIntsOrFloats(floats))",
          "element": "<pre><code>fmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n    SumIntsOrFloats(ints),\n    SumIntsOrFloats(floats))\n</code></pre>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n    SumIntsOrFloats(ints),\n    SumIntsOrFloats(floats))",
          "element": "<code>fmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n    SumIntsOrFloats(ints),\n    SumIntsOrFloats(floats))\n</code>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97",
          "element": "<pre><code>$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97",
          "element": "<code>$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\n</code>"
        },
        {
          "language": "",
          "code": "type Number interface {\n    int64 | float64\n}",
          "element": "<pre><code>type Number interface {\n    int64 | float64\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "type Number interface {\n    int64 | float64\n}",
          "element": "<code>type Number interface {\n    int64 | float64\n}\n</code>"
        },
        {
          "language": "",
          "code": "int64 | float64",
          "element": "<code>int64 | float64</code>"
        },
        {
          "language": "",
          "code": "// SumNumbers sums the values of map m. It supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<pre><code>// SumNumbers sums the values of map m. It supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n ..."
        },
        {
          "language": "",
          "code": "// SumNumbers sums the values of map m. It supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<code>// SumNumbers sums the values of map m. It supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n      ..."
        },
        {
          "language": "",
          "code": "fmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n    SumNumbers(ints),\n    SumNumbers(floats))",
          "element": "<pre><code>fmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n    SumNumbers(ints),\n    SumNumbers(floats))\n</code></pre>"
        },
        {
          "language": "",
          "code": "fmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n    SumNumbers(ints),\n    SumNumbers(floats))",
          "element": "<code>fmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n    SumNumbers(ints),\n    SumNumbers(floats))\n</code>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\nGeneric Sums with Constraint: 46 and 62.97",
          "element": "<pre><code>$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\nGeneric Sums with Constraint: 46 and 62.97\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\nGeneric Sums with Constraint: 46 and 62.97",
          "element": "<code>$ go run .\nNon-Generic Sums: 46 and 62.97\nGeneric Sums: 46 and 62.97\nGeneric Sums, type parameters inferred: 46 and 62.97\nGeneric Sums with Constraint: 46 and 62.97\n</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"\n\ntype Number interface {\n    int64 | float64\n}\n\nfunc main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\": 34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n    floats := map[string]float64{\n        \"first\": 35.98,\n        \"second\": 26.99,\n    }\n\n    fmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\n        SumInts(ints),\n        SumFloats(floats))\n\n    fmt.Printf(\"Generic Sums: %v and %v\\n\",\n        SumIntsOrFloats[string, int64](ints),\n        SumIntsOrFloats[string, float64](floats))\n\n    fmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n        SumIntsOrFloats(ints),\n        SumIntsOrFloats(floats))\n\n    fmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n        SumNumbers(ints),\n        SumNumbers(floats))\n}\n\n// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together the values of m.\nfunc SumFloats(m map[string]float64) float64 {\n    var s float64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumIntsOrFloats sums the values of map m. It supports both floats and integers\n// as map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumNumbers sums the values of map m. Its supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<pre><code>package main\n\nimport \"fmt\"\n\ntype Number interface {\n    int64 | float64\n}\n\nfunc main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\": 34,\n  ..."
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"\n\ntype Number interface {\n    int64 | float64\n}\n\nfunc main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\": 34,\n        \"second\": 12,\n    }\n\n    // Initialize a map for the float values\n    floats := map[string]float64{\n        \"first\": 35.98,\n        \"second\": 26.99,\n    }\n\n    fmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\n        SumInts(ints),\n        SumFloats(floats))\n\n    fmt.Printf(\"Generic Sums: %v and %v\\n\",\n        SumIntsOrFloats[string, int64](ints),\n        SumIntsOrFloats[string, float64](floats))\n\n    fmt.Printf(\"Generic Sums, type parameters inferred: %v and %v\\n\",\n        SumIntsOrFloats(ints),\n        SumIntsOrFloats(floats))\n\n    fmt.Printf(\"Generic Sums with Constraint: %v and %v\\n\",\n        SumNumbers(ints),\n        SumNumbers(floats))\n}\n\n// SumInts adds together the values of m.\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumFloats adds together the values of m.\nfunc SumFloats(m map[string]float64) float64 {\n    var s float64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumIntsOrFloats sums the values of map m. It supports both floats and integers\n// as map values.\nfunc SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\n// SumNumbers sums the values of map m. Its supports both integers\n// and floats as map values.\nfunc SumNumbers[K comparable, V Number](m map[K]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}",
          "element": "<code>package main\n\nimport \"fmt\"\n\ntype Number interface {\n    int64 | float64\n}\n\nfunc main() {\n    // Initialize a map for the integer values\n    ints := map[string]int64{\n        \"first\": 34,\n       ..."
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Tutorial: Getting started with generics",
          "id": ""
        },
        {
          "level": 2,
          "text": "Prerequisites",
          "id": "prerequisites"
        },
        {
          "level": 2,
          "text": "Create a folder for your code",
          "id": "create_folder"
        },
        {
          "level": 2,
          "text": "Add non-generic functions",
          "id": "non_generic_functions"
        },
        {
          "level": 2,
          "text": "Add a generic function to handle multiple types",
          "id": "add_generic_function"
        },
        {
          "level": 2,
          "text": "Remove type arguments when calling the generic function",
          "id": "remove_type_arguments"
        },
        {
          "level": 2,
          "text": "Declare a type constraint",
          "id": "declare_type_constraint"
        },
        {
          "level": 2,
          "text": "Conclusion",
          "id": "conclusion"
        },
        {
          "level": 2,
          "text": "Completed code",
          "id": "completed_code"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-1"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-1"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-2"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-2"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-3"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-3"
        }
      ],
      "timestamp": 1750757589.858641
    },
    {
      "url": "https://golang.org/doc/tutorial/fuzz.html",
      "title": "Tutorial: Getting started with fuzzing - The Go Programming Language",
      "content": "Documentation\nTutorials\nTutorial: Getting started with fuzzing\nTutorial: Getting started with fuzzing\nThis tutorial introduces the basics of fuzzing in Go. With fuzzing, random data\nis run against your test in an attempt to find vulnerabilities or crash-causing\ninputs. Some examples of vulnerabilities that can be found by fuzzing are SQL\ninjection, buffer overflow, denial of service and cross-site scripting attacks.\nIn this tutorial, youll write a fuzz test for a simple function, run the go\ncommand, and debug and fix issues in the code.\nFor help with terminology throughout this tutorial, see the\nGo Fuzzing\nglossary\n.\nYoull progress through the following sections:\nCreate a folder for your code.\nAdd code to test.\nAdd a unit test.\nAdd a fuzz test.\nFix two bugs.\nExplore additional resources.\nNote:\nFor other tutorials, see\nTutorials\n.\nNote:\nGo fuzzing currently supports a subset of built-in types, listed in\nthe\nGo Fuzzing docs\n, with support for more built-in\ntypes to be added in the future.\nPrerequisites\nAn installation of Go 1.18 or later.\nFor installation instructions, see\nInstalling Go\n.\nA tool to edit your code.\nAny text editor you have will work fine.\nA command terminal.\nGo works well using any terminal on Linux and Mac, and\non PowerShell or cmd in Windows.\nAn environment that supports fuzzing.\nGo fuzzing with coverage\ninstrumentation is only available on AMD64 and ARM64 architectures currently.\nCreate a folder for your code\nTo begin, create a folder for the code youll write.\nOpen a command prompt and change to your home directory.\nOn Linux or Mac:\n$ cd\nOn Windows:\nC:\\> cd %HOMEPATH%\nThe rest of the tutorial will show a $ as the prompt. The commands you use\nwill work on Windows too.\nFrom the command prompt, create a directory for your code called fuzz.\n$ mkdir fuzz\n$ cd fuzz\nCreate a module to hold your code.\nRun the\ngo mod init\ncommand, giving it your new codes module path.\n$ go mod init example/fuzz\ngo: creating new go.mod: module example/fuzz\nNote:\nFor production code, youd specify a module path thats more\nspecific to your own needs. For more, be sure to see\nManaging\ndependencies\n.\nNext, youll add some simple code to reverse a string, which well fuzz later.\nAdd code to test\nIn this step, youll add a function to reverse a string.\nWrite the code\nUsing your text editor, create a file called main.go in the fuzz directory.\nInto main.go, at the top of the file, paste the following package\ndeclaration.\npackage main\nA standalone program (as opposed to a library) is always in package\nmain\n.\nBeneath the package declaration, paste the following function declaration.\nfunc Reverse(s string) string {\n    b := []byte(s)\n    for i, j := 0, len(b)-1; i < len(b)/2; i, j = i+1, j-1 {\n        b[i], b[j] = b[j], b[i]\n    }\n    return string(b)\n}\nThis function will accept a\nstring\n, loop over it a\nbyte\nat a time, and\nreturn the reversed string at the end.\nNote:\nThis code is based on the\nstringutil.Reverse\nfunction within\ngolang.org/x/example.\nAt the top of main.go, beneath the package declaration, paste the following\nmain\nfunction to initialize a string, reverse it, print the output, and\nrepeat.\nfunc main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev := Reverse(input)\n    doubleRev := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q\\n\", rev)\n    fmt.Printf(\"reversed again: %q\\n\", doubleRev)\n}\nThis function will run a few\nReverse\noperations, then print the output to\nthe command line. This can be helpful for seeing the code in action, and\npotentially for debugging.\nThe\nmain\nfunction uses the fmt package, so you will need to import it.\nThe first lines of code should look like this:\npackage main\n\nimport \"fmt\"\nRun the code\nFrom the command line in the directory containing main.go, run the code.\n$ go run .\noriginal: \"The quick brown fox jumped over the lazy dog\"\nreversed: \"god yzal eht revo depmuj xof nworb kciuq ehT\"\nreversed again: \"The quick brown fox jumped over the lazy dog\"\nYou can see the original string, the result of reversing it, then the result of\nreversing it again, which is equivalent to the original.\nNow that the code is running, its time to test it.\nAdd a unit test\nIn this step, you will write a basic unit test for the\nReverse\nfunction.\nWrite the code\nUsing your text editor, create a file called reverse_test.go in the fuzz\ndirectory.\nPaste the following code into reverse_test.go.\npackage main\n\nimport (\n    \"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n    testcases := []struct {\n        in, want string\n    }{\n        {\"Hello, world\", \"dlrow ,olleH\"},\n        {\" \", \" \"},\n        {\"!12345\", \"54321!\"},\n    }\n    for _, tc := range testcases {\n        rev := Reverse(tc.in)\n        if rev != tc.want {\n                t.Errorf(\"Reverse: %q, want %q\", rev, tc.want)\n        }\n    }\n}\nThis simple test will assert that the listed input strings will be correctly\nreversed.\nRun the code\nRun the unit test using\ngo test\n$ go test\nPASS\nok      example/fuzz  0.013s\nNext, you will change the unit test into a fuzz test.\nAdd a fuzz test\nThe unit test has limitations, namely that each input must be added to the test\nby the developer. One benefit of fuzzing is that it comes up with inputs for\nyour code, and may identify edge cases that the test cases you came up with\ndidnt reach.\nIn this section you will convert the unit test to a fuzz test so that you can\ngenerate more inputs with less work!\nNote that you can keep unit tests, benchmarks, and fuzz tests in the same\n*_test.go file, but for this example you will convert the unit test to a fuzz\ntest.\nWrite the code\nIn your text editor, replace the unit test in reverse_test.go with the following\nfuzz test.\nfunc FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev := Reverse(orig)\n        doubleRev := Reverse(rev)\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}\nFuzzing has a few limitations as well. In your unit test, you could predict the\nexpected output of the\nReverse\nfunction, and verify that the actual output met\nthose expectations.\nFor example, in the test case\nReverse(\"Hello, world\")\nthe unit test specifies\nthe return as\n\"dlrow ,olleH\"\n.\nWhen fuzzing, you cant predict the expected output, since you dont have\ncontrol over the inputs.\nHowever, there are a few properties of the\nReverse\nfunction that you can\nverify in a fuzz test. The two properties being checked in this fuzz test are:\nReversing a string twice preserves the original value\nThe reversed string preserves its state as valid UTF-8.\nNote the syntax differences between the unit test and the fuzz test:\nThe function begins with FuzzXxx instead of TestXxx, and takes\n*testing.F\ninstead of\n*testing.T\nWhere you would expect to see a\nt.Run\nexecution, you instead see\nf.Fuzz\nwhich takes a fuzz target function whose parameters are\n*testing.T\nand the\ntypes to be fuzzed. The inputs from your unit test are provided as seed corpus\ninputs using\nf.Add\n.\nEnsure the new package,\nunicode/utf8\nhas been imported.\npackage main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\nWith the unit test converted to a fuzz test, its time to run the test again.\nRun the code\nRun the fuzz test without fuzzing it to make sure the seed inputs pass.\n$ go test\nPASS\nok      example/fuzz  0.013s\nYou can also run\ngo test -run=FuzzReverse\nif you have other tests in that\nfile, and you only wish to run the fuzz test.\nRun\nFuzzReverse\nwith fuzzing, to see if any randomly generated string\ninputs will cause a failure. This is executed using\ngo test\nwith a new\nflag,\n-fuzz\n, set to the parameter\nFuzz\n. Copy the command below.\n$ go test -fuzz=Fuzz\nAnother useful flag is\n-fuzztime\n, which restricts the time fuzzing takes.\nFor example, specifying\n-fuzztime 10s\nin the test below would mean that,\nas long as no failures occurred earlier, the test would exit by default\nafter 10 seconds had elapsed. See\nthis\nsection\nof the cmd/go\ndocumentation to see other testing flags.\nNow, run the command you just copied.\n$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/3 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 3/3 completed, now fuzzing with 8 workers\nfuzz: minimizing 38-byte failing input file...\n--- FAIL: FuzzReverse (0.01s)\n    --- FAIL: FuzzReverse (0.00s)\n        reverse_test.go:20: Reverse produced invalid UTF-8 string \"\\x9c\\xdd\"\n\n    Failing input written to testdata/fuzz/FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a\n    To re-run:\n    go test -run=FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a\nFAIL\nexit status 1\nFAIL    example/fuzz  0.030s\nA failure occurred while fuzzing, and the input that caused the problem is\nwritten to a seed corpus file that will be run the next time\ngo test\nis\ncalled, even without the\n-fuzz\nflag. To view the input that caused the\nfailure, open the corpus file written to the testdata/fuzz/FuzzReverse\ndirectory in a text editor. Your seed corpus file may contain a different\nstring, but the format will be the same.\ngo test fuzz v1\nstring(\"\")\nThe first line of the corpus file indicates the encoding version. Each\nfollowing line represents the value of each type making up the corpus entry.\nSince the fuzz target only takes 1 input, there is only 1 value after the\nversion.\nRun\ngo test\nagain without the\n-fuzz\nflag; the new failing seed corpus\nentry will be used:\n$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a (0.00s)\n        reverse_test.go:20: Reverse produced invalid string\nFAIL\nexit status 1\nFAIL    example/fuzz  0.016s\nSince our test has failed, its time to debug.\nFix the invalid string error\nIn this section, you will debug the failure, and fix the bug.\nFeel free to spend some time thinking about this and trying to fix the issue\nyourself before moving on.\nDiagnose the error\nThere are a few different ways you could debug this error. If you are using VS\nCode as your text editor, you can\nset up your\ndebugger\nto\ninvestigate.\nIn this tutorial, we will log useful debugging info to your terminal.\nFirst, consider the docs for\nutf8.ValidString\n.\nValidString reports whether s consists entirely of valid UTF-8-encoded runes.\nThe current\nReverse\nfunction reverses the string byte-by-byte, and therein\nlies our problem. In order to preserve the UTF-8-encoded runes of the original\nstring, we must instead reverse the string rune-by-rune.\nTo examine why the input (in this case, the Chinese character\n\n) is causing\nReverse\nto produce an invalid string when reversed, you can inspect the number\nof runes in the reversed string.\nWrite the code\nIn your text editor, replace the fuzz target within\nFuzzReverse\nwith the\nfollowing.\nf.Fuzz(func(t *testing.T, orig string) {\n    rev := Reverse(orig)\n    doubleRev := Reverse(rev)\n    t.Logf(\"Number of runes: orig=%d, rev=%d, doubleRev=%d\", utf8.RuneCountInString(orig), utf8.RuneCountInString(rev), utf8.RuneCountInString(doubleRev))\n    if orig != doubleRev {\n        t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n    }\n    if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n        t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n    }\n})\nThis\nt.Logf\nline will print to the command line if an error occurs, or if\nexecuting the test with\n-v\n, which can help you debug this particular issue.\nRun the code\nRun the test using go test\n$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=1, rev=3, doubleRev=1\n        reverse_test.go:21: Reverse produced invalid UTF-8 string \"\\x83\\xb3\\xe6\"\nFAIL\nexit status 1\nFAIL    example/fuzz    0.598s\nThe entire seed corpus used strings in which every character was a single byte.\nHowever, characters such as  can require several bytes. Thus, reversing the\nstring byte-by-byte will invalidate multi-byte characters.\nNote:\nIf youre curious about how Go deals with strings, read the blog post\nStrings, bytes, runes and characters in Go\nfor a\ndeeper understanding.\nWith a better understanding of the bug, correct the error in the\nReverse\nfunction.\nFix the error\nTo correct the\nReverse\nfunction, lets traverse the string by runes, instead\nof by bytes.\nWrite the code\nIn your text editor, replace the existing Reverse() function with the following.\nfunc Reverse(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}\nThe key difference is that\nReverse\nis now iterating over each\nrune\nin the\nstring, rather than each\nbyte\n. Note that this is just an example, and does not\nhandle\ncombining characters\ncorrectly.\nRun the code\nRun the test using\ngo test\n$ go test\nPASS\nok      example/fuzz  0.016s\nThe test now passes!\nFuzz it again with\ngo test -fuzz\n, to see if there are any new bugs.\n$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/37 completed\nfuzz: minimizing 506-byte failing input file...\nfuzz: elapsed: 0s, gathering baseline coverage: 5/37 completed\n--- FAIL: FuzzReverse (0.02s)\n    --- FAIL: FuzzReverse (0.00s)\n        reverse_test.go:33: Before: \"\\x91\", after: \"\"\n\n    Failing input written to testdata/fuzz/FuzzReverse/1ffc28f7538e29d79fce69fef20ce5ea72648529a9ca10bea392bcff28cd015c\n    To re-run:\n    go test -run=FuzzReverse/1ffc28f7538e29d79fce69fef20ce5ea72648529a9ca10bea392bcff28cd015c\nFAIL\nexit status 1\nFAIL    example/fuzz  0.032s\nWe can see that the string is different from the original after being\nreversed twice. This time the input itself is invalid unicode. How is this\npossible if were fuzzing with strings?\nLets debug again.\nFix the double reverse error\nIn this section, you will debug the double reverse failure and fix the bug.\nFeel free to spend some time thinking about this and trying to fix the issue\nyourself before moving on.\nDiagnose the error\nLike before, there are several ways you could debug this failure. In this case,\nusing a\ndebugger\nwould be a great approach.\nIn this tutorial, we will log useful debugging info in the\nReverse\nfunction.\nLook closely at the reversed string to spot the error. In Go,\na string is a\nread only slice of bytes\n, and can contain bytes\nthat arent valid UTF-8. The original string is a byte slice with one byte,\n'\\x91'\n. When the input string is set to\n[]rune\n, Go encodes the byte slice to\nUTF-8, and replaces the byte with the UTF-8 character . When we compare the\nreplacement UTF-8 character to the input byte slice, they are clearly not equal.\nWrite the code\nIn your text editor, replace the\nReverse\nfunction with the following.\nfunc Reverse(s string) string {\n    fmt.Printf(\"input: %q\\n\", s)\n    r := []rune(s)\n    fmt.Printf(\"runes: %q\\n\", r)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}\nThis will help us understand what is going wrong when converting the string\nto a slice of runes.\nRun the code\nThis time, we only want to run the failing test in order to inspect the logs. To\ndo this, we will use\ngo test -run\n.\nTo run a specific corpus entry within FuzzXxx/testdata, you can provide\n{FuzzTestName}/{filename} to\n-run\n. This can be helpful when debugging.\nIn this case, set the\n-run\nflag equal to the exact hash of the failing test.\nCopy and paste the unique hash from your terminal;\nit will be different than the one below.\n$ go test -run=FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0\ninput: \"\\x91\"\nrunes: ['']\ninput: \"\"\nrunes: ['']\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=1, rev=1, doubleRev=1\n        reverse_test.go:18: Before: \"\\x91\", after: \"\"\nFAIL\nexit status 1\nFAIL    example/fuzz    0.145s\nKnowing that the input is invalid unicode, lets fix the error in our\nReverse\nfunction.\nFix the error\nTo fix this issue, lets return an error if the input to\nReverse\nisnt valid\nUTF-8.\nWrite the code\nIn your text editor, replace the existing\nReverse\nfunction with the\nfollowing.\nfunc Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r), nil\n}\nThis change will return an error if the input string contains characters\nwhich are not valid UTF-8.\nSince the Reverse function now returns an error, modify the\nmain\nfunction to\ndiscard the extra error value. Replace the existing\nmain\nfunction with the\nfollowing.\nfunc main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q, err: %v\\n\", rev, revErr)\n    fmt.Printf(\"reversed again: %q, err: %v\\n\", doubleRev, doubleRevErr)\n}\nThese calls to\nReverse\nshould return a nil error, since the input\nstring is valid UTF-8.\nYou will need to import the errors and the unicode/utf8 packages.\nThe import statement in main.go should look like the following.\nimport (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\nModify the reverse_test.go file to check for errors and skip the test if\nerrors are generated by returning.\nfunc FuzzReverse(f *testing.F) {\n    testcases := []string {\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err1 := Reverse(orig)\n        if err1 != nil {\n            return\n        }\n        doubleRev, err2 := Reverse(rev)\n        if err2 != nil {\n             return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}\nRather than returning, you can also call\nt.Skip()\nto stop the execution of\nthat fuzz input.\nRun the code\nRun the test using go test\n$ go test\nPASS\nok      example/fuzz  0.019s\nFuzz it with\ngo test -fuzz=Fuzz\n, then after a few seconds has passed, stop\nfuzzing with\nctrl-C\n. The fuzz test will run until it encounters a failing\ninput unless you pass the\n-fuzztime\nflag. The default is to run forever if no\nfailures occur, and the process can be interrupted with\nctrl-C\n.\n$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/38 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 38/38 completed, now fuzzing with 4 workers\nfuzz: elapsed: 3s, execs: 86342 (28778/sec), new interesting: 2 (total: 35)\nfuzz: elapsed: 6s, execs: 193490 (35714/sec), new interesting: 4 (total: 37)\nfuzz: elapsed: 9s, execs: 304390 (36961/sec), new interesting: 4 (total: 37)\n...\nfuzz: elapsed: 3m45s, execs: 7246222 (32357/sec), new interesting: 8 (total: 41)\n^Cfuzz: elapsed: 3m48s, execs: 7335316 (31648/sec), new interesting: 8 (total: 41)\nPASS\nok      example/fuzz  228.000s\nFuzz it with\ngo test -fuzz=Fuzz -fuzztime 30s\nwhich will fuzz for 30\nseconds before exiting if no failure was found.\n$ go test -fuzz=Fuzz -fuzztime 30s\nfuzz: elapsed: 0s, gathering baseline coverage: 0/5 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 5/5 completed, now fuzzing with 4 workers\nfuzz: elapsed: 3s, execs: 80290 (26763/sec), new interesting: 12 (total: 12)\nfuzz: elapsed: 6s, execs: 210803 (43501/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 9s, execs: 292882 (27360/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 12s, execs: 371872 (26329/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 15s, execs: 517169 (48433/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 18s, execs: 663276 (48699/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 21s, execs: 771698 (36143/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 24s, execs: 924768 (50990/sec), new interesting: 16 (total: 16)\nfuzz: elapsed: 27s, execs: 1082025 (52427/sec), new interesting: 17 (total: 17)\nfuzz: elapsed: 30s, execs: 1172817 (30281/sec), new interesting: 17 (total: 17)\nfuzz: elapsed: 31s, execs: 1172817 (0/sec), new interesting: 17 (total: 17)\nPASS\nok      example/fuzz  31.025s\nFuzzing passed!\nIn addition to the\n-fuzz\nflag, several new flags have been added to\ngo test\nand can be viewed in the\ndocumentation\n.\nSee\nGo Fuzzing\nfor more\ninformation on terms used in fuzzing output. For example, new interesting\nrefers to inputs that expand the code coverage of the existing fuzz test\ncorpus. The number of new interesting inputs can be expected to increase\nsharply as fuzzing begins, spike several times as new code paths are\ndiscovered, then taper off over time.\nConclusion\nNicely done! Youve just introduced yourself to fuzzing in Go.\nThe next step is to choose a function in your code that youd like to fuzz, and\ntry it out! If fuzzing finds a bug in your code, consider adding it to the\ntrophy case\n.\nIf you experience any problems or have an idea for a feature,\nfile an\nissue\n.\nFor discussion and general feedback about the feature, you can also participate\nin the\n#fuzzing channel\nin\nGophers Slack.\nCheck out the documentation at\ngo.dev/security/fuzz\nfor\nfurther reading.\nCompleted code\n main.go \npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q, err: %v\\n\", rev, revErr)\n    fmt.Printf(\"reversed again: %q, err: %v\\n\", doubleRev, doubleRevErr)\n}\n\nfunc Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r), nil\n}\n reverse_test.go \npackage main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\n\nfunc FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc) // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err1 := Reverse(orig)\n        if err1 != nil {\n            return\n        }\n        doubleRev, err2 := Reverse(rev)\n        if err2 != nil {\n            return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}\nBack to top",
      "code_examples": [
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<pre><code>C:\\&gt; cd %HOMEPATH%\n</code></pre>"
        },
        {
          "language": "",
          "code": "C:\\> cd %HOMEPATH%",
          "element": "<code>C:\\&gt; cd %HOMEPATH%\n</code>"
        },
        {
          "language": "",
          "code": "$ mkdir fuzz\n$ cd fuzz",
          "element": "<pre><code>$ mkdir fuzz\n$ cd fuzz\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ mkdir fuzz\n$ cd fuzz",
          "element": "<code>$ mkdir fuzz\n$ cd fuzz\n</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "$ go mod init example/fuzz\ngo: creating new go.mod: module example/fuzz",
          "element": "<pre><code>$ go mod init example/fuzz\ngo: creating new go.mod: module example/fuzz\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod init example/fuzz\ngo: creating new go.mod: module example/fuzz",
          "element": "<code>$ go mod init example/fuzz\ngo: creating new go.mod: module example/fuzz\n</code>"
        },
        {
          "language": "",
          "code": "package main",
          "element": "<pre><code>package main\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main",
          "element": "<code>package main\n</code>"
        },
        {
          "language": "",
          "code": "func Reverse(s string) string {\n    b := []byte(s)\n    for i, j := 0, len(b)-1; i < len(b)/2; i, j = i+1, j-1 {\n        b[i], b[j] = b[j], b[i]\n    }\n    return string(b)\n}",
          "element": "<pre><code>func Reverse(s string) string {\n    b := []byte(s)\n    for i, j := 0, len(b)-1; i &lt; len(b)/2; i, j = i+1, j-1 {\n        b[i], b[j] = b[j], b[i]\n    }\n    return string(b)\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func Reverse(s string) string {\n    b := []byte(s)\n    for i, j := 0, len(b)-1; i < len(b)/2; i, j = i+1, j-1 {\n        b[i], b[j] = b[j], b[i]\n    }\n    return string(b)\n}",
          "element": "<code>func Reverse(s string) string {\n    b := []byte(s)\n    for i, j := 0, len(b)-1; i &lt; len(b)/2; i, j = i+1, j-1 {\n        b[i], b[j] = b[j], b[i]\n    }\n    return string(b)\n}\n</code>"
        },
        {
          "language": "",
          "code": "stringutil.Reverse",
          "element": "<code>stringutil.Reverse</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev := Reverse(input)\n    doubleRev := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q\\n\", rev)\n    fmt.Printf(\"reversed again: %q\\n\", doubleRev)\n}",
          "element": "<pre><code>func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev := Reverse(input)\n    doubleRev := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"rev..."
        },
        {
          "language": "",
          "code": "func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev := Reverse(input)\n    doubleRev := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q\\n\", rev)\n    fmt.Printf(\"reversed again: %q\\n\", doubleRev)\n}",
          "element": "<code>func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev := Reverse(input)\n    doubleRev := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed..."
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"",
          "element": "<pre><code>package main\n\nimport \"fmt\"\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport \"fmt\"",
          "element": "<code>package main\n\nimport \"fmt\"\n</code>"
        },
        {
          "language": "",
          "code": "$ go run .\noriginal: \"The quick brown fox jumped over the lazy dog\"\nreversed: \"god yzal eht revo depmuj xof nworb kciuq ehT\"\nreversed again: \"The quick brown fox jumped over the lazy dog\"",
          "element": "<pre><code>$ go run .\noriginal: \"The quick brown fox jumped over the lazy dog\"\nreversed: \"god yzal eht revo depmuj xof nworb kciuq ehT\"\nreversed again: \"The quick brown fox jumped over the lazy dog\"\n<..."
        },
        {
          "language": "",
          "code": "$ go run .\noriginal: \"The quick brown fox jumped over the lazy dog\"\nreversed: \"god yzal eht revo depmuj xof nworb kciuq ehT\"\nreversed again: \"The quick brown fox jumped over the lazy dog\"",
          "element": "<code>$ go run .\noriginal: \"The quick brown fox jumped over the lazy dog\"\nreversed: \"god yzal eht revo depmuj xof nworb kciuq ehT\"\nreversed again: \"The quick brown fox jumped over the lazy dog\"\n</code..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n    testcases := []struct {\n        in, want string\n    }{\n        {\"Hello, world\", \"dlrow ,olleH\"},\n        {\" \", \" \"},\n        {\"!12345\", \"54321!\"},\n    }\n    for _, tc := range testcases {\n        rev := Reverse(tc.in)\n        if rev != tc.want {\n                t.Errorf(\"Reverse: %q, want %q\", rev, tc.want)\n        }\n    }\n}",
          "element": "<pre><code>package main\n\nimport (\n    \"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n    testcases := []struct {\n        in, want string\n    }{\n        {\"Hello, world\", \"dlrow ,olleH\"},\n        {\" \", \"..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n    testcases := []struct {\n        in, want string\n    }{\n        {\"Hello, world\", \"dlrow ,olleH\"},\n        {\" \", \" \"},\n        {\"!12345\", \"54321!\"},\n    }\n    for _, tc := range testcases {\n        rev := Reverse(tc.in)\n        if rev != tc.want {\n                t.Errorf(\"Reverse: %q, want %q\", rev, tc.want)\n        }\n    }\n}",
          "element": "<code>package main\n\nimport (\n    \"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n    testcases := []struct {\n        in, want string\n    }{\n        {\"Hello, world\", \"dlrow ,olleH\"},\n        {\" \", \" \"},\n..."
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.013s",
          "element": "<pre><code>$ go test\nPASS\nok      example/fuzz  0.013s\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.013s",
          "element": "<code>$ go test\nPASS\nok      example/fuzz  0.013s\n</code>"
        },
        {
          "language": "",
          "code": "func FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev := Reverse(orig)\n        doubleRev := Reverse(rev)\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}",
          "element": "<pre><code>func FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n ..."
        },
        {
          "language": "",
          "code": "func FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev := Reverse(orig)\n        doubleRev := Reverse(rev)\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}",
          "element": "<code>func FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f...."
        },
        {
          "language": "",
          "code": "Reverse(\"Hello, world\")",
          "element": "<code>Reverse(\"Hello, world\")</code>"
        },
        {
          "language": "",
          "code": "\"dlrow ,olleH\"",
          "element": "<code>\"dlrow ,olleH\"</code>"
        },
        {
          "language": "",
          "code": "unicode/utf8",
          "element": "<code>unicode/utf8</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)",
          "element": "<pre><code>package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\n</code></pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)",
          "element": "<code>package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\n</code>"
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.013s",
          "element": "<pre><code>$ go test\nPASS\nok      example/fuzz  0.013s\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.013s",
          "element": "<code>$ go test\nPASS\nok      example/fuzz  0.013s\n</code>"
        },
        {
          "language": "",
          "code": "go test -run=FuzzReverse",
          "element": "<code>go test -run=FuzzReverse</code>"
        },
        {
          "language": "",
          "code": "FuzzReverse",
          "element": "<code>FuzzReverse</code>"
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz",
          "element": "<pre><code>$ go test -fuzz=Fuzz\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz",
          "element": "<code>$ go test -fuzz=Fuzz\n</code>"
        },
        {
          "language": "",
          "code": "-fuzztime 10s",
          "element": "<code>-fuzztime 10s</code>"
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/3 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 3/3 completed, now fuzzing with 8 workers\nfuzz: minimizing 38-byte failing input file...\n--- FAIL: FuzzReverse (0.01s)\n    --- FAIL: FuzzReverse (0.00s)\n        reverse_test.go:20: Reverse produced invalid UTF-8 string \"\\x9c\\xdd\"\n\n    Failing input written to testdata/fuzz/FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a\n    To re-run:\n    go test -run=FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a\nFAIL\nexit status 1\nFAIL    example/fuzz  0.030s",
          "element": "<pre><code>$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/3 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 3/3 completed, now fuzzing with 8 workers\nfuzz: minimizing..."
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/3 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 3/3 completed, now fuzzing with 8 workers\nfuzz: minimizing 38-byte failing input file...\n--- FAIL: FuzzReverse (0.01s)\n    --- FAIL: FuzzReverse (0.00s)\n        reverse_test.go:20: Reverse produced invalid UTF-8 string \"\\x9c\\xdd\"\n\n    Failing input written to testdata/fuzz/FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a\n    To re-run:\n    go test -run=FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a\nFAIL\nexit status 1\nFAIL    example/fuzz  0.030s",
          "element": "<code>$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/3 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 3/3 completed, now fuzzing with 8 workers\nfuzz: minimizing 38-b..."
        },
        {
          "language": "",
          "code": "go test fuzz v1\nstring(\"\")",
          "element": "<pre><code>go test fuzz v1\nstring(\"\")\n</code></pre>"
        },
        {
          "language": "",
          "code": "go test fuzz v1\nstring(\"\")",
          "element": "<code>go test fuzz v1\nstring(\"\")\n</code>"
        },
        {
          "language": "",
          "code": "$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a (0.00s)\n        reverse_test.go:20: Reverse produced invalid string\nFAIL\nexit status 1\nFAIL    example/fuzz  0.016s",
          "element": "<pre><code>$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a (0.00s)\n        reverse_test.go:20: Reverse produced inval..."
        },
        {
          "language": "",
          "code": "$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a (0.00s)\n        reverse_test.go:20: Reverse produced invalid string\nFAIL\nexit status 1\nFAIL    example/fuzz  0.016s",
          "element": "<code>$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/af69258a12129d6cbba438df5d5f25ba0ec050461c116f777e77ea7c9a0d217a (0.00s)\n        reverse_test.go:20: Reverse produced invalid st..."
        },
        {
          "language": "",
          "code": "utf8.ValidString",
          "element": "<code>utf8.ValidString</code>"
        },
        {
          "language": "",
          "code": "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.",
          "element": "<pre><code>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n</code></pre>"
        },
        {
          "language": "",
          "code": "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.",
          "element": "<code>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n</code>"
        },
        {
          "language": "",
          "code": "FuzzReverse",
          "element": "<code>FuzzReverse</code>"
        },
        {
          "language": "",
          "code": "f.Fuzz(func(t *testing.T, orig string) {\n    rev := Reverse(orig)\n    doubleRev := Reverse(rev)\n    t.Logf(\"Number of runes: orig=%d, rev=%d, doubleRev=%d\", utf8.RuneCountInString(orig), utf8.RuneCountInString(rev), utf8.RuneCountInString(doubleRev))\n    if orig != doubleRev {\n        t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n    }\n    if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n        t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n    }\n})",
          "element": "<pre><code>f.Fuzz(func(t *testing.T, orig string) {\n    rev := Reverse(orig)\n    doubleRev := Reverse(rev)\n    t.Logf(\"Number of runes: orig=%d, rev=%d, doubleRev=%d\", utf8.RuneCountInString(orig), ut..."
        },
        {
          "language": "",
          "code": "f.Fuzz(func(t *testing.T, orig string) {\n    rev := Reverse(orig)\n    doubleRev := Reverse(rev)\n    t.Logf(\"Number of runes: orig=%d, rev=%d, doubleRev=%d\", utf8.RuneCountInString(orig), utf8.RuneCountInString(rev), utf8.RuneCountInString(doubleRev))\n    if orig != doubleRev {\n        t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n    }\n    if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n        t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n    }\n})",
          "element": "<code>f.Fuzz(func(t *testing.T, orig string) {\n    rev := Reverse(orig)\n    doubleRev := Reverse(rev)\n    t.Logf(\"Number of runes: orig=%d, rev=%d, doubleRev=%d\", utf8.RuneCountInString(orig), utf8.Ru..."
        },
        {
          "language": "",
          "code": "$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=1, rev=3, doubleRev=1\n        reverse_test.go:21: Reverse produced invalid UTF-8 string \"\\x83\\xb3\\xe6\"\nFAIL\nexit status 1\nFAIL    example/fuzz    0.598s",
          "element": "<pre><code>$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=..."
        },
        {
          "language": "",
          "code": "$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=1, rev=3, doubleRev=1\n        reverse_test.go:21: Reverse produced invalid UTF-8 string \"\\x83\\xb3\\xe6\"\nFAIL\nexit status 1\nFAIL    example/fuzz    0.598s",
          "element": "<code>$ go test\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=1, re..."
        },
        {
          "language": "",
          "code": "func Reverse(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
          "element": "<pre><code>func Reverse(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func Reverse(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
          "element": "<code>func Reverse(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}\n</code>"
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.016s",
          "element": "<pre><code>$ go test\nPASS\nok      example/fuzz  0.016s\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.016s",
          "element": "<code>$ go test\nPASS\nok      example/fuzz  0.016s\n</code>"
        },
        {
          "language": "",
          "code": "go test -fuzz",
          "element": "<code>go test -fuzz</code>"
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/37 completed\nfuzz: minimizing 506-byte failing input file...\nfuzz: elapsed: 0s, gathering baseline coverage: 5/37 completed\n--- FAIL: FuzzReverse (0.02s)\n    --- FAIL: FuzzReverse (0.00s)\n        reverse_test.go:33: Before: \"\\x91\", after: \"\"\n\n    Failing input written to testdata/fuzz/FuzzReverse/1ffc28f7538e29d79fce69fef20ce5ea72648529a9ca10bea392bcff28cd015c\n    To re-run:\n    go test -run=FuzzReverse/1ffc28f7538e29d79fce69fef20ce5ea72648529a9ca10bea392bcff28cd015c\nFAIL\nexit status 1\nFAIL    example/fuzz  0.032s",
          "element": "<pre><code>$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/37 completed\nfuzz: minimizing 506-byte failing input file...\nfuzz: elapsed: 0s, gathering baseline coverage: 5/37 comp..."
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/37 completed\nfuzz: minimizing 506-byte failing input file...\nfuzz: elapsed: 0s, gathering baseline coverage: 5/37 completed\n--- FAIL: FuzzReverse (0.02s)\n    --- FAIL: FuzzReverse (0.00s)\n        reverse_test.go:33: Before: \"\\x91\", after: \"\"\n\n    Failing input written to testdata/fuzz/FuzzReverse/1ffc28f7538e29d79fce69fef20ce5ea72648529a9ca10bea392bcff28cd015c\n    To re-run:\n    go test -run=FuzzReverse/1ffc28f7538e29d79fce69fef20ce5ea72648529a9ca10bea392bcff28cd015c\nFAIL\nexit status 1\nFAIL    example/fuzz  0.032s",
          "element": "<code>$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/37 completed\nfuzz: minimizing 506-byte failing input file...\nfuzz: elapsed: 0s, gathering baseline coverage: 5/37 completed..."
        },
        {
          "language": "",
          "code": "func Reverse(s string) string {\n    fmt.Printf(\"input: %q\\n\", s)\n    r := []rune(s)\n    fmt.Printf(\"runes: %q\\n\", r)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
          "element": "<pre><code>func Reverse(s string) string {\n    fmt.Printf(\"input: %q\\n\", s)\n    r := []rune(s)\n    fmt.Printf(\"runes: %q\\n\", r)\n    for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {\n        ..."
        },
        {
          "language": "",
          "code": "func Reverse(s string) string {\n    fmt.Printf(\"input: %q\\n\", s)\n    r := []rune(s)\n    fmt.Printf(\"runes: %q\\n\", r)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
          "element": "<code>func Reverse(s string) string {\n    fmt.Printf(\"input: %q\\n\", s)\n    r := []rune(s)\n    fmt.Printf(\"runes: %q\\n\", r)\n    for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {\n        r[i],..."
        },
        {
          "language": "",
          "code": "go test -run",
          "element": "<code>go test -run</code>"
        },
        {
          "language": "",
          "code": "$ go test -run=FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0\ninput: \"\\x91\"\nrunes: ['']\ninput: \"\"\nrunes: ['']\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=1, rev=1, doubleRev=1\n        reverse_test.go:18: Before: \"\\x91\", after: \"\"\nFAIL\nexit status 1\nFAIL    example/fuzz    0.145s",
          "element": "<pre><code>$ go test -run=FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0\ninput: \"\\x91\"\nrunes: ['']\ninput: \"\"\nrunes: ['']\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: Fu..."
        },
        {
          "language": "",
          "code": "$ go test -run=FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0\ninput: \"\\x91\"\nrunes: ['']\ninput: \"\"\nrunes: ['']\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0 (0.00s)\n        reverse_test.go:16: Number of runes: orig=1, rev=1, doubleRev=1\n        reverse_test.go:18: Before: \"\\x91\", after: \"\"\nFAIL\nexit status 1\nFAIL    example/fuzz    0.145s",
          "element": "<code>$ go test -run=FuzzReverse/28f36ef487f23e6c7a81ebdaa9feffe2f2b02b4cddaa6252e87f69863046a5e0\ninput: \"\\x91\"\nrunes: ['']\ninput: \"\"\nrunes: ['']\n--- FAIL: FuzzReverse (0.00s)\n    --- FAIL: FuzzRev..."
        },
        {
          "language": "",
          "code": "func Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r), nil\n}",
          "element": "<pre><code>func Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i &lt; ..."
        },
        {
          "language": "",
          "code": "func Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r), nil\n}",
          "element": "<code>func Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i &lt; len(r..."
        },
        {
          "language": "",
          "code": "func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q, err: %v\\n\", rev, revErr)\n    fmt.Printf(\"reversed again: %q, err: %v\\n\", doubleRev, doubleRevErr)\n}",
          "element": "<pre><code>func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", inpu..."
        },
        {
          "language": "",
          "code": "func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q, err: %v\\n\", rev, revErr)\n    fmt.Printf(\"reversed again: %q, err: %v\\n\", doubleRev, doubleRevErr)\n}",
          "element": "<code>func main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n  ..."
        },
        {
          "language": "",
          "code": "import (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)",
          "element": "<pre><code>import (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\n</code></pre>"
        },
        {
          "language": "",
          "code": "import (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)",
          "element": "<code>import (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\n</code>"
        },
        {
          "language": "",
          "code": "func FuzzReverse(f *testing.F) {\n    testcases := []string {\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err1 := Reverse(orig)\n        if err1 != nil {\n            return\n        }\n        doubleRev, err2 := Reverse(rev)\n        if err2 != nil {\n             return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}",
          "element": "<pre><code>func FuzzReverse(f *testing.F) {\n    testcases := []string {\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n..."
        },
        {
          "language": "",
          "code": "func FuzzReverse(f *testing.F) {\n    testcases := []string {\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err1 := Reverse(orig)\n        if err1 != nil {\n            return\n        }\n        doubleRev, err2 := Reverse(rev)\n        if err2 != nil {\n             return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}",
          "element": "<code>func FuzzReverse(f *testing.F) {\n    testcases := []string {\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc)  // Use f.Add to provide a seed corpus\n    }\n    f..."
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.019s",
          "element": "<pre><code>$ go test\nPASS\nok      example/fuzz  0.019s\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go test\nPASS\nok      example/fuzz  0.019s",
          "element": "<code>$ go test\nPASS\nok      example/fuzz  0.019s\n</code>"
        },
        {
          "language": "",
          "code": "go test -fuzz=Fuzz",
          "element": "<code>go test -fuzz=Fuzz</code>"
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/38 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 38/38 completed, now fuzzing with 4 workers\nfuzz: elapsed: 3s, execs: 86342 (28778/sec), new interesting: 2 (total: 35)\nfuzz: elapsed: 6s, execs: 193490 (35714/sec), new interesting: 4 (total: 37)\nfuzz: elapsed: 9s, execs: 304390 (36961/sec), new interesting: 4 (total: 37)\n...\nfuzz: elapsed: 3m45s, execs: 7246222 (32357/sec), new interesting: 8 (total: 41)\n^Cfuzz: elapsed: 3m48s, execs: 7335316 (31648/sec), new interesting: 8 (total: 41)\nPASS\nok      example/fuzz  228.000s",
          "element": "<pre><code>$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/38 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 38/38 completed, now fuzzing with 4 workers\nfuzz: elapsed..."
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/38 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 38/38 completed, now fuzzing with 4 workers\nfuzz: elapsed: 3s, execs: 86342 (28778/sec), new interesting: 2 (total: 35)\nfuzz: elapsed: 6s, execs: 193490 (35714/sec), new interesting: 4 (total: 37)\nfuzz: elapsed: 9s, execs: 304390 (36961/sec), new interesting: 4 (total: 37)\n...\nfuzz: elapsed: 3m45s, execs: 7246222 (32357/sec), new interesting: 8 (total: 41)\n^Cfuzz: elapsed: 3m48s, execs: 7335316 (31648/sec), new interesting: 8 (total: 41)\nPASS\nok      example/fuzz  228.000s",
          "element": "<code>$ go test -fuzz=Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0/38 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 38/38 completed, now fuzzing with 4 workers\nfuzz: elapsed: 3s,..."
        },
        {
          "language": "",
          "code": "go test -fuzz=Fuzz -fuzztime 30s",
          "element": "<code>go test -fuzz=Fuzz -fuzztime 30s</code>"
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz -fuzztime 30s\nfuzz: elapsed: 0s, gathering baseline coverage: 0/5 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 5/5 completed, now fuzzing with 4 workers\nfuzz: elapsed: 3s, execs: 80290 (26763/sec), new interesting: 12 (total: 12)\nfuzz: elapsed: 6s, execs: 210803 (43501/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 9s, execs: 292882 (27360/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 12s, execs: 371872 (26329/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 15s, execs: 517169 (48433/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 18s, execs: 663276 (48699/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 21s, execs: 771698 (36143/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 24s, execs: 924768 (50990/sec), new interesting: 16 (total: 16)\nfuzz: elapsed: 27s, execs: 1082025 (52427/sec), new interesting: 17 (total: 17)\nfuzz: elapsed: 30s, execs: 1172817 (30281/sec), new interesting: 17 (total: 17)\nfuzz: elapsed: 31s, execs: 1172817 (0/sec), new interesting: 17 (total: 17)\nPASS\nok      example/fuzz  31.025s",
          "element": "<pre><code>$ go test -fuzz=Fuzz -fuzztime 30s\nfuzz: elapsed: 0s, gathering baseline coverage: 0/5 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 5/5 completed, now fuzzing with 4 workers\nfu..."
        },
        {
          "language": "",
          "code": "$ go test -fuzz=Fuzz -fuzztime 30s\nfuzz: elapsed: 0s, gathering baseline coverage: 0/5 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 5/5 completed, now fuzzing with 4 workers\nfuzz: elapsed: 3s, execs: 80290 (26763/sec), new interesting: 12 (total: 12)\nfuzz: elapsed: 6s, execs: 210803 (43501/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 9s, execs: 292882 (27360/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 12s, execs: 371872 (26329/sec), new interesting: 14 (total: 14)\nfuzz: elapsed: 15s, execs: 517169 (48433/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 18s, execs: 663276 (48699/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 21s, execs: 771698 (36143/sec), new interesting: 15 (total: 15)\nfuzz: elapsed: 24s, execs: 924768 (50990/sec), new interesting: 16 (total: 16)\nfuzz: elapsed: 27s, execs: 1082025 (52427/sec), new interesting: 17 (total: 17)\nfuzz: elapsed: 30s, execs: 1172817 (30281/sec), new interesting: 17 (total: 17)\nfuzz: elapsed: 31s, execs: 1172817 (0/sec), new interesting: 17 (total: 17)\nPASS\nok      example/fuzz  31.025s",
          "element": "<code>$ go test -fuzz=Fuzz -fuzztime 30s\nfuzz: elapsed: 0s, gathering baseline coverage: 0/5 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 5/5 completed, now fuzzing with 4 workers\nfuzz: e..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q, err: %v\\n\", rev, revErr)\n    fmt.Printf(\"reversed again: %q, err: %v\\n\", doubleRev, doubleRevErr)\n}\n\nfunc Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r), nil\n}",
          "element": "<pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, doubleRevErr := Reverse(rev)\n    fmt.Printf(\"original: %q\\n\", input)\n    fmt.Printf(\"reversed: %q, err: %v\\n\", rev, revErr)\n    fmt.Printf(\"reversed again: %q, err: %v\\n\", doubleRev, doubleRevErr)\n}\n\nfunc Reverse(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"input is not valid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r), nil\n}",
          "element": "<code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    input := \"The quick brown fox jumped over the lazy dog\"\n    rev, revErr := Reverse(input)\n    doubleRev, dou..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\n\nfunc FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc) // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err1 := Reverse(orig)\n        if err1 != nil {\n            return\n        }\n        doubleRev, err2 := Reverse(rev)\n        if err2 != nil {\n            return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}",
          "element": "<pre><code>package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\n\nfunc FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n     ..."
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\n\nfunc FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f.Add(tc) // Use f.Add to provide a seed corpus\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err1 := Reverse(orig)\n        if err1 != nil {\n            return\n        }\n        doubleRev, err2 := Reverse(rev)\n        if err2 != nil {\n            return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse produced invalid UTF-8 string %q\", rev)\n        }\n    })\n}",
          "element": "<code>package main\n\nimport (\n    \"testing\"\n    \"unicode/utf8\"\n)\n\nfunc FuzzReverse(f *testing.F) {\n    testcases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testcases {\n        f...."
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Tutorial: Getting started with fuzzing",
          "id": ""
        },
        {
          "level": 2,
          "text": "Prerequisites",
          "id": "prerequisites"
        },
        {
          "level": 2,
          "text": "Create a folder for your code",
          "id": "create_folder"
        },
        {
          "level": 2,
          "text": "Add code to test",
          "id": "code_to_test"
        },
        {
          "level": 2,
          "text": "Add a unit test",
          "id": "unit_test"
        },
        {
          "level": 2,
          "text": "Add a fuzz test",
          "id": "fuzz_test"
        },
        {
          "level": 2,
          "text": "Fix the invalid string error",
          "id": "fix_invalid_string_error"
        },
        {
          "level": 2,
          "text": "Fix the double reverse error",
          "id": "fix_double_reverse_error"
        },
        {
          "level": 2,
          "text": "Conclusion",
          "id": "conclusion"
        },
        {
          "level": 2,
          "text": "Completed code",
          "id": "completed-code"
        },
        {
          "level": 3,
          "text": "Write the code",
          "id": "write-the-code"
        },
        {
          "level": 3,
          "text": "Run the code",
          "id": "run-the-code"
        },
        {
          "level": 3,
          "text": "Write the code",
          "id": "write-the-code-1"
        },
        {
          "level": 3,
          "text": "Run the code",
          "id": "run-the-code-1"
        },
        {
          "level": 3,
          "text": "Write the code",
          "id": "write-the-code-2"
        },
        {
          "level": 3,
          "text": "Run the code",
          "id": "run-the-code-2"
        },
        {
          "level": 3,
          "text": "Diagnose the error",
          "id": "diagnose-the-error"
        },
        {
          "level": 3,
          "text": "Fix the error",
          "id": "fix-the-error"
        },
        {
          "level": 3,
          "text": "Diagnose the error",
          "id": "diagnose-the-error-1"
        },
        {
          "level": 3,
          "text": "Fix the error",
          "id": "fix-the-error-1"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-3"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-3"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-4"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-4"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-5"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-5"
        },
        {
          "level": 4,
          "text": "Write the code",
          "id": "write-the-code-6"
        },
        {
          "level": 4,
          "text": "Run the code",
          "id": "run-the-code-6"
        }
      ],
      "timestamp": 1750757594.0188348
    },
    {
      "url": "https://golang.org/doc/articles/wiki/",
      "title": "Writing Web Applications - The Go Programming Language",
      "content": "Documentation\n/doc/articles/\nWriting Web Applications\nWriting Web Applications\nIntroduction\nCovered in this tutorial:\nCreating a data structure with load and save methods\nUsing the\nnet/http\npackage to build web applications\nUsing the\nhtml/template\npackage to process HTML templates\nUsing the\nregexp\npackage to validate user input\nUsing closures\nAssumed knowledge:\nProgramming experience\nUnderstanding of basic web technologies (HTTP, HTML)\nSome UNIX/DOS command-line knowledge\nGetting Started\nAt present, you need to have a FreeBSD, Linux, macOS, or Windows machine to run Go.\nWe will use\n$\nto represent the command prompt.\nInstall Go (see the\nInstallation Instructions\n).\nMake a new directory for this tutorial inside your\nGOPATH\nand cd to it:\n$ mkdir gowiki\n$ cd gowiki\nCreate a file named\nwiki.go\n, open it in your favorite editor, and\nadd the following lines:\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\nWe import the\nfmt\nand\nos\npackages from the Go\nstandard library. Later, as we implement additional functionality, we will\nadd more packages to this\nimport\ndeclaration.\nData Structures\nLet's start by defining the data structures. A wiki consists of a series of\ninterconnected pages, each of which has a title and a body (the page content).\nHere, we define\nPage\nas a struct with two fields representing\nthe title and body.\ntype Page struct {\n    Title string\n    Body  []byte\n}\nThe type\n[]byte\nmeans \"a\nbyte\nslice\".\n(See\nSlices: usage and\ninternals\nfor more on slices.)\nThe\nBody\nelement is a\n[]byte\nrather than\nstring\nbecause that is the type expected by the\nio\nlibraries we will use, as you'll see below.\nThe\nPage\nstruct describes how page data will be stored in memory.\nBut what about persistent storage? We can address that by creating a\nsave\nmethod on\nPage\n:\nfunc (p *Page) save() error {\n    filename := p.Title + \".txt\"\n    return os.WriteFile(filename, p.Body, 0600)\n}\nThis method's signature reads: \"This is a method named\nsave\nthat\ntakes as its receiver\np\n, a pointer to\nPage\n. It takes\nno parameters, and returns a value of type\nerror\n.\"\nThis method will save the\nPage\n's\nBody\nto a text\nfile. For simplicity, we will use the\nTitle\nas the file name.\nThe\nsave\nmethod returns an\nerror\nvalue because\nthat is the return type of\nWriteFile\n(a standard library function\nthat writes a byte slice to a file).  The\nsave\nmethod returns the\nerror value, to let the application handle it should anything go wrong while\nwriting the file.  If all goes well,\nPage.save()\nwill return\nnil\n(the zero-value for pointers, interfaces, and some other\ntypes).\nThe octal integer literal\n0600\n, passed as the third parameter to\nWriteFile\n, indicates that the file should be created with\nread-write permissions for the current user only. (See the Unix man page\nopen(2)\nfor details.)\nIn addition to saving pages, we will want to load pages, too:\nfunc loadPage(title string) *Page {\n    filename := title + \".txt\"\n    body, _ := os.ReadFile(filename)\n    return &Page{Title: title, Body: body}\n}\nThe function\nloadPage\nconstructs the file name from the title\nparameter, reads the file's contents into a new variable\nbody\n, and\nreturns a pointer to a\nPage\nliteral constructed with the proper\ntitle and body values.\nFunctions can return multiple values. The standard library function\nos.ReadFile\nreturns\n[]byte\nand\nerror\n.\nIn\nloadPage\n, error isn't being handled yet; the \"blank identifier\"\nrepresented by the underscore (\n_\n) symbol is used to throw away the\nerror return value (in essence, assigning the value to nothing).\nBut what happens if\nReadFile\nencounters an error?  For example,\nthe file might not exist. We should not ignore such errors.  Let's modify the\nfunction to return\n*Page\nand\nerror\n.\nfunc loadPage(title string) (*Page, error) {\n    filename := title + \".txt\"\n    body, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, err\n    }\n    return &Page{Title: title, Body: body}, nil\n}\nCallers of this function can now check the second parameter; if it is\nnil\nthen it has successfully loaded a Page. If not, it will be an\nerror\nthat can be handled by the caller (see the\nlanguage specification\nfor details).\nAt this point we have a simple data structure and the ability to save to and\nload from a file. Let's write a\nmain\nfunction to test what we've\nwritten:\nfunc main() {\n    p1 := &Page{Title: \"TestPage\", Body: []byte(\"This is a sample Page.\")}\n    p1.save()\n    p2, _ := loadPage(\"TestPage\")\n    fmt.Println(string(p2.Body))\n}\nAfter compiling and executing this code, a file named\nTestPage.txt\nwould be created, containing the contents of\np1\n. The file would\nthen be read into the struct\np2\n, and its\nBody\nelement\nprinted to the screen.\nYou can compile and run the program like this:\n$ go build wiki.go\n$ ./wiki\nThis is a sample Page.\n(If you're using Windows you must type \"\nwiki\n\" without the\n\"\n./\n\" to run the program.)\nClick here to view the code we've written so far.\nIntroducing the\nnet/http\npackage (an interlude)\nHere's a full working example of a simple web server:\n//go:build ignore\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hi there, I love %s!\", r.URL.Path[1:])\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\nThe\nmain\nfunction begins with a call to\nhttp.HandleFunc\n, which tells the\nhttp\npackage to\nhandle all requests to the web root (\n\"/\"\n) with\nhandler\n.\nIt then calls\nhttp.ListenAndServe\n, specifying that it should\nlisten on port 8080 on any interface (\n\":8080\"\n). (Don't\nworry about its second parameter,\nnil\n, for now.)\nThis function will block until the program is terminated.\nListenAndServe\nalways returns an error, since it only returns when an\nunexpected error occurs.\nIn order to log that error we wrap the function call with\nlog.Fatal\n.\nThe function\nhandler\nis of the type\nhttp.HandlerFunc\n.\nIt takes an\nhttp.ResponseWriter\nand an\nhttp.Request\nas\nits arguments.\nAn\nhttp.ResponseWriter\nvalue assembles the HTTP server's response; by writing\nto it, we send data to the HTTP client.\nAn\nhttp.Request\nis a data structure that represents the client\nHTTP request.\nr.URL.Path\nis the path component\nof the request URL. The trailing\n[1:]\nmeans\n\"create a sub-slice of\nPath\nfrom the 1st character to the end.\"\nThis drops the leading \"/\" from the path name.\nIf you run this program and access the URL:\nhttp://localhost:8080/monkeys\nthe program would present a page containing:\nHi there, I love monkeys!\nUsing\nnet/http\nto serve wiki pages\nTo use the\nnet/http\npackage, it must be imported:\nimport (\n    \"fmt\"\n    \"os\"\n    \"log\"\n\"net/http\"\n)\nLet's create a handler,\nviewHandler\nthat will allow users to\nview a wiki page. It will handle URLs prefixed with \"/view/\".\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    fmt.Fprintf(w, \"<h1>%s</h1><div>%s</div>\", p.Title, p.Body)\n}\nAgain, note the use of\n_\nto ignore the\nerror\nreturn value from\nloadPage\n. This is done here for simplicity\nand generally considered bad practice. We will attend to this later.\nFirst, this function extracts the page title from\nr.URL.Path\n,\nthe path component of the request URL.\nThe\nPath\nis re-sliced with\n[len(\"/view/\"):]\nto drop\nthe leading\n\"/view/\"\ncomponent of the request path.\nThis is because the path will invariably begin with\n\"/view/\"\n,\nwhich is not part of the page's title.\nThe function then loads the page data, formats the page with a string of simple\nHTML, and writes it to\nw\n, the\nhttp.ResponseWriter\n.\nTo use this handler, we rewrite our\nmain\nfunction to\ninitialize\nhttp\nusing the\nviewHandler\nto handle\nany requests under the path\n/view/\n.\nfunc main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\nClick here to view the code we've written so far.\nLet's create some page data (as\ntest.txt\n), compile our code, and\ntry serving a wiki page.\nOpen\ntest.txt\nfile in your editor, and save the string \"Hello world\" (without quotes)\nin it.\n$ go build wiki.go\n$ ./wiki\n(If you're using Windows you must type \"\nwiki\n\" without the\n\"\n./\n\" to run the program.)\nWith this web server running, a visit to\nhttp://localhost:8080/view/test\nshould show a page titled \"test\" containing the words \"Hello world\".\nEditing Pages\nA wiki is not a wiki without the ability to edit pages. Let's create two new\nhandlers: one named\neditHandler\nto display an 'edit page' form,\nand the other named\nsaveHandler\nto save the data entered via the\nform.\nFirst, we add them to\nmain()\n:\nfunc main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.HandleFunc(\"/edit/\", editHandler)\n    http.HandleFunc(\"/save/\", saveHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\nThe function\neditHandler\nloads the page\n(or, if it doesn't exist, create an empty\nPage\nstruct),\nand displays an HTML form.\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    fmt.Fprintf(w, \"<h1>Editing %s</h1>\"+\n        \"<form action=\\\"/save/%s\\\" method=\\\"POST\\\">\"+\n        \"<textarea name=\\\"body\\\">%s</textarea><br>\"+\n        \"<input type=\\\"submit\\\" value=\\\"Save\\\">\"+\n        \"</form>\",\n        p.Title, p.Title, p.Body)\n}\nThis function will work fine, but all that hard-coded HTML is ugly.\nOf course, there is a better way.\nThe\nhtml/template\npackage\nThe\nhtml/template\npackage is part of the Go standard library.\nWe can use\nhtml/template\nto keep the HTML in a separate file,\nallowing us to change the layout of our edit page without modifying the\nunderlying Go code.\nFirst, we must add\nhtml/template\nto the list of imports. We\nalso won't be using\nfmt\nanymore, so we have to remove that.\nimport (\n\"html/template\"\n\"os\"\n    \"net/http\"\n)\nLet's create a template file containing the HTML form.\nOpen a new file named\nedit.html\n, and add the following lines:\n<h1>Editing {{.Title}}</h1>\n\n<form action=\"/save/{{.Title}}\" method=\"POST\">\n<div><textarea name=\"body\" rows=\"20\" cols=\"80\">{{printf \"%s\" .Body}}</textarea></div>\n<div><input type=\"submit\" value=\"Save\"></div>\n</form>\nModify\neditHandler\nto use the template, instead of the hard-coded\nHTML:\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    t, _ := template.ParseFiles(\"edit.html\")\n    t.Execute(w, p)\n}\nThe function\ntemplate.ParseFiles\nwill read the contents of\nedit.html\nand return a\n*template.Template\n.\nThe method\nt.Execute\nexecutes the template, writing the\ngenerated HTML to the\nhttp.ResponseWriter\n.\nThe\n.Title\nand\n.Body\ndotted identifiers refer to\np.Title\nand\np.Body\n.\nTemplate directives are enclosed in double curly braces.\nThe\nprintf \"%s\" .Body\ninstruction is a function call\nthat outputs\n.Body\nas a string instead of a stream of bytes,\nthe same as a call to\nfmt.Printf\n.\nThe\nhtml/template\npackage helps guarantee that only safe and\ncorrect-looking HTML is generated by template actions. For instance, it\nautomatically escapes any greater than sign (\n>\n), replacing it\nwith\n&gt;\n, to make sure user data does not corrupt the form\nHTML.\nSince we're working with templates now, let's create a template for our\nviewHandler\ncalled\nview.html\n:\n<h1>{{.Title}}</h1>\n\n<p>[<a href=\"/edit/{{.Title}}\">edit</a>]</p>\n\n<div>{{printf \"%s\" .Body}}</div>\nModify\nviewHandler\naccordingly:\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    t, _ := template.ParseFiles(\"view.html\")\n    t.Execute(w, p)\n}\nNotice that we've used almost exactly the same templating code in both\nhandlers. Let's remove this duplication by moving the templating code\nto its own function:\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, _ := template.ParseFiles(tmpl + \".html\")\n    t.Execute(w, p)\n}\nAnd modify the handlers to use that function:\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    renderTemplate(w, \"view\", p)\n}\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\nIf we comment out the registration of our unimplemented save handler in\nmain\n, we can once again build and test our program.\nClick here to view the code we've written so far.\nHandling non-existent pages\nWhat if you visit\n/view/APageThatDoesntExist\n? You'll see a page containing\nHTML. This is because it ignores the error return value from\nloadPage\nand continues to try and fill out the template\nwith no data. Instead, if the requested Page doesn't exist, it should\nredirect the client to the edit Page so the content may be created:\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\nThe\nhttp.Redirect\nfunction adds an HTTP status code of\nhttp.StatusFound\n(302) and a\nLocation\nheader to the HTTP response.\nSaving Pages\nThe function\nsaveHandler\nwill handle the submission of forms\nlocated on the edit pages. After uncommenting the related line in\nmain\n, let's implement the handler:\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    p.save()\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\nThe page title (provided in the URL) and the form's only field,\nBody\n, are stored in a new\nPage\n.\nThe\nsave()\nmethod is then called to write the data to a file,\nand the client is redirected to the\n/view/\npage.\nThe value returned by\nFormValue\nis of type\nstring\n.\nWe must convert that value to\n[]byte\nbefore it will fit into\nthe\nPage\nstruct. We use\n[]byte(body)\nto perform\nthe conversion.\nError handling\nThere are several places in our program where errors are being ignored.  This\nis bad practice, not least because when an error does occur the program will\nhave unintended behavior. A better solution is to handle the errors and return\nan error message to the user. That way if something does go wrong, the server\nwill function exactly how we want and the user can be notified.\nFirst, let's handle the errors in\nrenderTemplate\n:\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, err := template.ParseFiles(tmpl + \".html\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    err = t.Execute(w, p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\nThe\nhttp.Error\nfunction sends a specified HTTP response code\n(in this case \"Internal Server Error\") and error message.\nAlready the decision to put this in a separate function is paying off.\nNow let's fix up\nsaveHandler\n:\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\nAny errors that occur during\np.save()\nwill be reported\nto the user.\nTemplate caching\nThere is an inefficiency in this code:\nrenderTemplate\ncalls\nParseFiles\nevery time a page is rendered.\nA better approach would be to call\nParseFiles\nonce at program\ninitialization, parsing all templates into a single\n*Template\n.\nThen we can use the\nExecuteTemplate\nmethod to render a specific template.\nFirst we create a global variable named\ntemplates\n, and initialize\nit with\nParseFiles\n.\nvar templates = template.Must(template.ParseFiles(\"edit.html\", \"view.html\"))\nThe function\ntemplate.Must\nis a convenience wrapper that panics\nwhen passed a non-nil\nerror\nvalue, and otherwise returns the\n*Template\nunaltered. A panic is appropriate here; if the templates\ncan't be loaded the only sensible thing to do is exit the program.\nThe\nParseFiles\nfunction takes any number of string arguments that\nidentify our template files, and parses those files into templates that are\nnamed after the base file name. If we were to add more templates to our\nprogram, we would add their names to the\nParseFiles\ncall's\narguments.\nWe then modify the\nrenderTemplate\nfunction to call the\ntemplates.ExecuteTemplate\nmethod with the name of the appropriate\ntemplate:\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    err := templates.ExecuteTemplate(w, tmpl+\".html\", p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\nNote that the template name is the template file name, so we must\nappend\n\".html\"\nto the\ntmpl\nargument.\nValidation\nAs you may have observed, this program has a serious security flaw: a user\ncan supply an arbitrary path to be read/written on the server. To mitigate\nthis, we can write a function to validate the title with a regular expression.\nFirst, add\n\"regexp\"\nto the\nimport\nlist.\nThen we can create a global variable to store our validation\nexpression:\nvar validPath = regexp.MustCompile(\"^/(edit|save|view)/([a-zA-Z0-9]+)$\")\nThe function\nregexp.MustCompile\nwill parse and compile the\nregular expression, and return a\nregexp.Regexp\n.\nMustCompile\nis distinct from\nCompile\nin that it will\npanic if the expression compilation fails, while\nCompile\nreturns\nan\nerror\nas a second parameter.\nNow, let's write a function that uses the\nvalidPath\nexpression to validate path and extract the page title:\nfunc getTitle(w http.ResponseWriter, r *http.Request) (string, error) {\n    m := validPath.FindStringSubmatch(r.URL.Path)\n    if m == nil {\n        http.NotFound(w, r)\n        return \"\", errors.New(\"invalid Page Title\")\n    }\n    return m[2], nil\n// The title is the second subexpression.\n}\nIf the title is valid, it will be returned along with a\nnil\nerror value. If the title is invalid, the function will write a\n\"404 Not Found\" error to the HTTP connection, and return an error to the\nhandler. To create a new error, we have to import the\nerrors\npackage.\nLet's put a call to\ngetTitle\nin each of the handlers:\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err = p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\nIntroducing Function Literals and Closures\nCatching the error condition in each handler introduces a lot of repeated code.\nWhat if we could wrap each of the handlers in a function that does this\nvalidation and error checking? Go's\nfunction\nliterals\nprovide a powerful means of abstracting functionality\nthat can help us here.\nFirst, we re-write the function definition of each of the handlers to accept\na title string:\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string)\nNow let's define a wrapper function that\ntakes a function of the above\ntype\n, and returns a function of type\nhttp.HandlerFunc\n(suitable to be passed to the function\nhttp.HandleFunc\n):\nfunc makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Here we will extract the page title from the Request,\n        // and call the provided handler 'fn'\n    }\n}\nThe returned function is called a closure because it encloses values defined\noutside of it. In this case, the variable\nfn\n(the single argument\nto\nmakeHandler\n) is enclosed by the closure. The variable\nfn\nwill be one of our save, edit, or view handlers.\nNow we can take the code from\ngetTitle\nand use it here\n(with some minor modifications):\nfunc makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        m := validPath.FindStringSubmatch(r.URL.Path)\n        if m == nil {\n            http.NotFound(w, r)\n            return\n        }\n        fn(w, r, m[2])\n    }\n}\nThe closure returned by\nmakeHandler\nis a function that takes\nan\nhttp.ResponseWriter\nand\nhttp.Request\n(in other\nwords, an\nhttp.HandlerFunc\n).\nThe closure extracts the\ntitle\nfrom the request path, and\nvalidates it with the\nvalidPath\nregexp. If the\ntitle\nis invalid, an error will be written to the\nResponseWriter\nusing the\nhttp.NotFound\nfunction.\nIf the\ntitle\nis valid, the enclosed handler function\nfn\nwill be called with the\nResponseWriter\n,\nRequest\n, and\ntitle\nas arguments.\nNow we can wrap the handler functions with\nmakeHandler\nin\nmain\n, before they are registered with the\nhttp\npackage:\nfunc main() {\n    http.HandleFunc(\"/view/\", makeHandler(viewHandler))\n    http.HandleFunc(\"/edit/\", makeHandler(editHandler))\n    http.HandleFunc(\"/save/\", makeHandler(saveHandler))\n\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\nFinally we remove the calls to\ngetTitle\nfrom the handler functions,\nmaking them much simpler:\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string) {\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\nTry it out!\nClick here to view the final code listing.\nRecompile the code, and run the app:\n$ go build wiki.go\n$ ./wiki\nVisiting\nhttp://localhost:8080/view/ANewPage\nshould present you with the page edit form. You should then be able to\nenter some text, click 'Save', and be redirected to the newly created page.\nOther tasks\nHere are some simple tasks you might want to tackle on your own:\nStore templates in\ntmpl/\nand page data in\ndata/\n.\nAdd a handler to make the web root redirect to\n/view/FrontPage\n.\nSpruce up the page templates by making them valid HTML and adding some\n\tCSS rules.\nImplement inter-page linking by converting instances of\n[PageName]\nto\n<a href=\"/view/PageName\">PageName</a>\n.\n\t(hint: you could use\nregexp.ReplaceAllFunc\nto do this)",
      "code_examples": [
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "$ mkdir gowiki\n$ cd gowiki",
          "element": "<pre>\n$ mkdir gowiki\n$ cd gowiki\n</pre>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)",
          "element": "<pre>\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n</pre>"
        },
        {
          "language": "",
          "code": "type Page struct {\n    Title string\n    Body  []byte\n}",
          "element": "<pre>type Page struct {\n    Title string\n    Body  []byte\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func (p *Page) save() error {\n    filename := p.Title + \".txt\"\n    return os.WriteFile(filename, p.Body, 0600)\n}",
          "element": "<pre>func (p *Page) save() error {\n    filename := p.Title + \".txt\"\n    return os.WriteFile(filename, p.Body, 0600)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "Page.save()",
          "element": "<code>Page.save()</code>"
        },
        {
          "language": "",
          "code": "func loadPage(title string) *Page {\n    filename := title + \".txt\"\n    body, _ := os.ReadFile(filename)\n    return &Page{Title: title, Body: body}\n}",
          "element": "<pre>func loadPage(title string) *Page {\n    filename := title + \".txt\"\n    body, _ := os.ReadFile(filename)\n    return &amp;Page{Title: title, Body: body}\n}\n</pre>"
        },
        {
          "language": "",
          "code": "os.ReadFile",
          "element": "<code>os.ReadFile</code>"
        },
        {
          "language": "",
          "code": "func loadPage(title string) (*Page, error) {\n    filename := title + \".txt\"\n    body, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, err\n    }\n    return &Page{Title: title, Body: body}, nil\n}",
          "element": "<pre>func loadPage(title string) (*Page, error) {\n    filename := title + \".txt\"\n    body, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, err\n    }\n    return &amp;Page{Title: ti..."
        },
        {
          "language": "",
          "code": "func main() {\n    p1 := &Page{Title: \"TestPage\", Body: []byte(\"This is a sample Page.\")}\n    p1.save()\n    p2, _ := loadPage(\"TestPage\")\n    fmt.Println(string(p2.Body))\n}",
          "element": "<pre>func main() {\n    p1 := &amp;Page{Title: \"TestPage\", Body: []byte(\"This is a sample Page.\")}\n    p1.save()\n    p2, _ := loadPage(\"TestPage\")\n    fmt.Println(string(p2.Body))\n}\n</pre>"
        },
        {
          "language": "",
          "code": "TestPage.txt",
          "element": "<code>TestPage.txt</code>"
        },
        {
          "language": "",
          "code": "$ go build wiki.go\n$ ./wiki\nThis is a sample Page.",
          "element": "<pre>\n$ go build wiki.go\n$ ./wiki\nThis is a sample Page.\n</pre>"
        },
        {
          "language": "",
          "code": "//go:build ignorepackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hi there, I love %s!\", r.URL.Path[1:])\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
          "element": "<pre><span class=\"comment\">//go:build ignore</span>\n\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hi there, I..."
        },
        {
          "language": "",
          "code": "http.HandleFunc",
          "element": "<code>http.HandleFunc</code>"
        },
        {
          "language": "",
          "code": "http.ListenAndServe",
          "element": "<code>http.ListenAndServe</code>"
        },
        {
          "language": "",
          "code": "ListenAndServe",
          "element": "<code>ListenAndServe</code>"
        },
        {
          "language": "",
          "code": "http.HandlerFunc",
          "element": "<code>http.HandlerFunc</code>"
        },
        {
          "language": "",
          "code": "http.ResponseWriter",
          "element": "<code>http.ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "http.Request",
          "element": "<code>http.Request</code>"
        },
        {
          "language": "",
          "code": "http.ResponseWriter",
          "element": "<code>http.ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "http.Request",
          "element": "<code>http.Request</code>"
        },
        {
          "language": "",
          "code": "http://localhost:8080/monkeys",
          "element": "<pre>http://localhost:8080/monkeys</pre>"
        },
        {
          "language": "",
          "code": "Hi there, I love monkeys!",
          "element": "<pre>Hi there, I love monkeys!</pre>"
        },
        {
          "language": "",
          "code": "import (\n    \"fmt\"\n    \"os\"\n    \"log\"\"net/http\")",
          "element": "<pre>\nimport (\n    \"fmt\"\n    \"os\"\n    \"log\"\n    <b>\"net/http\"</b>\n)\n</pre>"
        },
        {
          "language": "",
          "code": "viewHandler",
          "element": "<code>viewHandler</code>"
        },
        {
          "language": "",
          "code": "func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    fmt.Fprintf(w, \"<h1>%s</h1><div>%s</div>\", p.Title, p.Body)\n}",
          "element": "<pre>func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    fmt.Fprintf(w, \"&lt;h1&gt;%s&lt;/h1&gt;&lt;div&gt;%s&lt;/div&gt;..."
        },
        {
          "language": "",
          "code": "[len(\"/view/\"):]",
          "element": "<code>[len(\"/view/\"):]</code>"
        },
        {
          "language": "",
          "code": "http.ResponseWriter",
          "element": "<code>http.ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "viewHandler",
          "element": "<code>viewHandler</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
          "element": "<pre>func main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</pre>"
        },
        {
          "language": "",
          "code": "$ go build wiki.go\n$ ./wiki",
          "element": "<pre>\n$ go build wiki.go\n$ ./wiki\n</pre>"
        },
        {
          "language": "",
          "code": "http://localhost:8080/view/test",
          "element": "<code><a href=\"http://localhost:8080/view/test\">http://localhost:8080/view/test</a></code>"
        },
        {
          "language": "",
          "code": "editHandler",
          "element": "<code>editHandler</code>"
        },
        {
          "language": "",
          "code": "saveHandler",
          "element": "<code>saveHandler</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.HandleFunc(\"/edit/\", editHandler)\n    http.HandleFunc(\"/save/\", saveHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
          "element": "<pre>func main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.HandleFunc(\"/edit/\", editHandler)\n    http.HandleFunc(\"/save/\", saveHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n<..."
        },
        {
          "language": "",
          "code": "editHandler",
          "element": "<code>editHandler</code>"
        },
        {
          "language": "",
          "code": "func editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    fmt.Fprintf(w, \"<h1>Editing %s</h1>\"+\n        \"<form action=\\\"/save/%s\\\" method=\\\"POST\\\">\"+\n        \"<textarea name=\\\"body\\\">%s</textarea><br>\"+\n        \"<input type=\\\"submit\\\" value=\\\"Save\\\">\"+\n        \"</form>\",\n        p.Title, p.Title, p.Body)\n}",
          "element": "<pre>func editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &amp;Page{Title: title}\n    }\n    ..."
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "import (\"html/template\"\"os\"\n    \"net/http\"\n)",
          "element": "<pre>\nimport (\n    <b>\"html/template\"</b>\n    \"os\"\n    \"net/http\"\n)\n</pre>"
        },
        {
          "language": "",
          "code": "<h1>Editing {{.Title}}</h1>\n\n<form action=\"/save/{{.Title}}\" method=\"POST\">\n<div><textarea name=\"body\" rows=\"20\" cols=\"80\">{{printf \"%s\" .Body}}</textarea></div>\n<div><input type=\"submit\" value=\"Save\"></div>\n</form>",
          "element": "<pre>&lt;h1&gt;Editing {{.Title}}&lt;/h1&gt;\n\n&lt;form action=\"/save/{{.Title}}\" method=\"POST\"&gt;\n&lt;div&gt;&lt;textarea name=\"body\" rows=\"20\" cols=\"80\"&gt;{{printf \"%s\" .Body}}&lt;/textarea&gt;&lt;..."
        },
        {
          "language": "",
          "code": "editHandler",
          "element": "<code>editHandler</code>"
        },
        {
          "language": "",
          "code": "func editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    t, _ := template.ParseFiles(\"edit.html\")\n    t.Execute(w, p)\n}",
          "element": "<pre>func editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &amp;Page{Title: title}\n    }\n    ..."
        },
        {
          "language": "",
          "code": "template.ParseFiles",
          "element": "<code>template.ParseFiles</code>"
        },
        {
          "language": "",
          "code": "*template.Template",
          "element": "<code>*template.Template</code>"
        },
        {
          "language": "",
          "code": "http.ResponseWriter",
          "element": "<code>http.ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "printf \"%s\" .Body",
          "element": "<code>printf \"%s\" .Body</code>"
        },
        {
          "language": "",
          "code": "html/template",
          "element": "<code>html/template</code>"
        },
        {
          "language": "",
          "code": "viewHandler",
          "element": "<code>viewHandler</code>"
        },
        {
          "language": "",
          "code": "<h1>{{.Title}}</h1>\n\n<p>[<a href=\"/edit/{{.Title}}\">edit</a>]</p>\n\n<div>{{printf \"%s\" .Body}}</div>",
          "element": "<pre>&lt;h1&gt;{{.Title}}&lt;/h1&gt;\n\n&lt;p&gt;[&lt;a href=\"/edit/{{.Title}}\"&gt;edit&lt;/a&gt;]&lt;/p&gt;\n\n&lt;div&gt;{{printf \"%s\" .Body}}&lt;/div&gt;\n</pre>"
        },
        {
          "language": "",
          "code": "viewHandler",
          "element": "<code>viewHandler</code>"
        },
        {
          "language": "",
          "code": "func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    t, _ := template.ParseFiles(\"view.html\")\n    t.Execute(w, p)\n}",
          "element": "<pre>func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    t, _ := template.ParseFiles(\"view.html\")\n    t.Execute(w, p)\n}\n<..."
        },
        {
          "language": "",
          "code": "func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, _ := template.ParseFiles(tmpl + \".html\")\n    t.Execute(w, p)\n}",
          "element": "<pre>func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, _ := template.ParseFiles(tmpl + \".html\")\n    t.Execute(w, p)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    renderTemplate(w, \"view\", p)\n}",
          "element": "<pre>func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    renderTemplate(w, \"view\", p)\n}\n</pre>"
        },
        {
          "language": "",
          "code": "func editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}",
          "element": "<pre>func editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &amp;Page{Title: title}\n    }\n    ..."
        },
        {
          "language": "",
          "code": "/view/APageThatDoesntExist",
          "element": "<code>/view/APageThatDoesntExist</code>"
        },
        {
          "language": "",
          "code": "func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}",
          "element": "<pre>func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, ht..."
        },
        {
          "language": "",
          "code": "http.Redirect",
          "element": "<code>http.Redirect</code>"
        },
        {
          "language": "",
          "code": "http.StatusFound",
          "element": "<code>http.StatusFound</code>"
        },
        {
          "language": "",
          "code": "saveHandler",
          "element": "<code>saveHandler</code>"
        },
        {
          "language": "",
          "code": "func saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    p.save()\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}",
          "element": "<pre>func saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &amp;Page{Title: title, Body: []byte(body)}\n    p.save(..."
        },
        {
          "language": "",
          "code": "[]byte(body)",
          "element": "<code>[]byte(body)</code>"
        },
        {
          "language": "",
          "code": "renderTemplate",
          "element": "<code>renderTemplate</code>"
        },
        {
          "language": "",
          "code": "func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, err := template.ParseFiles(tmpl + \".html\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    err = t.Execute(w, p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}",
          "element": "<pre>func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, err := template.ParseFiles(tmpl + \".html\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServ..."
        },
        {
          "language": "",
          "code": "saveHandler",
          "element": "<code>saveHandler</code>"
        },
        {
          "language": "",
          "code": "func saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}",
          "element": "<pre>func saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &amp;Page{Title: title, Body: []byte(body)}\n    err := ..."
        },
        {
          "language": "",
          "code": "renderTemplate",
          "element": "<code>renderTemplate</code>"
        },
        {
          "language": "",
          "code": "ExecuteTemplate",
          "element": "<code>ExecuteTemplate</code>"
        },
        {
          "language": "",
          "code": "var templates = template.Must(template.ParseFiles(\"edit.html\", \"view.html\"))",
          "element": "<pre>var templates = template.Must(template.ParseFiles(\"edit.html\", \"view.html\"))\n</pre>"
        },
        {
          "language": "",
          "code": "template.Must",
          "element": "<code>template.Must</code>"
        },
        {
          "language": "",
          "code": "renderTemplate",
          "element": "<code>renderTemplate</code>"
        },
        {
          "language": "",
          "code": "templates.ExecuteTemplate",
          "element": "<code>templates.ExecuteTemplate</code>"
        },
        {
          "language": "",
          "code": "func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    err := templates.ExecuteTemplate(w, tmpl+\".html\", p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}",
          "element": "<pre>func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    err := templates.ExecuteTemplate(w, tmpl+\".html\", p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInter..."
        },
        {
          "language": "",
          "code": "var validPath = regexp.MustCompile(\"^/(edit|save|view)/([a-zA-Z0-9]+)$\")",
          "element": "<pre>var validPath = regexp.MustCompile(\"^/(edit|save|view)/([a-zA-Z0-9]+)$\")\n</pre>"
        },
        {
          "language": "",
          "code": "regexp.MustCompile",
          "element": "<code>regexp.MustCompile</code>"
        },
        {
          "language": "",
          "code": "regexp.Regexp",
          "element": "<code>regexp.Regexp</code>"
        },
        {
          "language": "",
          "code": "MustCompile",
          "element": "<code>MustCompile</code>"
        },
        {
          "language": "",
          "code": "func getTitle(w http.ResponseWriter, r *http.Request) (string, error) {\n    m := validPath.FindStringSubmatch(r.URL.Path)\n    if m == nil {\n        http.NotFound(w, r)\n        return \"\", errors.New(\"invalid Page Title\")\n    }\n    return m[2], nil// The title is the second subexpression.}",
          "element": "<pre>func getTitle(w http.ResponseWriter, r *http.Request) (string, error) {\n    m := validPath.FindStringSubmatch(r.URL.Path)\n    if m == nil {\n        http.NotFound(w, r)\n        return \"\", errors.N..."
        },
        {
          "language": "",
          "code": "func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}",
          "element": "<pre>func viewHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        http..."
        },
        {
          "language": "",
          "code": "func editHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}",
          "element": "<pre>func editHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        p = ..."
        },
        {
          "language": "",
          "code": "func saveHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err = p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}",
          "element": "<pre>func saveHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    body := r.FormValue(\"body\")\n    p := &amp;Page{Title: titl..."
        },
        {
          "language": "",
          "code": "func viewHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string)",
          "element": "<pre>\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc saveHandler(w http.ResponseWriter, r *http.Requ..."
        },
        {
          "language": "",
          "code": "http.HandlerFunc",
          "element": "<code>http.HandlerFunc</code>"
        },
        {
          "language": "",
          "code": "http.HandleFunc",
          "element": "<code>http.HandleFunc</code>"
        },
        {
          "language": "",
          "code": "func makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Here we will extract the page title from the Request,\n        // and call the provided handler 'fn'\n    }\n}",
          "element": "<pre>\nfunc makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Here we will extract the page title..."
        },
        {
          "language": "",
          "code": "makeHandler",
          "element": "<code>makeHandler</code>"
        },
        {
          "language": "",
          "code": "func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        m := validPath.FindStringSubmatch(r.URL.Path)\n        if m == nil {\n            http.NotFound(w, r)\n            return\n        }\n        fn(w, r, m[2])\n    }\n}",
          "element": "<pre>func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        m := validPath.FindStringSubmatch(r.URL...."
        },
        {
          "language": "",
          "code": "makeHandler",
          "element": "<code>makeHandler</code>"
        },
        {
          "language": "",
          "code": "http.ResponseWriter",
          "element": "<code>http.ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "http.Request",
          "element": "<code>http.Request</code>"
        },
        {
          "language": "",
          "code": "http.HandlerFunc",
          "element": "<code>http.HandlerFunc</code>"
        },
        {
          "language": "",
          "code": "ResponseWriter",
          "element": "<code>ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "http.NotFound",
          "element": "<code>http.NotFound</code>"
        },
        {
          "language": "",
          "code": "ResponseWriter",
          "element": "<code>ResponseWriter</code>"
        },
        {
          "language": "",
          "code": "makeHandler",
          "element": "<code>makeHandler</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    http.HandleFunc(\"/view/\", makeHandler(viewHandler))\n    http.HandleFunc(\"/edit/\", makeHandler(editHandler))\n    http.HandleFunc(\"/save/\", makeHandler(saveHandler))\n\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
          "element": "<pre>func main() {\n    http.HandleFunc(\"/view/\", makeHandler(viewHandler))\n    http.HandleFunc(\"/edit/\", makeHandler(editHandler))\n    http.HandleFunc(\"/save/\", makeHandler(saveHandler))\n\n    log.Fata..."
        },
        {
          "language": "",
          "code": "func viewHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}",
          "element": "<pre>func viewHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        re..."
        },
        {
          "language": "",
          "code": "func editHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}",
          "element": "<pre>func editHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        p = &amp;Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", ..."
        },
        {
          "language": "",
          "code": "func saveHandler(w http.ResponseWriter, r *http.Request, title string) {\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}",
          "element": "<pre>func saveHandler(w http.ResponseWriter, r *http.Request, title string) {\n    body := r.FormValue(\"body\")\n    p := &amp;Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil..."
        },
        {
          "language": "",
          "code": "$ go build wiki.go\n$ ./wiki",
          "element": "<pre>\n$ go build wiki.go\n$ ./wiki\n</pre>"
        },
        {
          "language": "",
          "code": "/view/FrontPage",
          "element": "<code>/view/FrontPage</code>"
        },
        {
          "language": "",
          "code": "<a href=\"/view/PageName\">PageName</a>",
          "element": "<code>&lt;a href=\"/view/PageName\"&gt;PageName&lt;/a&gt;</code>"
        },
        {
          "language": "",
          "code": "regexp.ReplaceAllFunc",
          "element": "<code>regexp.ReplaceAllFunc</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Writing Web Applications",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": ""
        },
        {
          "level": 2,
          "text": "Getting Started",
          "id": ""
        },
        {
          "level": 2,
          "text": "Data Structures",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introducing thenet/httppackage (an interlude)",
          "id": ""
        },
        {
          "level": 2,
          "text": "Usingnet/httpto serve wiki pages",
          "id": ""
        },
        {
          "level": 2,
          "text": "Editing Pages",
          "id": ""
        },
        {
          "level": 2,
          "text": "Thehtml/templatepackage",
          "id": ""
        },
        {
          "level": 2,
          "text": "Handling non-existent pages",
          "id": ""
        },
        {
          "level": 2,
          "text": "Saving Pages",
          "id": ""
        },
        {
          "level": 2,
          "text": "Error handling",
          "id": ""
        },
        {
          "level": 2,
          "text": "Template caching",
          "id": ""
        },
        {
          "level": 2,
          "text": "Validation",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introducing Function Literals and Closures",
          "id": ""
        },
        {
          "level": 2,
          "text": "Try it out!",
          "id": ""
        },
        {
          "level": 2,
          "text": "Other tasks",
          "id": ""
        }
      ],
      "timestamp": 1750757597.776874
    },
    {
      "url": "https://golang.org/doc/faq",
      "title": "Frequently Asked Questions (FAQ) - The Go Programming Language",
      "content": "Documentation\nFrequently Asked Questions (FAQ)\nFrequently Asked Questions (FAQ)\nOrigins\nWhat is the purpose of the project?\nAt the time of Gos inception in 2007 the programming world was different from today.\nProduction software was usually written in C++ or Java,\nGitHub did not exist, most computers were not yet multiprocessors,\nand other than Visual Studio and Eclipse there were few IDEs or other high-level tools available\nat all, let alone for free on the Internet.\nMeanwhile, we had become frustrated by the undue complexity required\nto build large software projects with\nthe languages we were using and their associated build systems.\nComputers had become enormously quicker since languages such as\nC, C++ and Java were first developed but the act of programming had not\nitself advanced nearly as much.\nAlso, it was clear that multiprocessors were becoming universal but\nmost languages offered little help to program them efficiently\nand safely.\nWe decided to take a step back and think about what major issues were\ngoing to dominate software engineering in the years ahead as technology\ndeveloped, and how a new language might help address them.\nFor instance, the rise of multicore CPUs argued that a language should\nprovide first-class support for some sort of concurrency or parallelism.\nAnd to make resource management tractable in a large concurrent program,\ngarbage collection, or at least some sort of safe automatic memory management was required.\nThese considerations led to\na series of discussions\nfrom which Go arose, first as a set of ideas and\ndesiderata, then as a language.\nAn overarching goal was that Go do more to help the working programmer\nby enabling tooling, automating mundane tasks such as code formatting,\nand removing obstacles to working on large code bases.\nA much more expansive description of the goals of Go and how\nthey are met, or at least approached, is available in the article,\nGo at Google: Language Design in the Service of Software Engineering\n.\nWhat is the history of the project?\nRobert Griesemer, Rob Pike and Ken Thompson started sketching the\ngoals for a new language on the white board on September 21, 2007.\nWithin a few days the goals had settled into a plan to do something\nand a fair idea of what it would be.  Design continued part-time in\nparallel with unrelated work.  By January 2008, Ken had started work\non a compiler with which to explore ideas; it generated C code as its\noutput.  By mid-year the language had become a full-time project and\nhad settled enough to attempt a production compiler.  In May 2008,\nIan Taylor independently started on a GCC front end for Go using the\ndraft specification.  Russ Cox joined in late 2008 and helped move the language\nand libraries from prototype to reality.\nGo became a public open source project on November 10, 2009.\nCountless people from the community have contributed ideas, discussions, and code.\nThere are now millions of Go programmersgophersaround the world,\nand there are more every day.\nGos success has far exceeded our expectations.\nWhats the origin of the gopher mascot?\nThe mascot and logo were designed by\nRene French\n, who also designed\nGlenda\n,\nthe Plan 9 bunny.\nA\nblog post\nabout the gopher explains how it was\nderived from one she used for a\nWFMU\nT-shirt design some years ago.\nThe logo and mascot are covered by the\nCreative Commons Attribution 4.0\nlicense.\nThe gopher has a\nmodel sheet\nillustrating his characteristics and how to represent them correctly.\nThe model sheet was first shown in a\ntalk\nby Rene at Gophercon in 2016.\nHe has unique features; hes the\nGo gopher\n, not just any old gopher.\nIs the language called Go or Golang?\nThe language is called Go.\nThe golang moniker arose because the web site was\noriginally\ngolang.org\n.\n(There was no\n.dev\ndomain then.)\nMany use the golang name, though, and it is handy as\na label.\nFor instance, the social media tag for the language is #golang.\nThe languages name is just plain Go, regardless.\nA side note: Although the\nofficial logo\nhas two capital letters, the language name is written Go, not GO.\nWhy did you create a new language?\nGo was born out of frustration with existing languages and\nenvironments for the work we were doing at Google.\nProgramming had become too\ndifficult and the choice of languages was partly to blame.  One had to\nchoose either efficient compilation, efficient execution, or ease of\nprogramming; all three were not available in the same mainstream\nlanguage.  Programmers who could were choosing ease over\nsafety and efficiency by moving to dynamically typed languages such as\nPython and JavaScript rather than C++ or, to a lesser extent, Java.\nWe were not alone in our concerns.\nAfter many years with a pretty quiet landscape for programming languages,\nGo was among the first of several new languagesRust,\nElixir, Swift, and morethat have made programming language development\nan active, almost mainstream field again.\nGo addressed these issues by attempting to combine the ease of programming of an interpreted,\ndynamically typed\nlanguage with the efficiency and safety of a statically typed, compiled language.\nIt also aimed to be better adapted to current hardware, with support for networked and multicore\ncomputing.\nFinally, working with Go is intended to be\nfast\n: it should take\nat most a few seconds to build a large executable on a single computer.\nMeeting these goals led us to rethink some of the programming approaches\nfrom our current languages, leading to:\na compositional rather than hierarchical type system;\nsupport for concurrency and garbage collection; rigid specification of dependencies;\nand so on.\nThese cannot be handled well by libraries or tools; a new\nlanguage was called for.\nThe article\nGo at Google\ndiscusses the background and motivation behind the design of the Go language,\nas well as providing more detail about many of the answers presented in this FAQ.\nWhat are Gos ancestors?\nGo is mostly in the C family (basic syntax),\nwith significant input from the Pascal/Modula/Oberon\nfamily (declarations, packages),\nplus some ideas from languages\ninspired by Tony Hoares CSP,\nsuch as Newsqueak and Limbo (concurrency).\nHowever, it is a new language across the board.\nIn every respect the language was designed by thinking\nabout what programmers do and how to make programming, at least the\nkind of programming we do, more effective, which means more fun.\nWhat are the guiding principles in the design?\nWhen Go was designed, Java and C++ were the most commonly\nused languages for writing servers, at least at Google.\nWe felt that these languages required\ntoo much bookkeeping and repetition.\nSome programmers reacted by moving towards more dynamic,\nfluid languages like Python, at the cost of efficiency and\ntype safety.\nWe felt it should be possible to have the efficiency,\nthe safety, and the fluidity in a single language.\nGo attempts to reduce the amount of typing in both senses of the word.\nThroughout its design, we have tried to reduce clutter and\ncomplexity.  There are no forward declarations and no header files;\neverything is declared exactly once.  Initialization is expressive,\nautomatic, and easy to use.  Syntax is clean and light on keywords.\nRepetition (\nfoo.Foo* myFoo = new(foo.Foo)\n) is reduced by\nsimple type derivation using the\n:=\ndeclare-and-initialize construct.  And perhaps most radically, there\nis no type hierarchy: types just\nare\n, they dont have to\nannounce their relationships.  These simplifications allow Go to be\nexpressive yet comprehensible without sacrificing productivity.\nAnother important principle is to keep the concepts orthogonal.\nMethods can be implemented for any type; structures represent data while\ninterfaces represent abstraction; and so on.  Orthogonality makes it\neasier to understand what happens when things combine.\nUsage\nIs Google using Go internally?\nYes. Go is used widely in production inside Google.\nOne example is Googles download server,\ndl.google.com\n,\nwhich delivers Chrome binaries and other large installables such as\napt-get\npackages.\nGo is not the only language used at Google, far from it, but it is a key language\nfor a number of areas including\nsite reliability engineering (SRE)\nand large-scale data processing.\nIt is also a key part of the software that runs Google Cloud.\nWhat other companies use Go?\nGo usage is growing worldwide, especially but by no means exclusively\nin the cloud computing space.\nA couple of major cloud infrastructure projects written in Go are\nDocker and Kubernetes,\nbut there are many more.\nIts not just cloud, though, as you can see from the list of\ncompanies on the\ngo.dev web site\nalong with some\nsuccess stories\n.\nAlso, the Go Wiki includes a\npage\n,\nupdated regularly, that lists some of the many companies using Go.\nThe Wiki also has a page with links to more\nsuccess stories\nabout companies and projects that are using the language.\nDo Go programs link with C/C++ programs?\nIt is possible to use C and Go together in the same address space,\nbut it is not a natural fit and can require special interface software.\nAlso, linking C with Go code gives up the memory\nsafety and stack management properties that Go provides.\nSometimes its absolutely necessary to use C libraries to solve a problem,\nbut doing so always introduces an element of risk not present with\npure Go code, so do so with care.\nIf you do need to use C with Go, how to proceed depends on the Go\ncompiler implementation.\nThe standard compiler, part of the Go toolchain supported by the\nGo team at Google, is called\ngc\n.\nIn addition, there are also a GCC-based compiler (\ngccgo\n) and\nan LLVM-based compiler (\ngollvm\n),\nas well as a growing list of unusual ones serving different purposes,\nsometimes implementing language subsets,\nsuch as\nTinyGo\n.\nGc\nuses a different calling convention and linker from C and\ntherefore cannot be called directly from C programs, or vice versa.\nThe\ncgo\nprogram provides the mechanism for a\nforeign function interface to allow safe calling of\nC libraries from Go code.\nSWIG extends this capability to C++ libraries.\nYou can also use\ncgo\nand SWIG with\ngccgo\nand\ngollvm\n.\nSince they use a traditional ABI, its also possible, with great care,\nto link code from these compilers directly with GCC/LLVM-compiled C or C++ programs.\nHowever, doing so safely requires an understanding of the calling conventions for\nall languages concerned, as well as concern for stack limits when calling C or C++\nfrom Go.\nWhat IDEs does Go support?\nThe Go project does not include a custom IDE, but the language and\nlibraries have been designed to make it easy to analyze source code.\nAs a consequence, most well-known editors and IDEs support Go well,\neither directly or through a plugin.\nThe Go team also supports a Go language server for the LSP protocol, called\ngopls\n.\nTools that support LSP can use\ngopls\nto integrate language-specific support.\nThe list of well-known IDEs and editors that offer good Go support\nincludes Emacs, Vim, VSCode, Atom, Eclipse, Sublime, IntelliJ\n(through a custom variant called GoLand), and many more.\nChances are your favorite environment is a productive one for\nprogramming in Go.\nDoes Go support Googles protocol buffers?\nA separate open source project provides the necessary compiler plugin and library.\nIt is available at\ngithub.com/golang/protobuf/\n.\nDesign\nDoes Go have a runtime?\nGo has an extensive runtime library, often just called the\nruntime\n,\nthat is part of every Go program.\nThis library implements garbage collection, concurrency,\nstack management, and other critical features of the Go language.\nAlthough it is more central to the language, Gos runtime is analogous\nto\nlibc\n, the C library.\nIt is important to understand, however, that Gos runtime does not\ninclude a virtual machine, such as is provided by the Java runtime.\nGo programs are compiled ahead of time to native machine code\n(or JavaScript or WebAssembly, for some variant implementations).\nThus, although the term is often used to describe the virtual\nenvironment in which a program runs, in Go the word runtime\nis just the name given to the library providing critical language services.\nWhats up with Unicode identifiers?\nWhen designing Go, we wanted to make sure that it was not\noverly ASCII-centric,\nwhich meant extending the space of identifiers from the\nconfines of 7-bit ASCII.\nGos ruleidentifier characters must be\nletters or digits as defined by Unicodeis simple to understand\nand to implement but has restrictions.\nCombining characters are\nexcluded by design, for instance,\nand that excludes some languages such as Devanagari.\nThis rule has one other unfortunate consequence.\nSince an exported identifier must begin with an\nupper-case letter, identifiers created from characters\nin some languages can, by definition, not be exported.\nFor now the\nonly solution is to use something like\nX\n, which\nis clearly unsatisfactory.\nSince the earliest version of the language, there has been considerable\nthought into how best to expand the identifier space to accommodate\nprogrammers using other native languages.\nExactly what to do remains an active topic of discussion, and a future\nversion of the language may be more liberal in its definition\nof an identifier.\nFor instance, it might adopt some of the ideas from the Unicode\norganizations\nrecommendations\nfor identifiers.\nWhatever happens, it must be done compatibly while preserving\n(or perhaps expanding) the way letter case determines visibility of\nidentifiers, which remains one of our favorite features of Go.\nFor the time being, we have a simple rule that can be expanded later\nwithout breaking programs, one that avoids bugs that would surely arise\nfrom a rule that admits ambiguous identifiers.\nWhy does Go not have feature X?\nEvery language contains novel features and omits someones favorite\nfeature. Go was designed with an eye on felicity of programming, speed of\ncompilation, orthogonality of concepts, and the need to support features\nsuch as concurrency and garbage collection. Your favorite feature may be\nmissing because it doesnt fit, because it affects compilation speed or\nclarity of design, or because it would make the fundamental system model\ntoo difficult.\nIf it bothers you that Go is missing feature\nX\n,\nplease forgive us and investigate the features that Go does have. You might find that\nthey compensate in interesting ways for the lack of\nX\n.\nWhen did Go get generic types?\nThe Go 1.18 release added type parameters to the language.\nThis permits a form of polymorphic or generic programming.\nSee the\nlanguage spec\nand the\nproposal\nfor details.\nWhy was Go initially released without generic types?\nGo was intended as a language for writing server programs that would be\neasy to maintain over time.\n(See\nthis article\nfor more background.)\nThe design concentrated on things like scalability, readability, and\nconcurrency.\nPolymorphic programming did not seem essential to the languages\ngoals at the time, and so was initially left out for simplicity.\nGenerics are convenient but they come at a cost in complexity in the\ntype system and run-time.\nIt took a while to develop a design that we believe gives value\nproportionate to the complexity.\nWhy does Go not have exceptions?\nWe believe that coupling exceptions to a control\nstructure, as in the\ntry-catch-finally\nidiom, results in\nconvoluted code.  It also tends to encourage programmers to label\ntoo many ordinary errors, such as failing to open a file, as\nexceptional.\nGo takes a different approach.  For plain error handling, Gos multi-value\nreturns make it easy to report an error without overloading the return value.\nA canonical error type, coupled with Gos other features\n,\nmakes error handling pleasant but quite different\nfrom that in other languages.\nGo also has a couple\nof built-in functions to signal and recover from truly exceptional\nconditions.  The recovery mechanism is executed only as part of a\nfunctions state being torn down after an error, which is sufficient\nto handle catastrophe but requires no extra control structures and,\nwhen used well, can result in clean error-handling code.\nSee the\nDefer, Panic, and Recover\narticle for details.\nAlso, the\nErrors are values\nblog post\ndescribes one approach to handling errors cleanly in Go by demonstrating that,\nsince errors are just values, the full power of Go can be deployed in error handling.\nWhy does Go not have assertions?\nGo doesnt provide assertions. They are undeniably convenient, but our\nexperience has been that programmers use them as a crutch to avoid thinking\nabout proper error handling and reporting. Proper error handling means that\nservers continue to operate instead of crashing after a non-fatal error.\nProper error reporting means that errors are direct and to the point,\nsaving the programmer from interpreting a large crash trace. Precise\nerrors are particularly important when the programmer seeing the errors is\nnot familiar with the code.\nWe understand that this is a point of contention. There are many things in\nthe Go language and libraries that differ from modern practices, simply\nbecause we feel its sometimes worth trying a different approach.\nWhy build concurrency on the ideas of CSP?\nConcurrency and multi-threaded programming have over time\ndeveloped a reputation for difficulty.  We believe this is due partly to complex\ndesigns such as\npthreads\nand partly to overemphasis on low-level details\nsuch as mutexes, condition variables, and memory barriers.\nHigher-level interfaces enable much simpler code, even if there are still\nmutexes and such under the covers.\nOne of the most successful models for providing high-level linguistic support\nfor concurrency comes from Hoares Communicating Sequential Processes, or CSP.\nOccam and Erlang are two well known languages that stem from CSP.\nGos concurrency primitives derive from a different part of the family tree\nwhose main contribution is the powerful notion of channels as first class objects.\nExperience with several earlier languages has shown that the CSP model\nfits well into a procedural language framework.\nWhy goroutines instead of threads?\nGoroutines are part of making concurrency easy to use.  The idea, which has\nbeen around for a while, is to multiplex independently executing\nfunctionscoroutinesonto a set of threads.\nWhen a coroutine blocks, such as by calling a blocking system call,\nthe run-time automatically moves other coroutines on the same operating\nsystem thread to a different, runnable thread so they wont be blocked.\nThe programmer sees none of this, which is the point.\nThe result, which we call goroutines, can be very cheap: they have little\noverhead beyond the memory for the stack, which is just a few kilobytes.\nTo make the stacks small, Gos run-time uses resizable, bounded stacks.  A newly\nminted goroutine is given a few kilobytes, which is almost always enough.\nWhen it isnt, the run-time grows (and shrinks) the memory for storing\nthe stack automatically, allowing many goroutines to live in a modest\namount of memory.\nThe CPU overhead averages about three cheap instructions per function call.\nIt is practical to create hundreds of thousands of goroutines in the same\naddress space.\nIf goroutines were just threads, system resources would\nrun out at a much smaller number.\nWhy are map operations not defined to be atomic?\nAfter long discussion it was decided that the typical use of maps did not require\nsafe access from multiple goroutines, and in those cases where it did, the map was\nprobably part of some larger data structure or computation that was already\nsynchronized.  Therefore requiring that all map operations grab a mutex would slow\ndown most programs and add safety to few.  This was not an easy decision,\nhowever, since it means uncontrolled map access can crash the program.\nThe language does not preclude atomic map updates.  When required, such\nas when hosting an untrusted program, the implementation could interlock\nmap access.\nMap access is unsafe only when updates are occurring.\nAs long as all goroutines are only readinglooking up elements in the map,\nincluding iterating through it using a\nfor\nrange\nloopand not changing the map\nby assigning to elements or doing deletions,\nit is safe for them to access the map concurrently without synchronization.\nAs an aid to correct map use, some implementations of the language\ncontain a special check that automatically reports at run time when a map is modified\nunsafely by concurrent execution.\nAlso there is a type in the sync library called\nsync.Map\nthat works\nwell for certain usage patterns such as static caches, although it is not\nsuitable as a general replacement for the builtin map type.\nWill you accept my language change?\nPeople often suggest improvements to the languagethe\nmailing list\ncontains a rich history of such discussionsbut very few of these changes have\nbeen accepted.\nAlthough Go is an open source project, the language and libraries are protected\nby a\ncompatibility promise\nthat prevents\nchanges that break existing programs, at least at the source code level\n(programs may need to be recompiled occasionally to stay current).\nIf your proposal violates the Go 1 specification we cannot even entertain the\nidea, regardless of its merit.\nA future major release of Go may be incompatible with Go 1, but discussions\non that topic have only just begun and one thing is certain:\nthere will be very few such incompatibilities introduced in the process.\nMoreover, the compatibility promise encourages us to provide an automatic path\nforward for old programs to adapt should that situation arise.\nEven if your proposal is compatible with the Go 1 spec, it might\nnot be in the spirit of Gos design goals.\nThe article\nGo\nat Google: Language Design in the Service of Software Engineering\nexplains Gos origins and the motivation behind its design.\nTypes\nIs Go an object-oriented language?\nYes and no. Although Go has types and methods and allows an\nobject-oriented style of programming, there is no type hierarchy.\nThe concept of interface in Go provides a different approach that\nwe believe is easy to use and in some ways more general. There are\nalso ways to embed types in other types to provide something\nanalogousbut not identicalto subclassing.\nMoreover, methods in Go are more general than in C++ or Java:\nthey can be defined for any sort of data, even built-in types such\nas plain, unboxed integers.\nThey are not restricted to structs (classes).\nAlso, the lack of a type hierarchy makes objects in Go feel much more\nlightweight than in languages such as C++ or Java.\nHow do I get dynamic dispatch of methods?\nThe only way to have dynamically dispatched methods is through an\ninterface. Methods on a struct or any other concrete type are always resolved statically.\nWhy is there no type inheritance?\nObject-oriented programming, at least in the best-known languages,\ninvolves too much discussion of the relationships between types,\nrelationships that often could be derived automatically.  Go takes a\ndifferent approach.\nRather than requiring the programmer to declare ahead of time that two\ntypes are related, in Go a type automatically satisfies any interface\nthat specifies a subset of its methods.  Besides reducing the\nbookkeeping, this approach has real advantages.  Types can satisfy\nmany interfaces at once, without the complexities of traditional\nmultiple inheritance.\nInterfaces can be very lightweightan interface with\none or even zero methods can express a useful concept.\nInterfaces can be added after the fact if a new idea comes along\nor for testingwithout annotating the original types.\nBecause there are no explicit relationships between types\nand interfaces, there is no type hierarchy to manage or discuss.\nIts possible to use these ideas to construct something analogous to\ntype-safe Unix pipes.  For instance, see how\nfmt.Fprintf\nenables formatted printing to any output, not just a file, or how the\nbufio\npackage can be completely separate from file I/O,\nor how the\nimage\npackages generate compressed\nimage files.  All these ideas stem from a single interface\n(\nio.Writer\n) representing a single method\n(\nWrite\n).  And thats only scratching the surface.\nGos interfaces have a profound influence on how programs are structured.\nIt takes some getting used to but this implicit style of type\ndependency is one of the most productive things about Go.\nWhy is\nlen\na function and not a method?\nWe debated this issue but decided\nimplementing\nlen\nand friends as functions was fine in practice and\ndidnt complicate questions about the interface (in the Go type sense)\nof basic types.\nWhy does Go not support overloading of methods and operators?\nMethod dispatch is simplified if it doesnt need to do type matching as well.\nExperience with other languages told us that having a variety of\nmethods with the same name but different signatures was occasionally useful\nbut that it could also be confusing and fragile in practice.  Matching only by name\nand requiring consistency in the types was a major simplifying decision\nin Gos type system.\nRegarding operator overloading, it seems more a convenience than an absolute\nrequirement.  Again, things are simpler without it.\nWhy doesnt Go have implements declarations?\nA Go type implements an interface by implementing the methods of that interface,\nnothing more.  This property allows interfaces to be defined and used without\nneeding to modify existing code.  It enables a kind of\nstructural typing\nthat\npromotes separation of concerns and improves code re-use, and makes it easier\nto build on patterns that emerge as the code develops.\nThe semantics of interfaces is one of the main reasons for Gos nimble,\nlightweight feel.\nSee the\nquestion on type inheritance\nfor more detail.\nHow can I guarantee my type satisfies an interface?\nYou can ask the compiler to check that the type\nT\nimplements the\ninterface\nI\nby attempting an assignment using the zero value for\nT\nor pointer to\nT\n, as appropriate:\ntype T struct{}\nvar _ I = T{}       // Verify that T implements I.\nvar _ I = (*T)(nil) // Verify that *T implements I.\nIf\nT\n(or\n*T\n, accordingly) doesnt implement\nI\n, the mistake will be caught at compile time.\nIf you wish the users of an interface to explicitly declare that they implement\nit, you can add a method with a descriptive name to the interfaces method set.\nFor example:\ntype Fooer interface {\n    Foo()\n    ImplementsFooer()\n}\nA type must then implement the\nImplementsFooer\nmethod to be a\nFooer\n, clearly documenting the fact and announcing it in\ngo doc\ns output.\ntype Bar struct{}\nfunc (b Bar) ImplementsFooer() {}\nfunc (b Bar) Foo() {}\nMost code doesnt make use of such constraints, since they limit the utility of\nthe interface idea. Sometimes, though, theyre necessary to resolve ambiguities\namong similar interfaces.\nWhy doesnt type T satisfy the Equal interface?\nConsider this simple interface to represent an object that can compare\nitself with another value:\ntype Equaler interface {\n    Equal(Equaler) bool\n}\nand this type,\nT\n:\ntype T int\nfunc (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler\nUnlike the analogous situation in some polymorphic type systems,\nT\ndoes not implement\nEqualer\n.\nThe argument type of\nT.Equal\nis\nT\n,\nnot literally the required type\nEqualer\n.\nIn Go, the type system does not promote the argument of\nEqual\n; that is the programmers responsibility, as\nillustrated by the type\nT2\n, which does implement\nEqualer\n:\ntype T2 int\nfunc (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler\nEven this isnt like other type systems, though, because in Go\nany\ntype that satisfies\nEqualer\ncould be passed as the\nargument to\nT2.Equal\n, and at run time we must\ncheck that the argument is of type\nT2\n.\nSome languages arrange to make that guarantee at compile time.\nA related example goes the other way:\ntype Opener interface {\n   Open() Reader\n}\n\nfunc (t T3) Open() *os.File\nIn Go,\nT3\ndoes not satisfy\nOpener\n,\nalthough it might in another language.\nWhile it is true that Gos type system does less for the programmer\nin such cases, the lack of subtyping makes the rules about\ninterface satisfaction very easy to state: are the functions names\nand signatures exactly those of the interface?\nGos rule is also easy to implement efficiently.\nWe feel these benefits offset the lack of\nautomatic type promotion.\nCan I convert a []T to an []interface{}?\nNot directly.\nIt is disallowed by the language specification because the two types\ndo not have the same representation in memory.\nIt is necessary to copy the elements individually to the destination\nslice. This example converts a slice of\nint\nto a slice of\ninterface{}\n:\nt := []int{1, 2, 3, 4}\ns := make([]interface{}, len(t))\nfor i, v := range t {\n    s[i] = v\n}\nCan I convert []T1 to []T2 if T1 and T2 have the same underlying type?\nThis last line of this code sample does not compile.\ntype T1 int\ntype T2 int\nvar t1 T1\nvar x = T2(t1) // OK\nvar st1 []T1\nvar sx = ([]T2)(st1) // NOT OK\nIn Go, types are closely tied to methods, in that every named type has\na (possibly empty) method set.\nThe general rule is that you can change the name of the type being\nconverted (and thus possibly change its method set) but you cant\nchange the name (and method set) of elements of a composite type.\nGo requires you to be explicit about type conversions.\nWhy is my nil error value not equal to nil?\nUnder the covers, interfaces are implemented as two elements, a type\nT\nand a value\nV\n.\nV\nis a concrete value such as an\nint\n,\nstruct\nor pointer, never an interface itself, and has\ntype\nT\n.\nFor instance, if we store the\nint\nvalue 3 in an interface,\nthe resulting interface value has, schematically,\n(\nT=int\n,\nV=3\n).\nThe value\nV\nis also known as the interfaces\ndynamic\nvalue,\nsince a given interface variable might hold different values\nV\n(and corresponding types\nT\n)\nduring the execution of the program.\nAn interface value is\nnil\nonly if the\nV\nand\nT\nare both unset, (\nT=nil\n,\nV\nis not set),\nIn particular, a\nnil\ninterface will always hold a\nnil\ntype.\nIf we store a\nnil\npointer of type\n*int\ninside\nan interface value, the inner type will be\n*int\nregardless of the value of the pointer:\n(\nT=*int\n,\nV=nil\n).\nSuch an interface value will therefore be non-\nnil\neven when the pointer value\nV\ninside is\nnil\n.\nThis situation can be confusing, and arises when a\nnil\nvalue is\nstored inside an interface value such as an\nerror\nreturn:\nfunc returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n    return p // Will always return a non-nil error.\n}\nIf all goes well, the function returns a\nnil\np\n,\nso the return value is an\nerror\ninterface\nvalue holding (\nT=*MyError\n,\nV=nil\n).\nThis means that if the caller compares the returned error to\nnil\n,\nit will always look as if there was an error even if nothing bad happened.\nTo return a proper\nnil\nerror\nto the caller,\nthe function must return an explicit\nnil\n:\nfunc returnsError() error {\n    if bad() {\n        return ErrBad\n    }\n    return nil\n}\nIts a good idea for functions\nthat return errors always to use the\nerror\ntype in\ntheir signature (as we did above) rather than a concrete type such\nas\n*MyError\n, to help guarantee the error is\ncreated correctly. As an example,\nos.Open\nreturns an\nerror\neven though, if not\nnil\n,\nits always of concrete type\n*os.PathError\n.\nSimilar situations to those described here can arise whenever interfaces are used.\nJust keep in mind that if any concrete value\nhas been stored in the interface, the interface will not be\nnil\n.\nFor more information, see\nThe Laws of Reflection\n.\nWhy do zero-size types behave oddly?\nGo supports zero-size types, such as a struct with no fields\n(\nstruct{}\n) or an array with no elements (\n[0]byte\n).\nThere is nothing you can store in a zero-size type, but these types\nare sometimes useful when no value is needed, as in\nmap[int]struct{}\nor a type that has methods but no value.\nDifferent variables with a zero-size type may be placed at the same\nlocation in memory.\nThis is safe as no value can be stored in those variables.\nMoreover, the language does not make any guarantees as to whether\npointers to two different zero-size variables will compare equal or\nnot.\nSuch comparisons may even return\ntrue\nat one point in the program\nand then return\nfalse\nat a different point, depending on exactly how\nthe program is compiled and executed.\nA separate issue with zero-size types is that a pointer to a zero-size\nstruct field must not overlap with a pointer to a different object in\nmemory.\nThat could cause confusion in the garbage collector.\nThis means that if the last field in a struct is zero-size, the struct\nwill be padded to ensure that a pointer to the last field does not\noverlap with memory that immediately follows the struct.\nThus, this program:\nfunc main() {\n    type S struct {\n        f1 byte\n        f2 struct{}\n    }\n    fmt.Println(unsafe.Sizeof(S{}))\n}\nwill print\n2\n, not\n1\n, in most Go implementations.\nWhy are there no untagged unions, as in C?\nUntagged unions would violate Gos memory safety\nguarantees.\nWhy does Go not have variant types?\nVariant types, also known as algebraic types, provide a way to specify\nthat a value might take one of a set of other types, but only those\ntypes. A common example in systems programming would specify that an\nerror is, say, a network error, a security error or an application\nerror and allow the caller to discriminate the source of the problem\nby examining the type of the error. Another example is a syntax tree\nin which each node can be a different type: declaration, statement,\nassignment and so on.\nWe considered adding variant types to Go, but after discussion\ndecided to leave them out because they overlap in confusing ways\nwith interfaces. What would happen if the elements of a variant type\nwere themselves interfaces?\nAlso, some of what variant types address is already covered by the\nlanguage. The error example is easy to express using an interface\nvalue to hold the error and a type switch to discriminate cases.  The\nsyntax tree example is also doable, although not as elegantly.\nWhy does Go not have covariant result types?\nCovariant result types would mean that an interface like\ntype Copyable interface {\n    Copy() interface{}\n}\nwould be satisfied by the method\nfunc (v Value) Copy() Value\nbecause\nValue\nimplements the empty interface.\nIn Go method types must match exactly, so\nValue\ndoes not\nimplement\nCopyable\n.\nGo separates the notion of what a\ntype doesits methodsfrom the types implementation.\nIf two methods return different types, they are not doing the same thing.\nProgrammers who want covariant result types are often trying to\nexpress a type hierarchy through interfaces.\nIn Go its more natural to have a clean separation between interface\nand implementation.\nValues\nWhy does Go not provide implicit numeric conversions?\nThe convenience of automatic conversion between numeric types in C is\noutweighed by the confusion it causes.  When is an expression unsigned?\nHow big is the value?  Does it overflow?  Is the result portable, independent\nof the machine on which it executes?\nIt also complicates the compiler; Cs usual arithmetic conversions\nare not easy to implement and inconsistent across architectures.\nFor reasons of portability, we decided to make things clear and straightforward\nat the cost of some explicit conversions in the code.\nThe definition of constants in Goarbitrary precision values free\nof signedness and size annotationsameliorates matters considerably,\nthough.\nA related detail is that, unlike in C,\nint\nand\nint64\nare distinct types even if\nint\nis a 64-bit type.  The\nint\ntype is generic; if you care about how many bits an integer holds, Go\nencourages you to be explicit.\nHow do constants work in Go?\nAlthough Go is strict about conversion between variables of different\nnumeric types, constants in the language are much more flexible.\nLiteral constants such as\n23\n,\n3.14159\nand\nmath.Pi\noccupy a sort of ideal number space, with arbitrary precision and\nno overflow or underflow.\nFor instance, the value of\nmath.Pi\nis specified to 63 decimal digits\nin the source code, and constant expressions involving the value keep\nprecision beyond what a\nfloat64\ncould hold.\nOnly when the constant or constant expression is assigned to a\nvariablea memory location in the programdoes\nit become a computer number with\nthe usual floating-point properties and precision.\nAlso,\nbecause they are just numbers, not typed values, constants in Go can be\nused more freely than variables, thereby softening some of the awkwardness\naround the strict conversion rules.\nOne can write expressions such as\nsqrt2 := math.Sqrt(2)\nwithout complaint from the compiler because the ideal number\n2\ncan be converted safely and accurately\nto a\nfloat64\nfor the call to\nmath.Sqrt\n.\nA blog post titled\nConstants\nexplores this topic in more detail.\nWhy are maps built in?\nThe same reason strings are: they are such a powerful and important data\nstructure that providing one excellent implementation with syntactic support\nmakes programming more pleasant.  We believe that Gos implementation of maps\nis strong enough that it will serve for the vast majority of uses.\nIf a specific application can benefit from a custom implementation, its possible\nto write one but it will not be as convenient syntactically; this seems a reasonable tradeoff.\nWhy dont maps allow slices as keys?\nMap lookup requires an equality operator, which slices do not implement.\nThey dont implement equality because equality is not well defined on such types;\nthere are multiple considerations involving shallow vs. deep comparison, pointer vs.\nvalue comparison, how to deal with recursive types, and so on.\nWe may revisit this issueand implementing equality for slices\nwill not invalidate any existing programsbut without a clear idea of what\nequality of slices should mean, it was simpler to leave it out for now.\nEquality is defined for structs and arrays, so they can be used as map keys.\nWhy are maps, slices, and channels references while arrays are values?\nTheres a lot of history on that topic.  Early on, maps and channels\nwere syntactically pointers and it was impossible to declare or use a\nnon-pointer instance.  Also, we struggled with how arrays should work.\nEventually we decided that the strict separation of pointers and\nvalues made the language harder to use.  Changing these\ntypes to act as references to the associated, shared data structures resolved\nthese issues. This change added some regrettable complexity to the\nlanguage but had a large effect on usability: Go became a more\nproductive, comfortable language when it was introduced.\nWriting Code\nHow are libraries documented?\nFor access to documentation from the command line, the\ngo\ntool has a\ndoc\nsubcommand that provides a textual interface to the documentation\nfor declarations, files, packages and so on.\nThe global package discovery page\npkg.go.dev/pkg/\n.\nruns a server that extracts package documentation from Go source code\nanywhere on the web\nand serves it as HTML with links to the declarations and related elements.\nIt is the easiest way to learn about existing Go libraries.\nIn the early days of the project, there was a similar program,\ngodoc\n,\nthat could also be run to extract documentation for files on the local machine;\npkg.go.dev/pkg/\nis essentially a descendant.\nAnother descendant is the\npkgsite\ncommand that, like\ngodoc\n, can be run locally, although\nit is not yet integrated into\nthe results shown by\ngo\ndoc\n.\nIs there a Go programming style guide?\nThere is no explicit style guide, although there is certainly\na recognizable Go style.\nGo has established conventions to guide decisions around\nnaming, layout, and file organization.\nThe document\nEffective Go\ncontains some advice on these topics.\nMore directly, the program\ngofmt\nis a pretty-printer\nwhose purpose is to enforce layout rules; it replaces the usual\ncompendium of dos and donts that allows interpretation.\nAll the Go code in the repository, and the vast majority in the\nopen source world, has been run through\ngofmt\n.\nThe document titled\nGo Code Review Comments\nis a collection of very short essays about details of Go idiom that are often\nmissed by programmers.\nIt is a handy reference for people doing code reviews for Go projects.\nHow do I submit patches to the Go libraries?\nThe library sources are in the\nsrc\ndirectory of the repository.\nIf you want to make a significant change, please discuss on the mailing list before embarking.\nSee the document\nContributing to the Go project\nfor more information about how to proceed.\nWhy does go get use HTTPS when cloning a repository?\nCompanies often permit outgoing traffic only on the standard TCP ports 80 (HTTP)\nand 443 (HTTPS), blocking outgoing traffic on other ports, including TCP port 9418\n(git) and TCP port 22 (SSH).\nWhen using HTTPS instead of HTTP,\ngit\nenforces certificate validation by\ndefault, providing protection against man-in-the-middle, eavesdropping and tampering attacks.\nThe\ngo get\ncommand therefore uses HTTPS for safety.\nGit\ncan be configured to authenticate over HTTPS or to use SSH in place of HTTPS.\nTo authenticate over HTTPS, you can add a line\nto the\n$HOME/.netrc\nfile that git consults:\nmachine github.com login *USERNAME* password *APIKEY*\nFor GitHub accounts, the password can be a\npersonal access token\n.\nGit\ncan also be configured to use SSH in place of HTTPS for URLs matching a given prefix.\nFor example, to use SSH for all GitHub access,\nadd these lines to your\n~/.gitconfig\n:\n[url \"ssh://git@github.com/\"]\n    insteadOf = https://github.com/\nWhen working with private modules, but using a public module proxy for dependencies, you may need to set\nGOPRIVATE\n.\nSee\nprivate modules\nfor details and additional settings.\nHow should I manage package versions using go get?\nThe Go toolchain has a built-in system for managing versioned sets of related packages, known as\nmodules\n.\nModules were introduced in\nGo 1.11\nand have been ready for production use since\n1.14\n.\nTo create a project using modules, run\ngo mod init\n.\nThis command creates a\ngo.mod\nfile that tracks dependency versions.\ngo mod init example/project\nTo add, upgrade, or downgrade a dependency, run\ngo get\n:\ngo get golang.org/x/text@v0.3.5\nSee\nTutorial: Create a module\nfor more information on getting started.\nSee\nDeveloping modules\nfor guides on managing dependencies with modules.\nPackages within modules should maintain backward compatibility as they evolve, following the\nimport compatibility rule\n:\nIf an old package and a new package have the same import path,\nthe new package must be backwards compatible with the old package.\nThe\nGo 1 compatibility guidelines\nare a good reference here:\ndont remove exported names, encourage tagged composite literals, and so on.\nIf different functionality is required, add a new name instead of changing an old one.\nModules codify this with\nsemantic versioning\nand semantic import versioning.\nIf a break in compatibility is required, release a module at a new major version.\nModules at major version 2 and higher require a\nmajor version suffix\nas part of their path (like\n/v2\n).\nThis preserves the import compatibility rule: packages in different major versions of a module have distinct paths.\nPointers and Allocation\nWhen are function parameters passed by value?\nAs in all languages in the C family, everything in Go is passed by value.\nThat is, a function always gets a copy of the\nthing being passed, as if there were an assignment statement assigning the\nvalue to the parameter.  For instance, passing an\nint\nvalue\nto a function makes a copy of the\nint\n, and passing a pointer\nvalue makes a copy of the pointer, but not the data it points to.\n(See a\nlater section\nfor a discussion of how this affects method receivers.)\nMap and slice values behave like pointers: they are descriptors that\ncontain pointers to the underlying map or slice data.  Copying a map or\nslice value doesnt copy the data it points to.  Copying an interface value\nmakes a copy of the thing stored in the interface value.  If the interface\nvalue holds a struct, copying the interface value makes a copy of the\nstruct.  If the interface value holds a pointer, copying the interface value\nmakes a copy of the pointer, but again not the data it points to.\nNote that this discussion is about the semantics of the operations.\nActual implementations may apply optimizations to avoid copying\nas long as the optimizations do not change the semantics.\nWhen should I use a pointer to an interface?\nAlmost never. Pointers to interface values arise only in rare, tricky situations involving\ndisguising an interface values type for delayed evaluation.\nIt is a common mistake to pass a pointer to an interface value\nto a function expecting an interface. The compiler will complain about this\nerror but the situation can still be confusing, because sometimes a\npointer\nis necessary to satisfy an interface\n.\nThe insight is that although a pointer to a concrete type can satisfy\nan interface, with one exception\na pointer to an interface can never satisfy an interface\n.\nConsider the variable declaration,\nvar w io.Writer\nThe printing function\nfmt.Fprintf\ntakes as its first argument\na value that satisfies\nio.Writer\nsomething that implements\nthe canonical\nWrite\nmethod. Thus we can write\nfmt.Fprintf(w, \"hello, world\\n\")\nIf however we pass the address of\nw\n, the program will not compile.\nfmt.Fprintf(&w, \"hello, world\\n\") // Compile-time error.\nThe one exception is that any value, even a pointer to an interface, can be assigned to\na variable of empty interface type (\ninterface{}\n).\nEven so, its almost certainly a mistake if the value is a pointer to an interface;\nthe result can be confusing.\nShould I define methods on values or pointers?\nfunc (s *MyStruct) pointerMethod() { } // method on pointer\nfunc (s MyStruct)  valueMethod()   { } // method on value\nFor programmers unaccustomed to pointers, the distinction between these\ntwo examples can be confusing, but the situation is actually very simple.\nWhen defining a method on a type, the receiver (\ns\nin the above\nexamples) behaves exactly as if it were an argument to the method.\nWhether to define the receiver as a value or as a pointer is the same\nquestion, then, as whether a function argument should be a value or\na pointer.\nThere are several considerations.\nFirst, and most important, does the method need to modify the\nreceiver?\nIf it does, the receiver\nmust\nbe a pointer.\n(Slices and maps act as references, so their story is a little\nmore subtle, but for instance to change the length of a slice\nin a method the receiver must still be a pointer.)\nIn the examples above, if\npointerMethod\nmodifies\nthe fields of\ns\n,\nthe caller will see those changes, but\nvalueMethod\nis called with a copy of the callers argument (thats the definition\nof passing a value), so changes it makes will be invisible to the caller.\nBy the way, in Java method receivers have always been pointers,\nalthough their pointer nature is somewhat disguised\n(and recent developments are bringing value receivers to Java).\nIt is the value receivers in Go that are unusual.\nSecond is the consideration of efficiency. If the receiver is large,\na big\nstruct\nfor instance, it may be cheaper to\nuse a pointer receiver.\nNext is consistency. If some of the methods of the type must have\npointer receivers, the rest should too, so the method set is\nconsistent regardless of how the type is used.\nSee the section on\nmethod sets\nfor details.\nFor types such as basic types, slices, and small\nstructs\n,\na value receiver is very cheap so unless the semantics of the method\nrequires a pointer, a value receiver is efficient and clear.\nWhats the difference between new and make?\nIn short:\nnew\nallocates memory, while\nmake\ninitializes\nthe slice, map, and channel types.\nSee the\nrelevant section\nof Effective Go\nfor more details.\nWhat is the size of an\nint\non a 64 bit machine?\nThe sizes of\nint\nand\nuint\nare implementation-specific\nbut the same as each other on a given platform.\nFor portability, code that relies on a particular\nsize of value should use an explicitly sized type, like\nint64\n.\nOn 32-bit machines the compilers use 32-bit integers by default,\nwhile on 64-bit machines integers have 64 bits.\n(Historically, this was not always true.)\nOn the other hand, floating-point scalars and complex\ntypes are always sized (there are no\nfloat\nor\ncomplex\nbasic types),\nbecause programmers should be aware of precision when using floating-point numbers.\nThe default type used for an (untyped) floating-point constant is\nfloat64\n.\nThus\nfoo\n:=\n3.0\ndeclares a variable\nfoo\nof type\nfloat64\n.\nFor a\nfloat32\nvariable initialized by an (untyped) constant, the variable type\nmust be specified explicitly in the variable declaration:\nvar foo float32 = 3.0\nAlternatively, the constant must be given a type with a conversion as in\nfoo := float32(3.0)\n.\nHow do I know whether a variable is allocated on the heap or the stack?\nFrom a correctness standpoint, you dont need to know.\nEach variable in Go exists as long as there are references to it.\nThe storage location chosen by the implementation is irrelevant to the\nsemantics of the language.\nThe storage location does have an effect on writing efficient programs.\nWhen possible, the Go compilers will allocate variables that are\nlocal to a function in that functions stack frame.  However, if the\ncompiler cannot prove that the variable is not referenced after the\nfunction returns, then the compiler must allocate the variable on the\ngarbage-collected heap to avoid dangling pointer errors.\nAlso, if a local variable is very large, it might make more sense\nto store it on the heap rather than the stack.\nIn the current compilers, if a variable has its address taken, that variable\nis a candidate for allocation on the heap. However, a basic\nescape\nanalysis\nrecognizes some cases when such variables will not\nlive past the return from the function and can reside on the stack.\nWhy does my Go process use so much virtual memory?\nThe Go memory allocator reserves a large region of virtual memory as an arena\nfor allocations. This virtual memory is local to the specific Go process; the\nreservation does not deprive other processes of memory.\nTo find the amount of actual memory allocated to a Go process, use the Unix\ntop\ncommand and consult the\nRES\n(Linux) or\nRSIZE\n(macOS) columns.\nConcurrency\nWhat operations are atomic? What about mutexes?\nA description of the atomicity of operations in Go can be found in\nthe\nGo Memory Model\ndocument.\nLow-level synchronization and atomic primitives are available in the\nsync\nand\nsync/atomic\npackages.\nThese packages are good for simple tasks such as incrementing\nreference counts or guaranteeing small-scale mutual exclusion.\nFor higher-level operations, such as coordination among\nconcurrent servers, higher-level techniques can lead\nto nicer programs, and Go supports this approach through\nits goroutines and channels.\nFor instance, you can structure your program so that only one\ngoroutine at a time is ever responsible for a particular piece of data.\nThat approach is summarized by the original\nGo proverb\n,\nDo not communicate by sharing memory. Instead, share memory by communicating.\nSee the\nShare Memory By Communicating\ncode walk\nand its\nassociated article\nfor a detailed discussion of this concept.\nLarge concurrent programs are likely to borrow from both these toolkits.\nWhy doesnt my program run faster with more CPUs?\nWhether a program runs faster with more CPUs depends on the problem\nit is solving.\nThe Go language provides concurrency primitives, such as goroutines\nand channels, but concurrency only enables parallelism\nwhen the underlying problem is intrinsically parallel.\nProblems that are intrinsically sequential cannot be sped up by adding\nmore CPUs, while those that can be broken into pieces that can\nexecute in parallel can be sped up, sometimes dramatically.\nSometimes adding more CPUs can slow a program down.\nIn practical terms, programs that spend more time\nsynchronizing or communicating than doing useful computation\nmay experience performance degradation when using\nmultiple OS threads.\nThis is because passing data between threads involves switching\ncontexts, which has significant cost, and that cost can increase\nwith more CPUs.\nFor instance, the\nprime sieve example\nfrom the Go specification has no significant parallelism although it launches many\ngoroutines; increasing the number of threads (CPUs) is more likely to slow it down than\nto speed it up.\nFor more detail on this topic see the talk entitled\nConcurrency is not Parallelism\n.\nHow can I control the number of CPUs?\nThe number of CPUs available simultaneously to executing goroutines is\ncontrolled by the\nGOMAXPROCS\nshell environment variable,\nwhose default value is the number of CPU cores available.\nPrograms with the potential for parallel execution should therefore\nachieve it by default on a multiple-CPU machine.\nTo change the number of parallel CPUs to use,\nset the environment variable or use the similarly-named\nfunction\nof the runtime package to configure the\nrun-time support to utilize a different number of threads.\nSetting it to 1 eliminates the possibility of true parallelism,\nforcing independent goroutines to take turns executing.\nThe runtime can allocate more threads than the value\nof\nGOMAXPROCS\nto service multiple outstanding\nI/O requests.\nGOMAXPROCS\nonly affects how many goroutines\ncan actually execute at once; arbitrarily more may be blocked\nin system calls.\nGos goroutine scheduler does well at balancing goroutines\nand threads, and can even preempt execution of a goroutine\nto make sure others on the same thread are not starved.\nHowever, it is not perfect.\nIf you see performance issues,\nsetting\nGOMAXPROCS\non a per-application basis may help.\nWhy is there no goroutine ID?\nGoroutines do not have names; they are just anonymous workers.\nThey expose no unique identifier, name, or data structure to the programmer.\nSome people are surprised by this, expecting the\ngo\nstatement to return some item that can be used to access and control\nthe goroutine later.\nThe fundamental reason goroutines are anonymous is so that\nthe full Go language is available when programming concurrent code.\nBy contrast, the usage patterns that develop when threads and goroutines are\nnamed can restrict what a library using them can do.\nHere is an illustration of the difficulties.\nOnce one names a goroutine and constructs a model around\nit, it becomes special, and one is tempted to associate all computation\nwith that goroutine, ignoring the possibility\nof using multiple, possibly shared goroutines for the processing.\nIf the\nnet/http\npackage associated per-request\nstate with a goroutine,\nclients would be unable to use more goroutines\nwhen serving a request.\nMoreover, experience with libraries such as those for graphics systems\nthat require all processing to occur on the main thread\nhas shown how awkward and limiting the approach can be when\ndeployed in a concurrent language.\nThe very existence of a special thread or goroutine forces\nthe programmer to distort the program to avoid crashes\nand other problems caused by inadvertently operating\non the wrong thread.\nFor those cases where a particular goroutine is truly special,\nthe language provides features such as channels that can be\nused in flexible ways to interact with it.\nFunctions and Methods\nWhy do T and *T have different method sets?\nAs the\nGo specification\nsays,\nthe method set of a type\nT\nconsists of all methods\nwith receiver type\nT\n,\nwhile that of the corresponding pointer\ntype\n*T\nconsists of all methods with receiver\n*T\nor\nT\n.\nThat means the method set of\n*T\nincludes that of\nT\n,\nbut not the reverse.\nThis distinction arises because\nif an interface value contains a pointer\n*T\n,\na method call can obtain a value by dereferencing the pointer,\nbut if an interface value contains a value\nT\n,\nthere is no safe way for a method call to obtain a pointer.\n(Doing so would allow a method to modify the contents of\nthe value inside the interface, which is not permitted by\nthe language specification.)\nEven in cases where the compiler could take the address of a value\nto pass to the method, if the method modifies the value the changes\nwill be lost in the caller.\nAs an example, if the code below were valid:\nvar buf bytes.Buffer\nio.Copy(buf, os.Stdin)\nit would copy standard input into a\ncopy\nof\nbuf\n,\nnot into\nbuf\nitself.\nThis is almost never the desired behavior and is therefore disallowed by the language.\nWhat happens with closures running as goroutines?\nDue to the way loop variables work, before Go version 1.22 (see\nthe end of this section for an update),\nsome confusion could arise when using closures with concurrency.\nConsider the following program:\nfunc main() {\n    done := make(chan bool)\n\n    values := []string{\"a\", \"b\", \"c\"}\n    for _, v := range values {\n        go func() {\n            fmt.Println(v)\n            done <- true\n        }()\n    }\n\n    // wait for all goroutines to complete before exiting\n    for _ = range values {\n        <-done\n    }\n}\nOne might mistakenly expect to see\na, b, c\nas the output.\nWhat youll probably see instead is\nc, c, c\n.  This is because\neach iteration of the loop uses the same instance of the variable\nv\n, so\neach closure shares that single variable. When the closure runs, it prints the\nvalue of\nv\nat the time\nfmt.Println\nis executed,\nbut\nv\nmay have been modified since the goroutine was launched.\nTo help detect this and other problems before they happen, run\ngo vet\n.\nTo bind the current value of\nv\nto each closure as it is launched, one\nmust modify the inner loop to create a new variable each iteration.\nOne way is to pass the variable as an argument to the closure:\nfor _, v := range values {\n        go func(\nu\nstring) {\n            fmt.Println(\nu\n)\n            done <- true\n        }(\nv\n)\n    }\nIn this example, the value of\nv\nis passed as an argument to the\nanonymous function. That value is then accessible inside the function as\nthe variable\nu\n.\nEven easier is just to create a new variable, using a declaration style that may\nseem odd but works fine in Go:\nfor _, v := range values {\nv := v\n// create a new 'v'.\n        go func() {\n            fmt.Println(\nv\n)\n            done <- true\n        }()\n    }\nThis behavior of the language, not defining a new variable for\neach iteration, was considered a mistake in retrospect,\nand has been addressed in\nGo 1.22\n, which\ndoes indeed create a new variable for each iteration, eliminating this issue.\nControl Flow\nWhy does Go not have the\n?:\noperator?\nThere is no ternary testing operation in Go.\nYou may use the following to achieve the same\nresult:\nif expr {\n    n = trueVal\n} else {\n    n = falseVal\n}\nThe reason\n?:\nis absent from Go is that the languages designers\nhad seen the operation used too often to create impenetrably complex expressions.\nThe\nif-else\nform, although longer,\nis unquestionably clearer.\nA language needs only one conditional control flow construct.\nType Parameters\nWhy does Go have type parameters?\nType parameters permit what is known as generic programming, in which\nfunctions and data structures are defined in terms of types that are\nspecified later, when those functions and data structures are used.\nFor example, they make it possible to write a function that returns\nthe minimum of two values of any ordered type, without having to write\na separate version for each possible type.\nFor a more in-depth explanation with examples see the blog post\nWhy Generics?\n.\nHow are generics implemented in Go?\nThe compiler can choose whether to compile each instantiation\nseparately or whether to compile similar instantiations as\na single implementation.\nThe single implementation approach is similar to a function with an\ninterface parameter.\nDifferent compilers will make different choices for different cases.\nThe standard Go compiler ordinarily emits a single instantiation\nfor every type argument with the same shape, where the shape is\ndetermined by properties of the type such as the size and the location\nof pointers that it contains.\nFuture releases may experiment with the tradeoff between compile\ntime, run-time efficiency, and code size.\nHow do generics in Go compare to generics in other languages?\nThe basic functionality in all languages is similar: it is possible to\nwrite types and functions using types that are specified later.\nThat said, there are some differences.\nJava\nIn Java, the compiler checks generic types at compile time but removes\nthe types at run time.\nThis is known as\ntype erasure\n.\nFor example, a Java type known as\nList<Integer>\nat\ncompile time will become the non-generic type\nList\nat run\ntime.\nThis means, for example, that when using the Java form of type\nreflection it is impossible to distinguish a value of\ntype\nList<Integer>\nfrom a value of\ntype\nList<Float>\n.\nIn Go the reflection information for a generic type includes the full\ncompile-time type information.\nJava uses type wildcards such as\nList<? extends Number>\nor\nList<? super Number>\nto implement generic\ncovariance and contravariance.\nGo does not have these concepts, which makes generic types in Go much\nsimpler.\nC++\nTraditionally C++ templates do not enforce any constraints on type\narguments, although C++20 supports optional constraints via\nconcepts\n.\nIn Go constraints are mandatory for all type parameters.\nC++20 concepts are expressed as small code fragments that must compile\nwith the type arguments.\nGo constraints are interface types that define the set of all\npermitted type arguments.\nC++ supports template metaprogramming; Go does not.\nIn practice, all C++ compilers compile each template at the point\nwhere it is instantiated; as noted above, Go can and does use\ndifferent approaches for different instantiations.\nRust\nThe Rust version of constraints is known as trait bounds.\nIn Rust the association between a trait bound and a type must be\ndefined explicitly, either in the crate that defines the trait bound\nor the crate that defines the type.\nIn Go type arguments implicitly satisfy constraints, just as Go types\nimplicitly implement interface types.\nThe Rust standard library defines standard traits for operations such as\ncomparison or addition; the Go standard library does not, as these can\nbe expressed in user code via interface types. The one exception\nis Gos\ncomparable\npredefined interface, which\ncaptures a property not expressible in the type system.\nPython\nPython is not a statically typed language, so one can reasonably say\nthat all Python functions are always generic by default: they can\nalways be called with values of any type, and any type errors are\ndetected at run time.\nWhy does Go use square brackets for type parameter lists?\nJava and C++ use angle brackets for type parameter lists, as in\nJava\nList<Integer>\nand C++\nstd::vector<int>\n.\nHowever, that option was not available for Go, because it leads to\na syntactic problem: when parsing code within a function, such\nas\nv := F<T>\n, at the point of seeing\nthe\n<\nits ambiguous whether we are seeing an\ninstantiation or an expression using the\n<\noperator.\nThis is very difficult to resolve without type information.\nFor example, consider a statement like\na, b = w < x, y > (z)\nWithout type information, it is impossible to decide whether the right\nhand side of the assignment is a pair of expressions (\nw < x\nand\ny > z\n), or whether it is a generic function\ninstantiation and call that returns two result values\n(\n(w<x, y>)(z)\n).\nIt is a key design decision of Go that parsing be possible without\ntype information, which seems impossible when using angle brackets for\ngenerics.\nGo is not unique or original in using square brackets; there are other\nlanguages such as Scala that also use square brackets for generic\ncode.\nWhy does Go not support methods with type parameters?\nGo permits a generic type to have methods, but, other than the\nreceiver, the arguments to those methods cannot use parameterized\ntypes.\nWe do not anticipate that Go will ever add generic methods.\nThe problem is how to implement them.\nSpecifically, consider checking whether a value in an\ninterface implements another interface with additional methods.\nFor example, consider this type, an empty struct with a\ngeneric\nNop\nmethod that returns its argument, for any possible type:\ntype Empty struct{}\n\nfunc (Empty) Nop[T any](x T) T {\n    return x\n}\nNow suppose an\nEmpty\nvalue is stored in an\nany\nand passed\nto other code that checks what it can do:\nfunc TryNops(x any) {\n    if x, ok := x.(interface{ Nop(string) string }); ok {\n        fmt.Printf(\"string %s\\n\", x.Nop(\"hello\"))\n    }\n    if x, ok := x.(interface{ Nop(int) int }); ok {\n        fmt.Printf(\"int %d\\n\", x.Nop(42))\n    }\n    if x, ok := x.(interface{ Nop(io.Reader) io.Reader }); ok {\n        data, err := io.ReadAll(x.Nop(strings.NewReader(\"hello world\")))\n        fmt.Printf(\"reader %q %v\\n\", data, err)\n    }\n}\nHow does that code work if\nx\nis an\nEmpty\n?\nIt seems that\nx\nmust satisfy all three tests,\nalong with any other form with any other type.\nWhat code runs when those methods are called?\nFor non-generic methods, the compiler generates the code\nfor all method implementations and links them into the final program.\nBut for generic methods, there can be an infinite number of method\nimplementations, so a different strategy is needed.\nThere are four choices:\nAt link time, make a list of all the possible dynamic interface checks,\nand then look for types that would satisfy them but are missing\ncompiled methods, and then reinvoke the compiler to add those methods.\nThis would make builds significantly slower, by needing to stop after\nlinking and repeat some compilations. It would especially slow down\nincremental builds. Worse, it is possible that the newly compiled method\ncode would itself have new dynamic interface checks, and the process\nwould have to be repeated. Examples can be constructed where\nthe process never even finishes.\nImplement some kind of JIT, compiling the needed method code at runtime.\nGo benefits greatly from the simplicity and predictable performance\nof being purely ahead-of-time compiled.\nWe are reluctant to take on the complexity of a JIT just to implement\none language feature.\nArrange to emit a slow fallback for each generic method that uses\na table of functions for every possible language operation on the type parameter,\nand then use that fallback implementation for the dynamic tests.\nThis approach would make a generic method parameterized by an\nunexpected type much slower than the same method\nparameterized by a type observed at compile time.\nThis would make performance much less predictable.\nDefine that generic methods cannot be used to satisfy interfaces at all.\nInterfaces are an essential part of programming in Go.\nDisallowing generic methods from satisfying interfaces is unacceptable\nfrom a design point of view.\nNone of these choices are good ones, so we chose none of the above.\nInstead of methods with type parameters, use top-level functions with\ntype parameters, or add the type parameters to the receiver type.\nFor more details, including more examples, see the\nproposal\n.\nWhy cant I use a more specific type for the receiver of a parameterized type?\nThe method declarations of a generic type are written with a receiver\nthat includes the type parameter names.\nPerhaps because of the similarity of the syntax for specifying types\nat a call site,\nsome have thought this provides a mechanism for producing\na method customized for certain type arguments by naming\na specific type in the receiver, such as\nstring\n:\ntype S[T any] struct { f T }\n\nfunc (s S[string]) Add(t string) string {\n    return s.f + t\n}\nThis fails because the word\nstring\nis taken by\nthe compiler to be the name of the type argument in the method.\nThe compiler error message will be something like \noperator + not defined on s.f (variable of type string)\n.\nThis can be confusing because the\n+\noperator\nworks fine on the predeclared type\nstring\n,\nbut the declaration has overwritten, for this method, the definition of\nstring\n,\nand the operator does not work on that unrelated version of\nstring\n.\nIts valid to overwrite a predeclared name like this, but is an odd thing to do and\noften a mistake.\nWhy cant the compiler infer the type argument in my program?\nThere are many cases where a programmer can easily see what the type\nargument for a generic type or function must be, but the language does\nnot permit the compiler to infer it.\nType inference is intentionally limited to ensure that there is never\nany confusion as to which type is inferred.\nExperience with other languages suggests that unexpected type\ninference can lead to considerable confusion when reading and\ndebugging a program.\nIt is always possible to specify the explicit type argument to be used\nin the call.\nIn the future new forms of inference may be supported, as long as the\nrules remain simple and clear.\nPackages and Testing\nHow do I create a multifile package?\nPut all the source files for the package in a directory by themselves.\nSource files can refer to items from different files at will; there is\nno need for forward declarations or a header file.\nOther than being split into multiple files, the package will compile and test\njust like a single-file package.\nHow do I write a unit test?\nCreate a new file ending in\n_test.go\nin the same directory\nas your package sources. Inside that file,\nimport \"testing\"\nand write functions of the form\nfunc TestFoo(t *testing.T) {\n    ...\n}\nRun\ngo test\nin that directory.\nThat script finds the\nTest\nfunctions,\nbuilds a test binary, and runs it.\nSee the\nHow to Write Go Code\ndocument,\nthe\ntesting\npackage\nand the\ngo test\nsubcommand for more details.\nWhere is my favorite helper function for testing?\nGos standard\ntesting\npackage makes it easy to write unit tests, but it lacks\nfeatures provided in other languages testing frameworks such as assertion functions.\nAn\nearlier section\nof this document explained why Go\ndoesnt have assertions, and\nthe same arguments apply to the use of\nassert\nin tests.\nProper error handling means letting other tests run after one has failed, so\nthat the person debugging the failure gets a complete picture of what is\nwrong. It is more useful for a test to report that\nisPrime\ngives the wrong answer for 2, 3, 5, and 7 (or for\n2, 4, 8, and 16) than to report that\nisPrime\ngives the wrong\nanswer for 2 and therefore no more tests were run. The programmer who\ntriggers the test failure may not be familiar with the code that fails.\nTime invested writing a good error message now pays off later when the\ntest breaks.\nA related point is that testing frameworks tend to develop into mini-languages\nof their own, with conditionals and controls and printing mechanisms,\nbut Go already has all those capabilities; why recreate them?\nWed rather write tests in Go; its one fewer language to learn and the\napproach keeps the tests straightforward and easy to understand.\nIf the amount of extra code required to write\ngood errors seems repetitive and overwhelming, the test might work better if\ntable-driven, iterating over a list of inputs and outputs defined\nin a data structure (Go has excellent support for data structure literals).\nThe work to write a good test and good error messages will then be amortized over many\ntest cases. The standard Go library is full of illustrative examples, such as in\nthe formatting tests for the\nfmt\npackage\n.\nWhy isnt\nX\nin the standard library?\nThe standard librarys purpose is to support the runtime library, connect to\nthe operating system, and provide key functionality that many Go\nprograms require, such as formatted I/O and networking.\nIt also contains elements important for web programming, including\ncryptography and support for standards like HTTP, JSON, and XML.\nThere is no clear criterion that defines what is included because for\na long time, this was the\nonly\nGo library.\nThere are criteria that define what gets added today, however.\nNew additions to the standard library are rare and the bar for\ninclusion is high.\nCode included in the standard library bears a large ongoing maintenance cost\n(often borne by those other than the original author),\nis subject to the\nGo 1 compatibility promise\n(blocking fixes to any flaws in the API),\nand is subject to the Go\nrelease schedule\n,\npreventing bug fixes from being available to users quickly.\nMost new code should live outside of the standard library and be accessible\nvia the\ngo\ntool\ns\ngo get\ncommand.\nSuch code can have its own maintainers, release cycle,\nand compatibility guarantees.\nUsers can find packages and read their documentation at\npkg.go.dev\n.\nAlthough there are pieces in the standard library that dont really belong,\nsuch as\nlog/syslog\n, we continue to maintain everything in the\nlibrary because of the Go 1 compatibility promise.\nBut we encourage most new code to live elsewhere.\nImplementation\nWhat compiler technology is used to build the compilers?\nThere are several production compilers for Go, and a number of others\nin development for various platforms.\nThe default compiler,\ngc\n, is included with the\nGo distribution as part of the support for the\ngo\ncommand.\nGc\nwas originally written in C\nbecause of the difficulties of bootstrappingyoud need a Go compiler to\nset up a Go environment.\nBut things have advanced and since the Go 1.5 release the compiler has been\na Go program.\nThe compiler was converted from C to Go using automatic translation tools, as\ndescribed in this\ndesign document\nand\ntalk\n.\nThus the compiler is now self-hosting, which means we needed to face\nthe bootstrapping problem.\nThe solution is to have a working Go installation already in place,\njust as one normally has with a working C installation.\nThe story of how to bring up a new Go environment from source\nis described\nhere\nand\nhere\n.\nGc\nis written in Go with a recursive descent parser\nand uses a custom loader, also written in Go but\nbased on the Plan 9 loader, to generate ELF/Mach-O/PE binaries.\nThe\nGccgo\ncompiler is a front end written in C++\nwith a recursive descent parser coupled to the\nstandard GCC back end. An experimental\nLLVM back end\nis\nusing the same front end.\nAt the beginning of the project we considered using LLVM for\ngc\nbut decided it was too large and slow to meet\nour performance goals.\nMore important in retrospect, starting with LLVM would have made it\nharder to introduce some of the ABI and related changes, such as\nstack management, that Go requires but are not part of the standard\nC setup.\nGo turned out to be a fine language in which to implement a Go compiler,\nalthough that was not its original goal.\nNot being self-hosting from the beginning allowed Gos design to\nconcentrate on its original use case, which was networked servers.\nHad we decided Go should compile itself early on, we might have\nended up with a language targeted more for compiler construction,\nwhich is a worthy goal but not the one we had initially.\nAlthough\ngc\nhas its own implementation, a native lexer and\nparser are available in the\ngo/parser\npackage\nand there is also a native\ntype checker\n.\nThe\ngc\ncompiler uses variants of these libraries.\nHow is the run-time support implemented?\nAgain due to bootstrapping issues, the run-time code was originally written mostly in C (with a\ntiny bit of assembler) but it has since been translated to Go\n(except for some assembler bits).\nGccgo\ns run-time support uses\nglibc\n.\nThe\ngccgo\ncompiler implements goroutines using\na technique called segmented stacks,\nsupported by recent modifications to the gold linker.\nGollvm\nsimilarly is built on the corresponding\nLLVM infrastructure.\nWhy is my trivial program such a large binary?\nThe linker in the\ngc\ntoolchain\ncreates statically-linked binaries by default.\nAll Go binaries therefore include the Go\nruntime, along with the run-time type information necessary to support dynamic\ntype checks, reflection, and even panic-time stack traces.\nA simple C hello, world program compiled and linked statically using\ngcc on Linux is around 750 kB, including an implementation of\nprintf\n.\nAn equivalent Go program using\nfmt.Printf\nweighs a couple of megabytes, but that includes\nmore powerful run-time support and type and debugging information.\nA Go program compiled with\ngc\ncan be linked with\nthe\n-ldflags=-w\nflag to disable DWARF generation,\nremoving debugging information from the binary but with no\nother loss of functionality.\nThis can reduce the binary size substantially.\nCan I stop these complaints about my unused variable/import?\nThe presence of an unused variable may indicate a bug, while\nunused imports just slow down compilation,\nan effect that can become substantial as a program accumulates\ncode and programmers over time.\nFor these reasons, Go refuses to compile programs with unused\nvariables or imports,\ntrading short-term convenience for long-term build speed and\nprogram clarity.\nStill, when developing code, its common to create these situations\ntemporarily and it can be annoying to have to edit them out before the\nprogram will compile.\nSome have asked for a compiler option to turn those checks off\nor at least reduce them to warnings.\nSuch an option has not been added, though,\nbecause compiler options should not affect the semantics of the\nlanguage and because the Go compiler does not report warnings, only\nerrors that prevent compilation.\nThere are two reasons for having no warnings.  First, if its worth\ncomplaining about, its worth fixing in the code.  (Conversely, if its not\nworth fixing, its not worth mentioning.) Second, having the compiler\ngenerate warnings encourages the implementation to warn about weak\ncases that can make compilation noisy, masking real errors that\nshould\nbe fixed.\nIts easy to address the situation, though.  Use the blank identifier\nto let unused things persist while youre developing.\nimport \"unused\"\n\n// This declaration marks the import as used by referencing an\n// item from the package.\nvar _ = unused.Item  // TODO: Delete before committing!\n\nfunc main() {\n    debugData := debug.Profile()\n    _ = debugData // Used only during debugging.\n    ....\n}\nNowadays, most Go programmers use a tool,\ngoimports\n,\nwhich automatically rewrites a Go source file to have the correct imports,\neliminating the unused imports issue in practice.\nThis program is easily connected to most editors and IDEs to run automatically when a Go source file is written.\nThis functionality is also built into\ngopls\n, as\ndiscussed above\n.\nWhy does my virus-scanning software think my Go distribution or compiled binary is infected?\nThis is a common occurrence, especially on Windows machines, and is almost always a false positive.\nCommercial virus scanning programs are often confused by the structure of Go binaries, which\nthey dont see as often as those compiled from other languages.\nIf youve just installed the Go distribution and the system reports it is infected, thats certainly a mistake.\nTo be really thorough, you can verify the download by comparing the checksum with those on the\ndownloads page\n.\nIn any case, if you believe the report is in error, please report a bug to the supplier of your virus scanner.\nMaybe in time virus scanners can learn to understand Go programs.\nPerformance\nWhy does Go perform badly on benchmark X?\nOne of Gos design goals is to approach the performance of C for comparable\nprograms, yet on some benchmarks it does quite poorly, including several\nin\ngolang.org/x/exp/shootout\n.\nThe slowest depend on libraries for which versions of comparable performance\nare not available in Go.\nFor instance,\npidigits.go\ndepends on a multi-precision math package, and the C\nversions, unlike Gos, use\nGMP\n(which is\nwritten in optimized assembler).\nBenchmarks that depend on regular expressions\n(\nregex-dna.go\n,\nfor instance) are essentially comparing Gos native\nregexp package\nto\nmature, highly optimized regular expression libraries like PCRE.\nBenchmark games are won by extensive tuning and the Go versions of most\nof the benchmarks need attention.  If you measure truly comparable C\nand Go programs\n(\nreverse-complement.go\nis one example), youll see the two languages are much closer in raw performance\nthan this suite would indicate.\nStill, there is room for improvement. The compilers are good but could be\nbetter, many libraries need major performance work, and the garbage collector\nisnt fast enough yet. (Even if it were, taking care not to generate unnecessary\ngarbage can have a huge effect.)\nIn any case, Go can often be very competitive.\nThere has been significant improvement in the performance of many programs\nas the language and tools have developed.\nSee the blog post about\nprofiling\nGo programs\nfor an informative example.\nIts quite old but still contains helpful information.\nChanges from C\nWhy is the syntax so different from C?\nOther than declaration syntax, the differences are not major and stem\nfrom two desires.  First, the syntax should feel light, without too\nmany mandatory keywords, repetition, or arcana.  Second, the language\nhas been designed to be easy to analyze\nand can be parsed without a symbol table.  This makes it much easier\nto build tools such as debuggers, dependency analyzers, automated\ndocumentation extractors, IDE plug-ins, and so on.  C and its\ndescendants are notoriously difficult in this regard.\nWhy are declarations backwards?\nTheyre only backwards if youre used to C. In C, the notion is that a\nvariable is declared like an expression denoting its type, which is a\nnice idea, but the type and expression grammars dont mix very well and\nthe results can be confusing; consider function pointers.  Go mostly\nseparates expression and type syntax and that simplifies things (using\nprefix\n*\nfor pointers is an exception that proves the rule).  In C,\nthe declaration\nint* a, b;\ndeclares\na\nto be a pointer but not\nb\n; in Go\nvar a, b *int\ndeclares both to be pointers.  This is clearer and more regular.\nAlso, the\n:=\nshort declaration form argues that a full variable\ndeclaration should present the same order as\n:=\nso\nvar a uint64 = 1\nhas the same effect as\na := uint64(1)\nParsing is also simplified by having a distinct grammar for types that\nis not just the expression grammar; keywords such as\nfunc\nand\nchan\nkeep things clear.\nSee the article about\nGos Declaration Syntax\nfor more details.\nWhy is there no pointer arithmetic?\nSafety.  Without pointer arithmetic its possible to create a\nlanguage that can never derive an illegal address that succeeds\nincorrectly.  Compiler and hardware technology have advanced to the\npoint where a loop using array indices can be as efficient as a loop\nusing pointer arithmetic.  Also, the lack of pointer arithmetic can\nsimplify the implementation of the garbage collector.\nWhy are\n++\nand\n--\nstatements and not expressions?  And why postfix, not prefix?\nWithout pointer arithmetic, the convenience value of pre- and postfix\nincrement operators drops.  By removing them from the expression\nhierarchy altogether, expression syntax is simplified and the messy\nissues around order of evaluation of\n++\nand\n--\n(consider\nf(i++)\nand\np[i] = q[++i]\n)\nare eliminated as well.  The simplification is\nsignificant.  As for postfix vs. prefix, either would work fine but\nthe postfix version is more traditional; insistence on prefix arose\nwith the STL, a library for a language whose name contains, ironically, a\npostfix increment.\nWhy are there braces but no semicolons? And why cant I put the opening brace on the next line?\nGo uses brace brackets for statement grouping, a syntax familiar to\nprogrammers who have worked with any language in the C family.\nSemicolons, however, are for parsers, not for people, and we wanted to\neliminate them as much as possible.  To achieve this goal, Go borrows\na trick from BCPL: the semicolons that separate statements are in the\nformal grammar but are injected automatically, without lookahead, by\nthe lexer at the end of any line that could be the end of a statement.\nThis works very well in practice but has the effect that it forces a\nbrace style.  For instance, the opening brace of a function cannot\nappear on a line by itself.\nSome have argued that the lexer should do lookahead to permit the\nbrace to live on the next line.  We disagree.  Since Go code is meant\nto be formatted automatically by\ngofmt\n,\nsome\nstyle must be chosen.  That style may differ from what\nyouve used in C or Java, but Go is a different language and\ngofmt\ns style is as good as any other.  More\nimportantmuch more importantthe advantages of a single,\nprogrammatically mandated format for all Go programs greatly outweigh\nany perceived disadvantages of the particular style.\nNote too that Gos style means that an interactive implementation of\nGo can use the standard syntax one line at a time without special rules.\nWhy do garbage collection?  Wont it be too expensive?\nOne of the biggest sources of bookkeeping in systems programs is\nmanaging the lifetimes of allocated objects.\nIn languages such as C in which it is done manually,\nit can consume a significant amount of programmer time and is\noften the cause of pernicious bugs.\nEven in languages like C++ or Rust that provide mechanisms\nto assist, those mechanisms can have a significant effect on the\ndesign of the software, often adding programming overhead\nof its own.\nWe felt it was critical to eliminate such\nprogrammer overheads, and advances in garbage collection\ntechnology in the last few years gave us confidence that it\ncould be implemented cheaply enough, and with low enough\nlatency, that it could be a viable approach for networked\nsystems.\nMuch of the difficulty of concurrent programming\nhas its roots in the object lifetime problem:\nas objects get passed among threads it becomes cumbersome\nto guarantee they become freed safely.\nAutomatic garbage collection makes concurrent code far easier to write.\nOf course, implementing garbage collection in a concurrent environment is\nitself a challenge, but meeting it once rather than in every\nprogram helps everyone.\nFinally, concurrency aside, garbage collection makes interfaces\nsimpler because they dont need to specify how memory is managed across them.\nThis is not to say that the recent work in languages\nlike Rust that bring new ideas to the problem of managing\nresources is misguided; we encourage this work and are excited to see\nhow it evolves.\nBut Go takes a more traditional approach by addressing\nobject lifetimes through\ngarbage collection, and garbage collection alone.\nThe current implementation is a mark-and-sweep collector.\nIf the machine is a multiprocessor, the collector runs on a separate CPU\ncore in parallel with the main program.\nMajor work on the collector in recent years has reduced pause times\noften to the sub-millisecond range, even for large heaps,\nall but eliminating one of the major objections to garbage collection\nin networked servers.\nWork continues to refine the algorithm, reduce overhead and\nlatency further, and to explore new approaches.\nThe 2018\nISMM keynote\nby Rick Hudson of the Go team\ndescribes the progress so far and suggests some future approaches.\nOn the topic of performance, keep in mind that Go gives the programmer\nconsiderable control over memory layout and allocation, much more than\nis typical in garbage-collected languages. A careful programmer can reduce\nthe garbage collection overhead dramatically by using the language well;\nsee the article about\nprofiling Go programs\nfor a worked example,\nincluding a demonstration of Gos profiling tools.\nRelease Notes\nLearn about what's new in each Go release.\nView release notes\nCode of Conduct\nGuidelines for participating in Go community spaces and reporting process for handing issues.\nView more\nBrand Guidelines\nGuidance about reusing the Go logo, gopher mascot, etc.\nView guidelines\nContribute Guide\nLearn how to file bugs, pull requests, or otherwise contribute to the Go ecosystem.\nView guide\nGet connected",
      "code_examples": [
        {
          "language": "",
          "code": "foo.Foo* myFoo = new(foo.Foo)",
          "element": "<code>foo.Foo* myFoo = new(foo.Foo)</code>"
        },
        {
          "language": "",
          "code": "dl.google.com",
          "element": "<code>dl.google.com</code>"
        },
        {
          "language": "",
          "code": "try-catch-finally",
          "element": "<code>try-catch-finally</code>"
        },
        {
          "language": "",
          "code": "fmt.Fprintf",
          "element": "<code>fmt.Fprintf</code>"
        },
        {
          "language": "",
          "code": "type T struct{}\nvar _ I = T{}       // Verify that T implements I.\nvar _ I = (*T)(nil) // Verify that *T implements I.",
          "element": "<pre><code>type T struct{}\nvar _ I = T{}       // Verify that T implements I.\nvar _ I = (*T)(nil) // Verify that *T implements I.\n</code></pre>"
        },
        {
          "language": "",
          "code": "type T struct{}\nvar _ I = T{}       // Verify that T implements I.\nvar _ I = (*T)(nil) // Verify that *T implements I.",
          "element": "<code>type T struct{}\nvar _ I = T{}       // Verify that T implements I.\nvar _ I = (*T)(nil) // Verify that *T implements I.\n</code>"
        },
        {
          "language": "",
          "code": "type Fooer interface {\n    Foo()\n    ImplementsFooer()\n}",
          "element": "<pre><code>type Fooer interface {\n    Foo()\n    ImplementsFooer()\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "type Fooer interface {\n    Foo()\n    ImplementsFooer()\n}",
          "element": "<code>type Fooer interface {\n    Foo()\n    ImplementsFooer()\n}\n</code>"
        },
        {
          "language": "",
          "code": "ImplementsFooer",
          "element": "<code>ImplementsFooer</code>"
        },
        {
          "language": "",
          "code": "type Bar struct{}\nfunc (b Bar) ImplementsFooer() {}\nfunc (b Bar) Foo() {}",
          "element": "<pre><code>type Bar struct{}\nfunc (b Bar) ImplementsFooer() {}\nfunc (b Bar) Foo() {}\n</code></pre>"
        },
        {
          "language": "",
          "code": "type Bar struct{}\nfunc (b Bar) ImplementsFooer() {}\nfunc (b Bar) Foo() {}",
          "element": "<code>type Bar struct{}\nfunc (b Bar) ImplementsFooer() {}\nfunc (b Bar) Foo() {}\n</code>"
        },
        {
          "language": "",
          "code": "type Equaler interface {\n    Equal(Equaler) bool\n}",
          "element": "<pre><code>type Equaler interface {\n    Equal(Equaler) bool\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "type Equaler interface {\n    Equal(Equaler) bool\n}",
          "element": "<code>type Equaler interface {\n    Equal(Equaler) bool\n}\n</code>"
        },
        {
          "language": "",
          "code": "type T int\nfunc (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler",
          "element": "<pre><code>type T int\nfunc (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler\n</code></pre>"
        },
        {
          "language": "",
          "code": "type T int\nfunc (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler",
          "element": "<code>type T int\nfunc (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler\n</code>"
        },
        {
          "language": "",
          "code": "type T2 int\nfunc (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler",
          "element": "<pre><code>type T2 int\nfunc (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler\n</code></pre>"
        },
        {
          "language": "",
          "code": "type T2 int\nfunc (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler",
          "element": "<code>type T2 int\nfunc (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler\n</code>"
        },
        {
          "language": "",
          "code": "type Opener interface {\n   Open() Reader\n}\n\nfunc (t T3) Open() *os.File",
          "element": "<pre><code>type Opener interface {\n   Open() Reader\n}\n\nfunc (t T3) Open() *os.File\n</code></pre>"
        },
        {
          "language": "",
          "code": "type Opener interface {\n   Open() Reader\n}\n\nfunc (t T3) Open() *os.File",
          "element": "<code>type Opener interface {\n   Open() Reader\n}\n\nfunc (t T3) Open() *os.File\n</code>"
        },
        {
          "language": "",
          "code": "interface{}",
          "element": "<code>interface{}</code>"
        },
        {
          "language": "",
          "code": "t := []int{1, 2, 3, 4}\ns := make([]interface{}, len(t))\nfor i, v := range t {\n    s[i] = v\n}",
          "element": "<pre><code>t := []int{1, 2, 3, 4}\ns := make([]interface{}, len(t))\nfor i, v := range t {\n    s[i] = v\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "t := []int{1, 2, 3, 4}\ns := make([]interface{}, len(t))\nfor i, v := range t {\n    s[i] = v\n}",
          "element": "<code>t := []int{1, 2, 3, 4}\ns := make([]interface{}, len(t))\nfor i, v := range t {\n    s[i] = v\n}\n</code>"
        },
        {
          "language": "",
          "code": "type T1 int\ntype T2 int\nvar t1 T1\nvar x = T2(t1) // OK\nvar st1 []T1\nvar sx = ([]T2)(st1) // NOT OK",
          "element": "<pre><code>type T1 int\ntype T2 int\nvar t1 T1\nvar x = T2(t1) // OK\nvar st1 []T1\nvar sx = ([]T2)(st1) // NOT OK\n</code></pre>"
        },
        {
          "language": "",
          "code": "type T1 int\ntype T2 int\nvar t1 T1\nvar x = T2(t1) // OK\nvar st1 []T1\nvar sx = ([]T2)(st1) // NOT OK",
          "element": "<code>type T1 int\ntype T2 int\nvar t1 T1\nvar x = T2(t1) // OK\nvar st1 []T1\nvar sx = ([]T2)(st1) // NOT OK\n</code>"
        },
        {
          "language": "",
          "code": "func returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n    return p // Will always return a non-nil error.\n}",
          "element": "<pre><code>func returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n    return p // Will always return a non-nil error.\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n    return p // Will always return a non-nil error.\n}",
          "element": "<code>func returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n    return p // Will always return a non-nil error.\n}\n</code>"
        },
        {
          "language": "",
          "code": "func returnsError() error {\n    if bad() {\n        return ErrBad\n    }\n    return nil\n}",
          "element": "<pre><code>func returnsError() error {\n    if bad() {\n        return ErrBad\n    }\n    return nil\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func returnsError() error {\n    if bad() {\n        return ErrBad\n    }\n    return nil\n}",
          "element": "<code>func returnsError() error {\n    if bad() {\n        return ErrBad\n    }\n    return nil\n}\n</code>"
        },
        {
          "language": "",
          "code": "*os.PathError",
          "element": "<code>*os.PathError</code>"
        },
        {
          "language": "",
          "code": "map[int]struct{}",
          "element": "<code>map[int]struct{}</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    type S struct {\n        f1 byte\n        f2 struct{}\n    }\n    fmt.Println(unsafe.Sizeof(S{}))\n}",
          "element": "<pre><code>func main() {\n    type S struct {\n        f1 byte\n        f2 struct{}\n    }\n    fmt.Println(unsafe.Sizeof(S{}))\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func main() {\n    type S struct {\n        f1 byte\n        f2 struct{}\n    }\n    fmt.Println(unsafe.Sizeof(S{}))\n}",
          "element": "<code>func main() {\n    type S struct {\n        f1 byte\n        f2 struct{}\n    }\n    fmt.Println(unsafe.Sizeof(S{}))\n}\n</code>"
        },
        {
          "language": "",
          "code": "type Copyable interface {\n    Copy() interface{}\n}",
          "element": "<pre><code>type Copyable interface {\n    Copy() interface{}\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "type Copyable interface {\n    Copy() interface{}\n}",
          "element": "<code>type Copyable interface {\n    Copy() interface{}\n}\n</code>"
        },
        {
          "language": "",
          "code": "func (v Value) Copy() Value",
          "element": "<pre><code>func (v Value) Copy() Value\n</code></pre>"
        },
        {
          "language": "",
          "code": "func (v Value) Copy() Value",
          "element": "<code>func (v Value) Copy() Value\n</code>"
        },
        {
          "language": "",
          "code": "sqrt2 := math.Sqrt(2)",
          "element": "<pre><code>sqrt2 := math.Sqrt(2)\n</code></pre>"
        },
        {
          "language": "",
          "code": "sqrt2 := math.Sqrt(2)",
          "element": "<code>sqrt2 := math.Sqrt(2)\n</code>"
        },
        {
          "language": "",
          "code": "$HOME/.netrc",
          "element": "<code>$HOME/.netrc</code>"
        },
        {
          "language": "",
          "code": "machine github.com login *USERNAME* password *APIKEY*",
          "element": "<pre><code>machine github.com login *USERNAME* password *APIKEY*\n</code></pre>"
        },
        {
          "language": "",
          "code": "machine github.com login *USERNAME* password *APIKEY*",
          "element": "<code>machine github.com login *USERNAME* password *APIKEY*\n</code>"
        },
        {
          "language": "",
          "code": "~/.gitconfig",
          "element": "<code>~/.gitconfig</code>"
        },
        {
          "language": "",
          "code": "[url \"ssh://git@github.com/\"]\n    insteadOf = https://github.com/",
          "element": "<pre><code>[url \"ssh://git@github.com/\"]\n    insteadOf = https://github.com/\n</code></pre>"
        },
        {
          "language": "",
          "code": "[url \"ssh://git@github.com/\"]\n    insteadOf = https://github.com/",
          "element": "<code>[url \"ssh://git@github.com/\"]\n    insteadOf = https://github.com/\n</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "go mod init example/project",
          "element": "<pre><code>go mod init example/project\n</code></pre>"
        },
        {
          "language": "",
          "code": "go mod init example/project",
          "element": "<code>go mod init example/project\n</code>"
        },
        {
          "language": "",
          "code": "go get golang.org/x/text@v0.3.5",
          "element": "<pre><code>go get golang.org/x/text@v0.3.5\n</code></pre>"
        },
        {
          "language": "",
          "code": "go get golang.org/x/text@v0.3.5",
          "element": "<code>go get golang.org/x/text@v0.3.5\n</code>"
        },
        {
          "language": "",
          "code": "var w io.Writer",
          "element": "<pre><code>var w io.Writer\n</code></pre>"
        },
        {
          "language": "",
          "code": "var w io.Writer",
          "element": "<code>var w io.Writer\n</code>"
        },
        {
          "language": "",
          "code": "fmt.Fprintf",
          "element": "<code>fmt.Fprintf</code>"
        },
        {
          "language": "",
          "code": "fmt.Fprintf(w, \"hello, world\\n\")",
          "element": "<pre><code>fmt.Fprintf(w, \"hello, world\\n\")\n</code></pre>"
        },
        {
          "language": "",
          "code": "fmt.Fprintf(w, \"hello, world\\n\")",
          "element": "<code>fmt.Fprintf(w, \"hello, world\\n\")\n</code>"
        },
        {
          "language": "",
          "code": "fmt.Fprintf(&w, \"hello, world\\n\") // Compile-time error.",
          "element": "<pre><code>fmt.Fprintf(&amp;w, \"hello, world\\n\") // Compile-time error.\n</code></pre>"
        },
        {
          "language": "",
          "code": "fmt.Fprintf(&w, \"hello, world\\n\") // Compile-time error.",
          "element": "<code>fmt.Fprintf(&amp;w, \"hello, world\\n\") // Compile-time error.\n</code>"
        },
        {
          "language": "",
          "code": "interface{}",
          "element": "<code>interface{}</code>"
        },
        {
          "language": "",
          "code": "func (s *MyStruct) pointerMethod() { } // method on pointer\nfunc (s MyStruct)  valueMethod()   { } // method on value",
          "element": "<pre><code>func (s *MyStruct) pointerMethod() { } // method on pointer\nfunc (s MyStruct)  valueMethod()   { } // method on value\n</code></pre>"
        },
        {
          "language": "",
          "code": "func (s *MyStruct) pointerMethod() { } // method on pointer\nfunc (s MyStruct)  valueMethod()   { } // method on value",
          "element": "<code>func (s *MyStruct) pointerMethod() { } // method on pointer\nfunc (s MyStruct)  valueMethod()   { } // method on value\n</code>"
        },
        {
          "language": "",
          "code": "pointerMethod",
          "element": "<code>pointerMethod</code>"
        },
        {
          "language": "",
          "code": "valueMethod",
          "element": "<code>valueMethod</code>"
        },
        {
          "language": "",
          "code": "var foo float32 = 3.0",
          "element": "<pre><code>var foo float32 = 3.0\n</code></pre>"
        },
        {
          "language": "",
          "code": "var foo float32 = 3.0",
          "element": "<code>var foo float32 = 3.0\n</code>"
        },
        {
          "language": "",
          "code": "foo := float32(3.0)",
          "element": "<code>foo := float32(3.0)</code>"
        },
        {
          "language": "",
          "code": "var buf bytes.Buffer\nio.Copy(buf, os.Stdin)",
          "element": "<pre><code>var buf bytes.Buffer\nio.Copy(buf, os.Stdin)\n</code></pre>"
        },
        {
          "language": "",
          "code": "var buf bytes.Buffer\nio.Copy(buf, os.Stdin)",
          "element": "<code>var buf bytes.Buffer\nio.Copy(buf, os.Stdin)\n</code>"
        },
        {
          "language": "",
          "code": "func main() {\n    done := make(chan bool)\n\n    values := []string{\"a\", \"b\", \"c\"}\n    for _, v := range values {\n        go func() {\n            fmt.Println(v)\n            done <- true\n        }()\n    }\n\n    // wait for all goroutines to complete before exiting\n    for _ = range values {\n        <-done\n    }\n}",
          "element": "<pre>\nfunc main() {\n    done := make(chan bool)\n\n    values := []string{\"a\", \"b\", \"c\"}\n    for _, v := range values {\n        go func() {\n            fmt.Println(v)\n            done &lt;- true\n       ..."
        },
        {
          "language": "",
          "code": "fmt.Println",
          "element": "<code>fmt.Println</code>"
        },
        {
          "language": "",
          "code": "for _, v := range values {\n        go func(ustring) {\n            fmt.Println(u)\n            done <- true\n        }(v)\n    }",
          "element": "<pre>\n    for _, v := range values {\n        go func(<b>u</b> string) {\n            fmt.Println(<b>u</b>)\n            done &lt;- true\n        }(<b>v</b>)\n    }\n</pre>"
        },
        {
          "language": "",
          "code": "for _, v := range values {v := v// create a new 'v'.\n        go func() {\n            fmt.Println(v)\n            done <- true\n        }()\n    }",
          "element": "<pre>\n    for _, v := range values {\n        <b>v := v</b> // create a new 'v'.\n        go func() {\n            fmt.Println(<b>v</b>)\n            done &lt;- true\n        }()\n    }\n</pre>"
        },
        {
          "language": "",
          "code": "if expr {\n    n = trueVal\n} else {\n    n = falseVal\n}",
          "element": "<pre><code>if expr {\n    n = trueVal\n} else {\n    n = falseVal\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "if expr {\n    n = trueVal\n} else {\n    n = falseVal\n}",
          "element": "<code>if expr {\n    n = trueVal\n} else {\n    n = falseVal\n}\n</code>"
        },
        {
          "language": "",
          "code": "List<Integer>",
          "element": "<code>List&lt;Integer&gt;</code>"
        },
        {
          "language": "",
          "code": "List<Integer>",
          "element": "<code>List&lt;Integer&gt;</code>"
        },
        {
          "language": "",
          "code": "List<Float>",
          "element": "<code>List&lt;Float&gt;</code>"
        },
        {
          "language": "",
          "code": "List<? extends Number>",
          "element": "<code>List&lt;? extends Number&gt;</code>"
        },
        {
          "language": "",
          "code": "List<? super Number>",
          "element": "<code>List&lt;? super Number&gt;</code>"
        },
        {
          "language": "",
          "code": "List<Integer>",
          "element": "<code>List&lt;Integer&gt;</code>"
        },
        {
          "language": "",
          "code": "std::vector<int>",
          "element": "<code>std::vector&lt;int&gt;</code>"
        },
        {
          "language": "",
          "code": "a, b = w < x, y > (z)",
          "element": "<pre>\n    a, b = w &lt; x, y &gt; (z)\n</pre>"
        },
        {
          "language": "",
          "code": "(w<x, y>)(z)",
          "element": "<code>(w&lt;x, y&gt;)(z)</code>"
        },
        {
          "language": "",
          "code": "type Empty struct{}\n\nfunc (Empty) Nop[T any](x T) T {\n    return x\n}",
          "element": "<pre><code>type Empty struct{}\n\nfunc (Empty) Nop[T any](x T) T {\n    return x\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "type Empty struct{}\n\nfunc (Empty) Nop[T any](x T) T {\n    return x\n}",
          "element": "<code>type Empty struct{}\n\nfunc (Empty) Nop[T any](x T) T {\n    return x\n}\n</code>"
        },
        {
          "language": "",
          "code": "func TryNops(x any) {\n    if x, ok := x.(interface{ Nop(string) string }); ok {\n        fmt.Printf(\"string %s\\n\", x.Nop(\"hello\"))\n    }\n    if x, ok := x.(interface{ Nop(int) int }); ok {\n        fmt.Printf(\"int %d\\n\", x.Nop(42))\n    }\n    if x, ok := x.(interface{ Nop(io.Reader) io.Reader }); ok {\n        data, err := io.ReadAll(x.Nop(strings.NewReader(\"hello world\")))\n        fmt.Printf(\"reader %q %v\\n\", data, err)\n    }\n}",
          "element": "<pre><code>func TryNops(x any) {\n    if x, ok := x.(interface{ Nop(string) string }); ok {\n        fmt.Printf(\"string %s\\n\", x.Nop(\"hello\"))\n    }\n    if x, ok := x.(interface{ Nop(int) int }); ok {\n ..."
        },
        {
          "language": "",
          "code": "func TryNops(x any) {\n    if x, ok := x.(interface{ Nop(string) string }); ok {\n        fmt.Printf(\"string %s\\n\", x.Nop(\"hello\"))\n    }\n    if x, ok := x.(interface{ Nop(int) int }); ok {\n        fmt.Printf(\"int %d\\n\", x.Nop(42))\n    }\n    if x, ok := x.(interface{ Nop(io.Reader) io.Reader }); ok {\n        data, err := io.ReadAll(x.Nop(strings.NewReader(\"hello world\")))\n        fmt.Printf(\"reader %q %v\\n\", data, err)\n    }\n}",
          "element": "<code>func TryNops(x any) {\n    if x, ok := x.(interface{ Nop(string) string }); ok {\n        fmt.Printf(\"string %s\\n\", x.Nop(\"hello\"))\n    }\n    if x, ok := x.(interface{ Nop(int) int }); ok {\n      ..."
        },
        {
          "language": "",
          "code": "type S[T any] struct { f T }\n\nfunc (s S[string]) Add(t string) string {\n    return s.f + t\n}",
          "element": "<pre><code>type S[T any] struct { f T }\n\nfunc (s S[string]) Add(t string) string {\n    return s.f + t\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "type S[T any] struct { f T }\n\nfunc (s S[string]) Add(t string) string {\n    return s.f + t\n}",
          "element": "<code>type S[T any] struct { f T }\n\nfunc (s S[string]) Add(t string) string {\n    return s.f + t\n}\n</code>"
        },
        {
          "language": "",
          "code": "operator + not defined on s.f (variable of type string)",
          "element": "<code>operator + not defined on s.f (variable of type string)</code>"
        },
        {
          "language": "",
          "code": "import \"testing\"",
          "element": "<code>import \"testing\"</code>"
        },
        {
          "language": "",
          "code": "func TestFoo(t *testing.T) {\n    ...\n}",
          "element": "<pre><code>func TestFoo(t *testing.T) {\n    ...\n}\n</code></pre>"
        },
        {
          "language": "",
          "code": "func TestFoo(t *testing.T) {\n    ...\n}",
          "element": "<code>func TestFoo(t *testing.T) {\n    ...\n}\n</code>"
        },
        {
          "language": "",
          "code": "-ldflags=-w",
          "element": "<code>-ldflags=-w</code>"
        },
        {
          "language": "",
          "code": "import \"unused\"\n\n// This declaration marks the import as used by referencing an\n// item from the package.\nvar _ = unused.Item  // TODO: Delete before committing!\n\nfunc main() {\n    debugData := debug.Profile()\n    _ = debugData // Used only during debugging.\n    ....\n}",
          "element": "<pre><code>import \"unused\"\n\n// This declaration marks the import as used by referencing an\n// item from the package.\nvar _ = unused.Item  // TODO: Delete before committing!\n\nfunc main() {\n    debugDat..."
        },
        {
          "language": "",
          "code": "import \"unused\"\n\n// This declaration marks the import as used by referencing an\n// item from the package.\nvar _ = unused.Item  // TODO: Delete before committing!\n\nfunc main() {\n    debugData := debug.Profile()\n    _ = debugData // Used only during debugging.\n    ....\n}",
          "element": "<code>import \"unused\"\n\n// This declaration marks the import as used by referencing an\n// item from the package.\nvar _ = unused.Item  // TODO: Delete before committing!\n\nfunc main() {\n    debugData := ..."
        },
        {
          "language": "",
          "code": "var a, b *int",
          "element": "<pre><code>    var a, b *int\n</code></pre>"
        },
        {
          "language": "",
          "code": "var a, b *int",
          "element": "<code>    var a, b *int\n</code>"
        },
        {
          "language": "",
          "code": "var a uint64 = 1",
          "element": "<pre><code>    var a uint64 = 1\n</code></pre>"
        },
        {
          "language": "",
          "code": "var a uint64 = 1",
          "element": "<code>    var a uint64 = 1\n</code>"
        },
        {
          "language": "",
          "code": "a := uint64(1)",
          "element": "<pre><code>    a := uint64(1)\n</code></pre>"
        },
        {
          "language": "",
          "code": "a := uint64(1)",
          "element": "<code>    a := uint64(1)\n</code>"
        },
        {
          "language": "",
          "code": "p[i] = q[++i]",
          "element": "<code>p[i] = q[++i]</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Frequently Asked Questions (FAQ)",
          "id": ""
        },
        {
          "level": 2,
          "text": "Origins",
          "id": "Origins"
        },
        {
          "level": 2,
          "text": "Usage",
          "id": "Usage"
        },
        {
          "level": 2,
          "text": "Design",
          "id": "Design"
        },
        {
          "level": 2,
          "text": "Types",
          "id": "types"
        },
        {
          "level": 2,
          "text": "Values",
          "id": "Values"
        },
        {
          "level": 2,
          "text": "Writing Code",
          "id": "Writing_Code"
        },
        {
          "level": 2,
          "text": "Pointers and Allocation",
          "id": "Pointers"
        },
        {
          "level": 2,
          "text": "Concurrency",
          "id": "Concurrency"
        },
        {
          "level": 2,
          "text": "Functions and Methods",
          "id": "Functions_methods"
        },
        {
          "level": 2,
          "text": "Control Flow",
          "id": "Control_flow"
        },
        {
          "level": 2,
          "text": "Type Parameters",
          "id": "Type_Parameters"
        },
        {
          "level": 2,
          "text": "Packages and Testing",
          "id": "Packages_Testing"
        },
        {
          "level": 2,
          "text": "Implementation",
          "id": "Implementation"
        },
        {
          "level": 2,
          "text": "Performance",
          "id": "Performance"
        },
        {
          "level": 2,
          "text": "Changes from C",
          "id": "change_from_c"
        },
        {
          "level": 3,
          "text": "What is the purpose of the project?",
          "id": "What_is_the_purpose_of_the_project"
        },
        {
          "level": 3,
          "text": "What is the history of the project?",
          "id": "history"
        },
        {
          "level": 3,
          "text": "Whats the origin of the gopher mascot?",
          "id": "gopher"
        },
        {
          "level": 3,
          "text": "Is the language called Go or Golang?",
          "id": "go_or_golang"
        },
        {
          "level": 3,
          "text": "Why did you create a new language?",
          "id": "creating_a_new_language"
        },
        {
          "level": 3,
          "text": "What are Gos ancestors?",
          "id": "ancestors"
        },
        {
          "level": 3,
          "text": "What are the guiding principles in the design?",
          "id": "principles"
        },
        {
          "level": 3,
          "text": "Is Google using Go internally?",
          "id": "internal_usage"
        },
        {
          "level": 3,
          "text": "What other companies use Go?",
          "id": "external_usage"
        },
        {
          "level": 3,
          "text": "Do Go programs link with C/C++ programs?",
          "id": "Do_Go_programs_link_with_Cpp_programs"
        },
        {
          "level": 3,
          "text": "What IDEs does Go support?",
          "id": "ide"
        },
        {
          "level": 3,
          "text": "Does Go support Googles protocol buffers?",
          "id": "protocol_buffers"
        },
        {
          "level": 3,
          "text": "Does Go have a runtime?",
          "id": "runtime"
        },
        {
          "level": 3,
          "text": "Whats up with Unicode identifiers?",
          "id": "unicode_identifiers"
        },
        {
          "level": 3,
          "text": "Why does Go not have feature X?",
          "id": "Why_doesnt_Go_have_feature_X"
        },
        {
          "level": 3,
          "text": "When did Go get generic types?",
          "id": "generics"
        },
        {
          "level": 3,
          "text": "Why was Go initially released without generic types?",
          "id": "beginning_generics"
        },
        {
          "level": 3,
          "text": "Why does Go not have exceptions?",
          "id": "exceptions"
        },
        {
          "level": 3,
          "text": "Why does Go not have assertions?",
          "id": "assertions"
        },
        {
          "level": 3,
          "text": "Why build concurrency on the ideas of CSP?",
          "id": "csp"
        },
        {
          "level": 3,
          "text": "Why goroutines instead of threads?",
          "id": "goroutines"
        },
        {
          "level": 3,
          "text": "Why are map operations not defined to be atomic?",
          "id": "atomic_maps"
        },
        {
          "level": 3,
          "text": "Will you accept my language change?",
          "id": "language_changes"
        },
        {
          "level": 3,
          "text": "Is Go an object-oriented language?",
          "id": "Is_Go_an_object-oriented_language"
        },
        {
          "level": 3,
          "text": "How do I get dynamic dispatch of methods?",
          "id": "How_do_I_get_dynamic_dispatch_of_methods"
        },
        {
          "level": 3,
          "text": "Why is there no type inheritance?",
          "id": "inheritance"
        },
        {
          "level": 3,
          "text": "Why islena function and not a method?",
          "id": "methods_on_basics"
        },
        {
          "level": 3,
          "text": "Why does Go not support overloading of methods and operators?",
          "id": "overloading"
        },
        {
          "level": 3,
          "text": "Why doesnt Go have implements declarations?",
          "id": "implements_interface"
        },
        {
          "level": 3,
          "text": "How can I guarantee my type satisfies an interface?",
          "id": "guarantee_satisfies_interface"
        },
        {
          "level": 3,
          "text": "Why doesnt type T satisfy the Equal interface?",
          "id": "t_and_equal_interface"
        },
        {
          "level": 3,
          "text": "Can I convert a []T to an []interface{}?",
          "id": "convert_slice_of_interface"
        },
        {
          "level": 3,
          "text": "Can I convert []T1 to []T2 if T1 and T2 have the same underlying type?",
          "id": "convert_slice_with_same_underlying_type"
        },
        {
          "level": 3,
          "text": "Why is my nil error value not equal to nil?",
          "id": "nil_error"
        },
        {
          "level": 3,
          "text": "Why do zero-size types behave oddly?",
          "id": "zero_size_types"
        },
        {
          "level": 3,
          "text": "Why are there no untagged unions, as in C?",
          "id": "unions"
        },
        {
          "level": 3,
          "text": "Why does Go not have variant types?",
          "id": "variant_types"
        },
        {
          "level": 3,
          "text": "Why does Go not have covariant result types?",
          "id": "covariant_types"
        },
        {
          "level": 3,
          "text": "Why does Go not provide implicit numeric conversions?",
          "id": "conversions"
        },
        {
          "level": 3,
          "text": "How do constants work in Go?",
          "id": "constants"
        },
        {
          "level": 3,
          "text": "Why are maps built in?",
          "id": "builtin_maps"
        },
        {
          "level": 3,
          "text": "Why dont maps allow slices as keys?",
          "id": "map_keys"
        },
        {
          "level": 3,
          "text": "Why are maps, slices, and channels references while arrays are values?",
          "id": "references"
        },
        {
          "level": 3,
          "text": "How are libraries documented?",
          "id": "How_are_libraries_documented"
        },
        {
          "level": 3,
          "text": "Is there a Go programming style guide?",
          "id": "Is_there_a_Go_programming_style_guide"
        },
        {
          "level": 3,
          "text": "How do I submit patches to the Go libraries?",
          "id": "How_do_I_submit_patches_to_the_Go_libraries"
        },
        {
          "level": 3,
          "text": "Why does go get use HTTPS when cloning a repository?",
          "id": "git_https"
        },
        {
          "level": 3,
          "text": "How should I manage package versions using go get?",
          "id": "get_version"
        },
        {
          "level": 3,
          "text": "When are function parameters passed by value?",
          "id": "pass_by_value"
        },
        {
          "level": 3,
          "text": "When should I use a pointer to an interface?",
          "id": "pointer_to_interface"
        },
        {
          "level": 3,
          "text": "Should I define methods on values or pointers?",
          "id": "methods_on_values_or_pointers"
        },
        {
          "level": 3,
          "text": "Whats the difference between new and make?",
          "id": "new_and_make"
        },
        {
          "level": 3,
          "text": "What is the size of aninton a 64 bit machine?",
          "id": "q_int_sizes"
        },
        {
          "level": 3,
          "text": "How do I know whether a variable is allocated on the heap or the stack?",
          "id": "stack_or_heap"
        },
        {
          "level": 3,
          "text": "Why does my Go process use so much virtual memory?",
          "id": "Why_does_my_Go_process_use_so_much_virtual_memory"
        },
        {
          "level": 3,
          "text": "What operations are atomic? What about mutexes?",
          "id": "What_operations_are_atomic_What_about_mutexes"
        },
        {
          "level": 3,
          "text": "Why doesnt my program run faster with more CPUs?",
          "id": "parallel_slow"
        },
        {
          "level": 3,
          "text": "How can I control the number of CPUs?",
          "id": "number_cpus"
        },
        {
          "level": 3,
          "text": "Why is there no goroutine ID?",
          "id": "no_goroutine_id"
        },
        {
          "level": 3,
          "text": "Why do T and *T have different method sets?",
          "id": "different_method_sets"
        },
        {
          "level": 3,
          "text": "What happens with closures running as goroutines?",
          "id": "closures_and_goroutines"
        },
        {
          "level": 3,
          "text": "Why does Go not have the?:operator?",
          "id": "Does_Go_have_a_ternary_form"
        },
        {
          "level": 3,
          "text": "Why does Go have type parameters?",
          "id": "why_generics"
        },
        {
          "level": 3,
          "text": "How are generics implemented in Go?",
          "id": "generics_implementation"
        },
        {
          "level": 3,
          "text": "How do generics in Go compare to generics in other languages?",
          "id": "generics_comparison"
        },
        {
          "level": 3,
          "text": "Why does Go use square brackets for type parameter lists?",
          "id": "generic_brackets"
        },
        {
          "level": 3,
          "text": "Why does Go not support methods with type parameters?",
          "id": "generic_methods"
        },
        {
          "level": 3,
          "text": "Why cant I use a more specific type for the receiver of a parameterized type?",
          "id": "types_in_method_declaration"
        },
        {
          "level": 3,
          "text": "Why cant the compiler infer the type argument in my program?",
          "id": "type_inference"
        },
        {
          "level": 3,
          "text": "How do I create a multifile package?",
          "id": "How_do_I_create_a_multifile_package"
        },
        {
          "level": 3,
          "text": "How do I write a unit test?",
          "id": "How_do_I_write_a_unit_test"
        },
        {
          "level": 3,
          "text": "Where is my favorite helper function for testing?",
          "id": "testing_framework"
        },
        {
          "level": 3,
          "text": "Why isntXin the standard library?",
          "id": "x_in_std"
        },
        {
          "level": 3,
          "text": "What compiler technology is used to build the compilers?",
          "id": "What_compiler_technology_is_used_to_build_the_compilers"
        },
        {
          "level": 3,
          "text": "How is the run-time support implemented?",
          "id": "How_is_the_run_time_support_implemented"
        },
        {
          "level": 3,
          "text": "Why is my trivial program such a large binary?",
          "id": "Why_is_my_trivial_program_such_a_large_binary"
        },
        {
          "level": 3,
          "text": "Can I stop these complaints about my unused variable/import?",
          "id": "unused_variables_and_imports"
        },
        {
          "level": 3,
          "text": "Why does my virus-scanning software think my Go distribution or compiled binary is infected?",
          "id": "virus"
        },
        {
          "level": 3,
          "text": "Why does Go perform badly on benchmark X?",
          "id": "Why_does_Go_perform_badly_on_benchmark_x"
        },
        {
          "level": 3,
          "text": "Why is the syntax so different from C?",
          "id": "different_syntax"
        },
        {
          "level": 3,
          "text": "Why are declarations backwards?",
          "id": "declarations_backwards"
        },
        {
          "level": 3,
          "text": "Why is there no pointer arithmetic?",
          "id": "no_pointer_arithmetic"
        },
        {
          "level": 3,
          "text": "Why are++and--statements and not expressions?  And why postfix, not prefix?",
          "id": "inc_dec"
        },
        {
          "level": 3,
          "text": "Why are there braces but no semicolons? And why cant I put the opening brace on the next line?",
          "id": "semicolons"
        },
        {
          "level": 3,
          "text": "Why do garbage collection?  Wont it be too expensive?",
          "id": "garbage_collection"
        },
        {
          "level": 4,
          "text": "Release Notes",
          "id": ""
        },
        {
          "level": 4,
          "text": "Code of Conduct",
          "id": ""
        },
        {
          "level": 4,
          "text": "Brand Guidelines",
          "id": ""
        },
        {
          "level": 4,
          "text": "Contribute Guide",
          "id": ""
        },
        {
          "level": 4,
          "text": "Get connected",
          "id": ""
        }
      ],
      "timestamp": 1750757601.424623
    },
    {
      "url": "https://golang.org/doc/diagnostics.html",
      "title": "Diagnostics - The Go Programming Language",
      "content": "Documentation\nDiagnostics\nDiagnostics\nIntroduction\nThe Go ecosystem provides a large suite of APIs and tools to\ndiagnose logic and performance problems in Go programs. This page\nsummarizes the available tools and helps Go users pick the right one\nfor their specific problem.\nDiagnostics solutions can be categorized into the following groups:\nProfiling\n: Profiling tools analyze the complexity and costs of a\nGo program such as its memory usage and frequently called\nfunctions to identify the expensive sections of a Go program.\nTracing\n: Tracing is a way to instrument code to analyze latency\nthroughout the lifecycle of a call or user request. Traces provide an\noverview of how much latency each component contributes to the overall\nlatency in a system. Traces can span multiple Go processes.\nDebugging\n: Debugging allows us to pause a Go program and examine\nits execution. Program state and flow can be verified with debugging.\nRuntime statistics and events\n: Collection and analysis of runtime stats and events\nprovides a high-level overview of the health of Go programs. Spikes/dips of metrics\nhelps us to identify changes in throughput, utilization, and performance.\nNote: Some diagnostics tools may interfere with each other. For example, precise\nmemory profiling skews CPU profiles and goroutine blocking profiling affects scheduler\ntrace. Use tools in isolation to get more precise info.\nProfiling\nProfiling is useful for identifying expensive or frequently called sections\nof code. The Go runtime provides\nprofiling data\nin the format expected by the\npprof visualization tool\n.\nThe profiling data can be collected during testing\nvia\ngo\ntest\nor endpoints made available from the\nnet/http/pprof\npackage. Users need to collect the profiling data and use pprof tools to filter\nand visualize the top code paths.\nPredefined profiles provided by the\nruntime/pprof\npackage:\ncpu\n: CPU profile determines where a program spends\nits time while actively consuming CPU cycles (as opposed to while sleeping or waiting for I/O).\nheap\n: Heap profile reports memory allocation samples;\nused to monitor current and historical memory usage, and to check for memory leaks.\nthreadcreate\n: Thread creation profile reports the sections\nof the program that lead the creation of new OS threads.\ngoroutine\n: Goroutine profile reports the stack traces of all current goroutines.\nblock\n: Block profile shows where goroutines block waiting on synchronization\nprimitives (including timer channels). Block profile is not enabled by default;\nuse\nruntime.SetBlockProfileRate\nto enable it.\nmutex\n: Mutex profile reports the lock contentions. When you think your\nCPU is not fully utilized due to a mutex contention, use this profile. Mutex profile\nis not enabled by default, see\nruntime.SetMutexProfileFraction\nto enable it.\nWhat other profilers can I use to profile Go programs?\nOn Linux,\nperf tools\ncan be used for profiling Go programs. Perf can profile\nand unwind cgo/SWIG code and kernel, so it can be useful to get insights into\nnative/kernel performance bottlenecks. On macOS,\nInstruments\nsuite can be used profile Go programs.\nCan I profile my production services?\nYes. It is safe to profile programs in production, but enabling\nsome profiles (e.g. the CPU profile) adds cost. You should expect to\nsee performance downgrade. The performance penalty can be estimated\nby measuring the overhead of the profiler before turning it on in\nproduction.\nYou may want to periodically profile your production services.\nEspecially in a system with many replicas of a single process, selecting\na random replica periodically is a safe option.\nSelect a production process, profile it for\nX seconds for every Y seconds and save the results for visualization and\nanalysis; then repeat periodically. Results may be manually and/or automatically\nreviewed to find problems.\nCollection of profiles can interfere with each other,\nso it is recommended to collect only a single profile at a time.\nWhat are the best ways to visualize the profiling data?\nThe Go tools provide text, graph, and\ncallgrind\nvisualization of the profile data using\ngo tool pprof\n.\nRead\nProfiling Go programs\nto see them in action.\nListing of the most expensive calls as text.\nVisualization of the most expensive calls as a graph.\nWeblist view displays the expensive parts of the source line by line in\nan HTML page. In the following example, 530ms is spent in the\nruntime.concatstrings\nand cost of each line is presented\nin the listing.\nVisualization of the most expensive calls as weblist.\nAnother way to visualize profile data is a\nflame graph\n.\nFlame graphs allow you to move in a specific ancestry path, so you can zoom\nin/out of specific sections of code.\nThe\nupstream pprof\nhas support for flame graphs.\nFlame graphs offers visualization to spot the most expensive code-paths.\nAm I restricted to the built-in profiles?\nAdditionally to what is provided by the runtime, Go users can create\ntheir custom profiles via\npprof.Profile\nand use the existing tools to examine them.\nCan I serve the profiler handlers (/debug/pprof/...) on a different path and port?\nYes. The\nnet/http/pprof\npackage registers its handlers to the default\nmux by default, but you can also register them yourself by using the handlers\nexported from the package.\nFor example, the following example will serve the pprof.Profile\nhandler on :7777 at /custom_debug_path/profile:\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/custom_debug_path/profile\", pprof.Profile)\n\tlog.Fatal(http.ListenAndServe(\":7777\", mux))\n}\nTracing\nTracing is a way to instrument code to analyze latency throughout the\nlifecycle of a chain of calls. Go provides\ngolang.org/x/net/trace\npackage as a minimal tracing backend per Go node and provides a minimal\ninstrumentation library with a simple dashboard. Go also provides\nan execution tracer to trace the runtime events within an interval.\nTracing enables us to:\nInstrument and analyze application latency in a Go process.\nMeasure the cost of specific calls in a long chain of calls.\nFigure out the utilization and performance improvements.\nBottlenecks are not always obvious without tracing data.\nIn monolithic systems, it's relatively easy to collect diagnostic data\nfrom the building blocks of a program. All modules live within one\nprocess and share common resources to report logs, errors, and other\ndiagnostic information. Once your system grows beyond a single process and\nstarts to become distributed, it becomes harder to follow a call starting\nfrom the front-end web server to all of its back-ends until a response is\nreturned back to the user. This is where distributed tracing plays a big\nrole to instrument and analyze your production systems.\nDistributed tracing is a way to instrument code to analyze latency throughout\nthe lifecycle of a user request. When a system is distributed and when\nconventional profiling and debugging tools dont scale, you might want\nto use distributed tracing tools to analyze the performance of your user\nrequests and RPCs.\nDistributed tracing enables us to:\nInstrument and profile application latency in a large system.\nTrack all RPCs within the lifecycle of a user request and see integration issues\nthat are only visible in production.\nFigure out performance improvements that can be applied to our systems.\nMany bottlenecks are not obvious before the collection of tracing data.\nThe Go ecosystem provides various distributed tracing libraries per tracing system\nand backend-agnostic ones.\nIs there a way to automatically intercept each function call and create traces?\nGo doesnt provide a way to automatically intercept every function call and create\ntrace spans. You need to manually instrument your code to create, end, and annotate spans.\nHow should I propagate trace headers in Go libraries?\nYou can propagate trace identifiers and tags in the\ncontext.Context\n.\nThere is no canonical trace key or common representation of trace headers\nin the industry yet. Each tracing provider is responsible for providing propagation\nutilities in their Go libraries.\nWhat other low-level events from the standard library or\nruntime can be included in a trace?\nThe standard library and runtime are trying to expose several additional APIs\nto notify on low level internal events. For example,\nhttptrace.ClientTrace\nprovides APIs to follow low-level events in the life cycle of an outgoing request.\nThere is an ongoing effort to retrieve low-level runtime events from\nthe runtime execution tracer and allow users to define and record their user events.\nDebugging\nDebugging is the process of identifying why a program misbehaves.\nDebuggers allow us to understand a programs execution flow and current state.\nThere are several styles of debugging; this section will only focus on attaching\na debugger to a program and core dump debugging.\nGo users mostly use the following debuggers:\nDelve\n:\nDelve is a debugger for the Go programming language. It has\nsupport for Gos runtime concepts and built-in types. Delve is\ntrying to be a fully featured reliable debugger for Go programs.\nGDB\n:\nGo provides GDB support via the standard Go compiler and Gccgo.\nThe stack management, threading, and runtime contain aspects that differ\nenough from the execution model GDB expects that they can confuse the\ndebugger, even when the program is compiled with gccgo. Even though\nGDB can be used to debug Go programs, it is not ideal and may\ncreate confusion.\nHow well do debuggers work with Go programs?\nThe\ngc\ncompiler performs optimizations such as\nfunction inlining and variable registerization. These optimizations\nsometimes make debugging with debuggers harder. There is an ongoing\neffort to improve the quality of the DWARF information generated for\noptimized binaries. Until those improvements are available, we recommend\ndisabling optimizations when building the code being debugged. The following\ncommand builds a package with no compiler optimizations:\n$ go build -gcflags=all=\"-N -l\"\nAs part of the improvement effort, Go 1.10 introduced a new compiler\nflag\n-dwarflocationlists\n. The flag causes the compiler to\nadd location lists that helps debuggers work with optimized binaries.\nThe following command builds a package with optimizations but with\nthe DWARF location lists:\n$ go build -gcflags=\"-dwarflocationlists=true\"\nWhats the recommended debugger user interface?\nEven though both delve and gdb provides CLIs, most editor integrations\nand IDEs provides debugging-specific user interfaces.\nIs it possible to do postmortem debugging with Go programs?\nA core dump file is a file that contains the memory dump of a running\nprocess and its process status. It is primarily used for post-mortem\ndebugging of a program and to understand its state\nwhile it is still running. These two cases make debugging of core\ndumps a good diagnostic aid to postmortem and analyze production\nservices. It is possible to obtain core files from Go programs and\nuse delve or gdb to debug, see the\ncore dump debugging\npage for a step-by-step guide.\nRuntime statistics and events\nThe runtime provides stats and reporting of internal events for\nusers to diagnose performance and utilization problems at the\nruntime level.\nUsers can monitor these stats to better understand the overall\nhealth and performance of Go programs.\nSome frequently monitored stats and states:\nruntime.ReadMemStats\nreports the metrics related to heap\nallocation and garbage collection. Memory stats are useful for\nmonitoring how much memory resources a process is consuming,\nwhether the process can utilize memory well, and to catch\nmemory leaks.\ndebug.ReadGCStats\nreads statistics about garbage collection.\nIt is useful to see how much of the resources are spent on GC pauses.\nIt also reports a timeline of garbage collector pauses and pause time percentiles.\ndebug.Stack\nreturns the current stack trace. Stack trace\nis useful to see how many goroutines are currently running,\nwhat they are doing, and whether they are blocked or not.\ndebug.WriteHeapDump\nsuspends the execution of all goroutines\nand allows you to dump the heap to a file. A heap dump is a\nsnapshot of a Go process' memory at a given time. It contains all\nallocated objects as well as goroutines, finalizers, and more.\nruntime.NumGoroutine\nreturns the number of current goroutines.\nThe value can be monitored to see whether enough goroutines are\nutilized, or to detect goroutine leaks.\nExecution tracer\nGo comes with a runtime execution tracer to capture a wide range\nof runtime events. Scheduling, syscall, garbage collections,\nheap size, and other events are collected by runtime and available\nfor visualization by the go tool trace. Execution tracer is a tool\nto detect latency and utilization problems. You can examine how well\nthe CPU is utilized, and when networking or syscalls are a cause of\npreemption for the goroutines.\nTracer is useful to:\nUnderstand how your goroutines execute.\nUnderstand some of the core runtime events such as GC runs.\nIdentify poorly parallelized execution.\nHowever, it is not great for identifying hot spots such as\nanalyzing the cause of excessive memory or CPU usage.\nUse profiling tools instead first to address them.\nAbove, the go tool trace visualization shows the execution started\nfine, and then it became serialized. It suggests that there might\nbe lock contention for a shared resource that creates a bottleneck.\nSee\ngo\ntool\ntrace\nto collect and analyze runtime traces.\nGODEBUG\nRuntime also emits events and information if\nGODEBUG\nenvironmental variable is set accordingly.\nGODEBUG=gctrace=1 prints garbage collector events at\neach collection, summarizing the amount of memory collected\nand the length of the pause.\nGODEBUG=inittrace=1 prints a summary of execution time and memory allocation\ninformation for completed package initialization work.\nGODEBUG=schedtrace=X prints scheduling events every X milliseconds.\nThe GODEBUG environmental variable can be used to disable use of\ninstruction set extensions in the standard library and runtime.\nGODEBUG=cpu.all=off disables the use of all optional\ninstruction set extensions.\nGODEBUG=cpu.\nextension\n=off disables use of instructions from the\nspecified instruction set extension.\nextension\nis the lower case name for the instruction set extension\nsuch as\nsse41\nor\navx\n.",
      "code_examples": [
        {
          "language": "",
          "code": "runtime.SetBlockProfileRate",
          "element": "<code>runtime.SetBlockProfileRate</code>"
        },
        {
          "language": "",
          "code": "runtime.SetMutexProfileFraction",
          "element": "<code>runtime.SetMutexProfileFraction</code>"
        },
        {
          "language": "",
          "code": "go tool pprof",
          "element": "<code><a href=\"https://github.com/google/pprof/blob/master/doc/README.md\">go tool pprof</a></code>"
        },
        {
          "language": "",
          "code": "runtime.concatstrings",
          "element": "<code>runtime.concatstrings</code>"
        },
        {
          "language": "",
          "code": "net/http/pprof",
          "element": "<code>net/http/pprof</code>"
        },
        {
          "language": "",
          "code": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/custom_debug_path/profile\", pprof.Profile)\n\tlog.Fatal(http.ListenAndServe(\":7777\", mux))\n}",
          "element": "<pre>\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/custom_debug_path/profile\", pprof.Profile)\n\tlog.Fatal(http.ListenAndServ..."
        },
        {
          "language": "",
          "code": "context.Context",
          "element": "<code>context.Context</code>"
        },
        {
          "language": "",
          "code": "httptrace.ClientTrace",
          "element": "<code>httptrace.ClientTrace</code>"
        },
        {
          "language": "",
          "code": "$ go build -gcflags=all=\"-N -l\"",
          "element": "<pre>\n$ go build -gcflags=all=\"-N -l\"\n</pre>"
        },
        {
          "language": "",
          "code": "-dwarflocationlists",
          "element": "<code>-dwarflocationlists</code>"
        },
        {
          "language": "",
          "code": "$ go build -gcflags=\"-dwarflocationlists=true\"",
          "element": "<pre>\n$ go build -gcflags=\"-dwarflocationlists=true\"\n</pre>"
        },
        {
          "language": "",
          "code": "runtime.ReadMemStats",
          "element": "<code><a href=\"/pkg/runtime/#ReadMemStats\">runtime.ReadMemStats</a></code>"
        },
        {
          "language": "",
          "code": "debug.ReadGCStats",
          "element": "<code><a href=\"/pkg/runtime/debug/#ReadGCStats\">debug.ReadGCStats</a></code>"
        },
        {
          "language": "",
          "code": "debug.Stack",
          "element": "<code><a href=\"/pkg/runtime/debug/#Stack\">debug.Stack</a></code>"
        },
        {
          "language": "",
          "code": "debug.WriteHeapDump",
          "element": "<code><a href=\"/pkg/runtime/debug/#WriteHeapDump\">debug.WriteHeapDump</a></code>"
        },
        {
          "language": "",
          "code": "runtime.NumGoroutine",
          "element": "<code><a href=\"/pkg/runtime#NumGoroutine\">runtime.NumGoroutine</a></code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Diagnostics",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 2,
          "text": "Profiling",
          "id": "profiling"
        },
        {
          "level": 2,
          "text": "Tracing",
          "id": "tracing"
        },
        {
          "level": 2,
          "text": "Debugging",
          "id": "debugging"
        },
        {
          "level": 2,
          "text": "Runtime statistics and events",
          "id": "runtime"
        },
        {
          "level": 3,
          "text": "Execution tracer",
          "id": "execution-tracer"
        },
        {
          "level": 3,
          "text": "GODEBUG",
          "id": "godebug"
        }
      ],
      "timestamp": 1750757605.687339
    },
    {
      "url": "https://golang.org/doc/gc-guide",
      "title": "A Guide to the Go Garbage Collector - The Go Programming Language",
      "content": "Documentation\nA Guide to the Go Garbage Collector\nA Guide to the Go Garbage Collector\nIntroduction\nThis guide is intended to aid advanced Go users in better understanding their\napplication costs by providing insights into the Go garbage collector.\nIt also provides guidance on how Go users may use these insights to improve\ntheir applications' resource utilization.\nIt does not assume any knowledge of garbage collection, but does assume\nfamiliarity with the Go programming language.\nThe Go language takes responsibility for arranging the storage of Go values;\nin most cases, a Go developer need not care about where these values are stored,\nor why, if at all.\nIn practice, however, these values often need to be stored in computer\nphysical memory\nand physical memory is a finite resource.\nBecause it is finite, memory must be managed carefully and recycled in order to\navoid running out of it while executing a Go program.\nIt's the job of a Go implementation to allocate and recycle memory as needed.\nAnother term for automatically recycling memory is\ngarbage collection\n.\nAt a high level, a garbage\ncollector\n(or GC, for short) is a system that\nrecycles memory on behalf of the application by identifying which parts of memory\nare no longer needed.\nThe Go standard toolchain provides a runtime library that ships with every\napplication, and this runtime library includes a garbage collector.\nNote that the existence of a garbage collector as described by this guide\nis not guaranteed by the\nGo specification\n, only that\nthe underlying storage for Go values is managed by the language itself.\nThis omission is intentional and enables the use of radically different\nmemory management techniques.\nTherefore, this guide is about a specific implementation of the Go programming\nlanguage and\nmay not apply to other implementations\n.\nSpecifically, this following guide applies to the standard toolchain (the\ngc\nGo compiler and tools).\nGccgo and Gollvm both use a very similar GC implementation so many of the\nsame concepts apply, but details may vary.\nFurthermore, this is a living document and will change over time to best\nreflect the latest release of Go.\nThis document currently describes the garbage collector as of Go 1.19.\nWhere Go Values Live\nBefore we dive into the GC, let's first discuss the memory that doesn't need to\nbe managed by the GC.\nFor instance, non-pointer Go values stored in local variables will likely not be\nmanaged by the Go GC at all, and Go will instead arrange for memory to be\nallocated that's tied to the\nlexical scope\nin\nwhich it's created.\nIn general, this is more efficient than relying on the GC, because the Go\ncompiler is able to predetermine when that memory may be freed and emit\nmachine instructions that clean up.\nTypically, we refer to allocating memory for Go values this way as\n\"stack allocation,\" because the space is stored on the goroutine stack.\nGo values whose memory cannot be allocated this way, because the Go compiler\ncannot determine its lifetime, are said to\nescape to the heap\n.\n\"The heap\" can be thought of as a catch-all for memory allocation, for when Go\nvalues need to be placed\nsomewhere\n.\nThe act of allocating memory on the heap is typically referred to as \"dynamic\nmemory allocation\" because both the compiler and the runtime can make very few\nassumptions as to how this memory is used and when it can be cleaned up.\nThat's where a GC comes in: it's a system that specifically identifies and\ncleans up dynamic memory allocations.\nThere are many reasons why a Go value might need to escape to the heap.\nOne reason could be that its size is dynamically determined.\nConsider for instance the backing array of a slice whose initial size is\ndetermined by a variable, rather than a constant.\nNote that escaping to the heap must also be transitive: if a reference to a\nGo value is written into another Go value that has already been determined to\nescape, that value must also escape.\nWhether a Go value escapes or not is a function of the context in which it is\nused and the Go compiler's escape analysis algorithm.\nIt would be fragile and difficult to try to enumerate precisely when values\nescape: the algorithm itself is fairly sophisticated and changes between Go\nreleases.\nFor more details on how to identify which values escape and which do not, see\nthe section on\neliminating heap allocations\n.\nTracing Garbage Collection\nGarbage collection may refer to many different methods of automatically\nrecycling memory; for example, reference counting.\nIn the context of this document, garbage collection refers to\ntracing\ngarbage collection, which identifies in-use, so-called\nlive\n, objects by\nfollowing pointers transitively.\nLet's define these terms more rigorously.\nObject\nAn object is a dynamically allocated piece of memory\n\t\tthat contains one or more Go values.\nPointer\nA memory address that references any value within an\n\t\tobject.\n\t\tThis naturally includes Go values of the form\n*T\n, but also includes\n\t\tparts of built-in Go values.\n\t\tStrings, slices, channels, maps, and interface values all contain memory\n\t\taddresses that the GC must trace.\nTogether, objects and pointers to other objects form the\nobject graph\n.\nTo identify live memory, the GC walks the object graph starting at the\nprogram's\nroots\n, pointers that identify objects that are definitely\nin-use by the program.\nTwo examples of roots are local variables and global variables.\nThe process of walking the object graph is referred to as\nscanning\n.\nAnother phrase you might see in the Go documentation is whether an object is\nreachable\n, which just means that the object can be discovered by the\nscanning process.\nNote also that,\nwith one\nexception\n, once memory becomes unreachable, it stays unreachable.\nThis basic algorithm is common to all tracing GCs.\nWhere tracing GCs differ is what they do once they discover memory is live.\nGo's GC uses the mark-sweep technique, which means that in order to keep track\nof its progress, the GC also\nmarks\nthe values it encounters as live.\nOnce tracing is complete, the GC then walks over all memory in the heap and\nmakes all memory that is\nnot\nmarked available for allocation.\nThis process is called\nsweeping\n.\nOne alternative technique you may be familiar with is to actually\nmove\nthe objects to a new part of memory and leave behind a forwarding pointer that\nis later used to update all the application's pointers.\nWe call a GC that moves objects in this way a\nmoving\nGC; Go has a\nnon-moving\nGC.\nThe GC cycle\nBecause the Go GC is a mark-sweep GC, it broadly operates in two phases: the\nmark phase, and the sweep phase.\nWhile this statement might seem tautological, it contains an important insight:\nit's not possible to release memory back to be allocated until\nall\nmemory\nhas been traced, because there may still be an un-scanned pointer keeping\nan object alive.\nAs a result, the act of sweeping must be entirely separated from the act of\nmarking.\nFurthermore, the GC may also not be active at all, when there's no GC-related\nwork to do.\nThe GC continuously rotates through these three phases of sweeping, off, and\nmarking in what's known as the\nGC cycle\n.\nFor the purposes of this document, consider the GC cycle starting with sweeping,\nturning off, then marking.\nThe next few sections will focus on building intuition for the costs of the\nGC to aid users in tweaking GC parameters for their own benefit.\nUnderstanding costs\nThe GC is inherently a complex piece of software built on even more complex\nsystems.\nIt's easy to become mired in detail when trying to understand the GC and\ntweak its behavior.\nThis section is intended to provide a framework for reasoning about the cost\nof the Go GC and its tuning parameters.\nTo begin with, consider this model of GC cost based on three simple axioms.\nThe GC involves only two resources: physical memory, and CPU time.\nThe GC's memory costs consist of live heap memory, new heap memory\n\t\tallocated before the mark phase, and space for metadata that, even\n\t\tif proportional to the previous costs, are small in comparison.\nGC memory cost for cycle N = live heap from cycle N-1 + new heap\nLive heap memory is memory that was determined to be live by the\n\t\tprevious GC cycle, while new heap memory is any memory allocated in the\n\t\tcurrent cycle, which may or may not be live by the end.\n\t\tHow much memory is live at any given point in time is a property of the\n\t\tprogram, and not something the GC can directly control.\nThe GC's CPU costs are modeled as a fixed cost per cycle, and a\n\t\tmarginal cost that scales proportionally with the size of the live\n\t\theap.\nGC CPU time for cycle N = Fixed CPU time cost per cycle + average CPU time cost per byte * live heap memory found in cycle N\nThe fixed CPU time cost per cycle includes things that happen a constant number\n\t\tof times each cycle, like initializing data structures for the next GC cycle.\n\t\tThis cost is typically small, and is included just for completeness.\nMost of the CPU cost of the GC is marking and scanning, which is captured by\n\t\tthe marginal cost.\n\t\tThe average cost of marking and scanning depends on the GC implementation, but\n\t\talso on the behavior of the program.\n\t\tFor example, more pointers means more GC work, because at minimum the GC needs\n\t\tto visit all the pointers in the program.\n\t\tStructures like linked lists and trees are also more difficult for the GC to\n\t\twalk in parallel, increasing the average cost per byte.\nThis model ignores sweeping costs, which are proportional to total heap memory,\n\t\tincluding memory that is dead (it must be made available for allocation).\n\t\tFor Go's current GC implementation, sweeping is so much faster than marking and\n\t\tscanning that the cost is negligible in comparison.\nThis model is simple but effective: it accurately categorizes the dominant\ncosts of the GC.\nIt also tells us that the\ntotal CPU cost\nof the garbage collector depends on\nthe total number of GC cycles in a given time frame.\nFinally, embedded in this model is a fundamental time/space trade-off for the GC.\nTo see why, let's explore a constrained but useful scenario: the\nsteady state\n.\nThe steady state of an application, from the GC's perspective, is defined by the\nfollowing properties:\nThe rate at which the application allocates new memory (in bytes per\n\t\tsecond) is constant.\nThis means that, from the GC's perspective, the application's workload\n\t\tlooks approximately the same over time.\n\t\tFor example, for a web service, this would be a constant request rate\n\t\twith, on average, the same kinds of requests being made, with the average\n\t\tlifetime of each request staying roughly constant.\nThe marginal costs of the GC are constant.\nThis means that statistics of the object graph, such as the distribution\n\t\tof object sizes, the number of pointers, and the average depth of data\n\t\tstructures, remain the same from cycle to cycle.\nLet's work through an example.\nAssume some application allocates 10 MiB/s, the GC can scan at a rate\nof 100 MiB/cpu-second (this is made up), and fixed GC costs are zero.\nThe steady state makes no assumptions about the size of the live heap,\nbut for simplicity, let's say this application's live heap is always 10 MiB.\n(Note: a constant live heap does not mean that all newly allocated memory is\ndead.\nIt means that, after the GC runs,\nsome mix\nof old and new heap memory\nis live.)\nIf each GC cycle happens exactly every 1 cpu-second, then our example\napplication, in the steady state, will have a 20 MiB total heap size on each GC\ncycle.\nAnd with every GC cycle, the GC will need 0.1 cpu-seconds to do its work,\nresulting in a 10% overhead.\nNow let's say each GC cycle happens less often, once every 2 cpu-seconds.\nThen, our example application, in the steady state, will have a 30 MiB total\nheap size on each GC cycle.\nBut with every GC cycle, the GC will\nstill only need 0.1 cpu-seconds\nto do its work.\nSo this means that our GC overhead just went down, from 10% to 5%, at the\ncost of 50% more memory being used.\nThis change in overheads is the fundamental time/space trade-off mentioned\nearlier.\nAnd\nGC frequency\nis at the center of this trade-off:\nif we execute the GC more frequently, then we use less memory, and vice versa.\nBut how often does the GC actually execute?\nIn Go, deciding when the GC should start is the main parameter which the user\nhas control over.\nGOGC\nAt a high level, GOGC determines the trade-off between GC CPU and memory.\nIt works by determining the target heap size after each GC cycle, a target value\nfor the total heap size in the next cycle.\nThe GC's goal is to finish a collection cycle before the total heap size\nexceeds the target heap size.\nTotal heap size is defined as the live heap size at the end of the previous\ncycle, plus any new heap memory allocated by the application since the previous\ncycle.\nMeanwhile, target heap memory is defined as:\nTarget heap memory = Live heap + (Live heap + GC roots) * GOGC / 100\nAs an example, consider a Go program with a live heap size of 8 MiB, 1 MiB\nof goroutine stacks, and 1 MiB of pointers in global variables.\nThen, with a GOGC value of 100, the amount of new memory that will be allocated\nbefore the next GC runs will be 10 MiB, or 100% of the 10 MiB of work, for a\ntotal heap footprint of 18 MiB.\nWith a GOGC value of 50, then it'll be 50%, or 5 MiB.\nWith a GOGC value of 200, it'll be 200%, or 20 MiB.\nNote: GOGC includes the root set only as of Go 1.18.\nPreviously, it would only count the live heap.\nOften, the amount of memory in goroutine stacks is quite small and the live\nheap size dominates all other sources of GC work, but in cases where programs\nhad hundreds of thousands of goroutines, the GC was making poor judgements.\nThe heap target controls GC frequency: the bigger the target, the longer the GC\ncan wait to start another mark phase and vice versa.\nWhile the precise formula is useful for making estimates, it's best to think of\nGOGC in terms of its fundamental purpose: a parameter that picks a point in the\nGC CPU and memory trade-off.\nThe key takeaway is that\ndoubling GOGC will double heap memory overheads and\nroughly halve GC CPU cost\n, and vice versa.\n(To see a full explanation as to why, see the\nappendix\n.)\nNote: the target heap size is just a target, and there are several reasons why\nthe GC cycle might not finish right at that target.\nFor one, a large enough heap allocation can simply exceed the target.\nHowever, other reasons appear in GC implementations that go beyond the\nGC model\nthis guide has been using thus far.\nFor some more detail, see the\nlatency section\n, but the\ncomplete details may be found in the\nadditional\nresources\n.\nGOGC may be configured through either the\nGOGC\nenvironment\nvariable (which all Go programs recognize), or through the\nSetGCPercent\nAPI in the\nruntime/debug\npackage.\nNote that GOGC may also be used to turn off the GC entirely (provided the\nmemory limit\ndoes not apply) by setting\nGOGC=off\nor calling\nSetGCPercent(-1)\n.\nConceptually, this setting is equivalent to setting GOGC to a value of\ninfinity, as the amount of new memory before a GC is triggered is unbounded.\nTo better understand everything we've discussed so far, try out the interactive\nvisualization below that is built on the\nGC cost model\ndiscussed earlier.\nThis visualization depicts the execution of some program whose non-GC work takes\n10 seconds of CPU time to complete.\nIn the first second it performs some initialization step (growing its live heap)\nbefore settling into a steady state.\nThe application allocates 200 MiB in total, with 20 MiB live at a time.\nIt assumes that the only relevant GC work to complete comes from the live heap,\nand that (unrealistically) the application uses no additional memory.\nUse the slider to adjust the value of GOGC to see how the application responds\nin terms of total duration and GC overhead.\nEach GC cycle ends while the new heap drops to zero.\nThe time taken while the new heap drops to zero is the combined time for the\nmark phase for cycle N, and the sweep phase for the cycle N+1.\nNote that this visualization (and all the visualizations in this guide) assume\nthe application is paused while the GC executes, so GC CPU costs are fully\nrepresented by the time it takes for new heap memory to drop to zero.\nThis is only to make visualization simpler; the same intuition still applies.\nThe X axis shifts to always show the full CPU-time duration of the program.\nNotice that additional CPU time used by the GC increases the overall duration.\nGOGC\nNotice that the GC always incurs some CPU and peak memory overhead.\nAs GOGC increases, CPU overhead decreases, but peak memory increases\nproportionally to the live heap size.\nAs GOGC decreases, the peak memory requirement decreases at the expense of\nadditional CPU overhead.\nNote: the graph displays CPU time, not wall-clock time to complete the program.\nIf the program runs on 1 CPU and fully utilizes its resources, then these are\nequivalent.\nA real-world program likely runs on a multi-core system and does not 100%\nutilize the CPUs at all times.\nIn these cases the wall-time impact of the GC will be lower.\nNote: the Go GC has a minimum total heap size of 4 MiB, so if the GOGC-set\ntarget is ever below that, it gets rounded up.\nThe visualization reflects this detail.\nHere's another example that's a little bit more dynamic and realistic.\nOnce again, the application takes 10 CPU-seconds to complete without the GC, but\nthe steady state allocation rate increases dramatically half-way through, and\nthe live heap size shifts around a bit in the first phase.\nThis example demonstrates how the steady state might look when the live heap\nsize is actually changing, and how a higher allocation rate leads to more\nfrequent GC cycles.\nGOGC\nMemory limit\nUntil Go 1.19, GOGC was the sole parameter that could be used to modify the GC's\nbehavior.\nWhile it works great as a way to set a trade-off, it doesn't take into account\nthat available memory is finite.\nConsider what happens when there's a transient spike in the live heap size:\nbecause the GC will pick a total heap size proportional to that live heap size,\nGOGC must be configured such for the\npeak\nlive heap size, even if in the\nusual case a higher GOGC value provides a better trade-off.\nThe visualization below demonstrates this transient heap spike situation.\nGOGC\nIf the example workload is running in a container with a bit over 60 MiB of\nmemory available, then GOGC can't be increased beyond 100, even though the rest\nof the GC cycles have the available memory to make use of that extra memory.\nFurthermore, in some applications, these transient peaks can be rare and hard to\npredict, leading to occasional, unavoidable, and potentially costly\nout-of-memory conditions.\nThat's why in the 1.19 release, Go added support for setting a runtime memory\nlimit.\nThe memory limit may be configured either via the\nGOMEMLIMIT\nenvironment variable which all Go programs recognize, or through the\nSetMemoryLimit\nfunction available in the\nruntime/debug\npackage.\nThis memory limit sets a maximum on the\ntotal amount of memory that the Go\nruntime can use\n.\nThe specific set of memory included is defined in terms of\nruntime.MemStats\nas the expression\nSys\n-\nHeapReleased\nor equivalently in terms of the\nruntime/metrics\npackage,\n/memory/classes/total:bytes\n-\n/memory/classes/heap/released:bytes\nBecause the Go GC has explicit control over how much heap memory it uses, it\nsets the total heap size based on this memory limit and how much other memory\nthe Go runtime uses.\nThe visualization below depicts the same single-phase steady state workload from\nthe GOGC section, but this time with an extra 10 MiB of overhead from the Go\nruntime and with an adjustable memory limit.\nTry shifting around both GOGC and the memory limit and see what happens.\nGOGC\nMemory Limit\nNotice that when the memory limit is lowered below the peak memory that's\ndetermined by GOGC (42 MiB for a GOGC of 100), the GC runs more frequently to\nkeep the peak memory within the limit.\nReturning to our previous example of the transient heap spike, by setting a\nmemory limit and turning up GOGC, we can get the best of both worlds: no memory\nlimit breach, and better resource economy.\nTry out the interactive visualization below.\nGOGC\nMemory Limit\nNotice that with some values of GOGC and the memory limit, peak memory use\nstops at whatever the memory limit is, but that the rest of the program's\nexecution still obeys the total heap size rule set by GOGC.\nThis observation leads to another interesting detail: even when GOGC is set to\noff, the memory limit is still respected!\nIn fact, this particular configuration represents a\nmaximization of resource\neconomy\nbecause it sets the minimum GC frequency required to maintain some\nmemory limit.\nIn this case,\nall\nof the program's execution has the heap size rise to\nmeet the memory limit.\nNow, while the memory limit is clearly a powerful tool,\nthe use of\na memory limit does not come without a cost\n, and certainly doesn't\ninvalidate the utility of GOGC.\nConsider what happens when the live heap grows large enough to bring total\nmemory use close to the memory limit.\nIn the steady state visualization above, try turning GOGC off and then slowly\nlowering the memory limit further and further to see what happens.\nNotice that the total time the application takes will start to grow in an\nunbounded manner as the GC is constantly executing to maintain an impossible\nmemory limit.\nThis situation, where the program fails to make reasonable progress due to\nconstant GC cycles, is called\nthrashing\n.\nIt's particularly dangerous because it effectively stalls the program.\nEven worse, it can happen for exactly the same situation we were trying to\navoid with GOGC: a large enough transient heap spike can cause a program to\nstall indefinitely!\nTry reducing the memory limit (around 30 MiB or lower) in the transient heap\nspike visualization and notice how the worst behavior specifically starts with\nthe heap spike.\nIn many cases, an indefinite stall is worse than an out-of-memory condition,\nwhich tends to result in a much faster failure.\nFor this reason, the memory limit is defined to be\nsoft\n.\nThe Go runtime makes no guarantees that it will maintain this memory limit\nunder all circumstances; it only promises some reasonable amount of effort.\nThis relaxation of the memory limit is critical to avoiding thrashing behavior,\nbecause it gives the GC a way out: let memory use surpass the limit to avoid\nspending too much time in the GC.\nHow this works internally is the GC sets an upper limit on the amount\nof CPU time it can use over some time window (with some hysteresis for very\nshort transient spikes in CPU use).\nThis limit is currently set at roughly 50%, with a\n2 * GOMAXPROCS\nCPU-second window.\nThe consequence of limiting GC CPU time is that the GC's work is delayed,\nmeanwhile the Go program may continue allocating new heap memory, even beyond\nthe memory limit.\nThe intuition behind the 50% GC CPU limit is based on the worst-case impact\non a program with ample available memory.\nIn the case of a misconfiguration of the memory limit, where it is set too\nlow mistakenly, the program will slow down at most by 2x, because the GC\ncan't take more than 50% of its CPU time away.\nNote: the visualizations on this page do not simulate the GC CPU limit.\nSuggested uses\nWhile the memory limit is a powerful tool, and the Go runtime takes steps to\nmitigate the worst behaviors from misuse, it's still important to use it\nthoughtfully.\nBelow is a collection of tidbits of advice about where the memory limit is most\nuseful and applicable, and where it might cause more harm than good.\nDo\ntake advantage of the memory limit when the execution\n\t\tenvironment of your Go program is entirely within your control, and\n\t\tthe Go program is the only program with access to some set of resources\n\t\t(i.e. some kind of memory reservation, like a container memory limit).\nA good example is the deployment of a web service into containers with\n\t\ta fixed amount of available memory.\nIn this case, a good rule of thumb is to leave an additional 5-10%\n\t\tof headroom to account for memory sources the Go runtime is unaware of.\nDo\nfeel free to adjust the memory limit in real time to adapt to\n\t\tchanging conditions.\nA good example is a cgo program where C libraries temporarily need to\n\t\tuse substantially more memory.\nDon't\nset GOGC to off with a memory limit if the Go program\n\t\tmight share some of its limited memory with other programs, and those\n\t\tprograms are generally decoupled from the Go program.\n\t\tInstead, keep the memory limit since it may help to curb undesirable\n\t\ttransient behavior, but set GOGC to some smaller, reasonable value for\n\t\tthe average case.\nWhile it may be tempting to try and \"reserve\" memory for co-tenant\n\t\tprograms, unless the programs are fully synchronized (e.g. the Go\n\t\tprogram calls some subprocess and blocks while its callee executes),\n\t\tthe result will be less reliable as inevitably both programs will\n\t\tneed more memory.\n\t\tLetting the Go program use less memory when it doesn't need it will\n\t\tgenerate a more reliable result overall.\n\t\tThis advice also applies to overcommit situations, where the sum of\n\t\tmemory limits of containers running on one machine may exceed the\n\t\tactual physical memory available to the machine.\nDon't\nuse the memory limit when deploying to an execution\n\t\tenvironment you don't control, especially when your program's memory\n\t\tuse is proportional to its inputs.\nA good example is a CLI tool or a desktop application.\n\t\tBaking a memory limit into the program when it's unclear what kind of\n\t\tinputs it might be fed, or how much memory might be available on the\n\t\tsystem can lead to confusing crashes and poor performance.\n\t\tPlus, an advanced end-user can always set a memory limit if they wish.\nDon't\nset a memory limit to avoid out-of-memory conditions when\n\t\ta program is already close to its environment's memory limits.\nThis effectively replaces an out-of-memory risk with a risk of\n\t\tsevere application slowdown, which is often not a favorable trade,\n\t\teven with the efforts Go makes to mitigate thrashing.\n\t\tIn such a case, it would be much more effective to either increase the\n\t\tenvironment's memory limits (and\nthen\npotentially set a memory\n\t\tlimit) or decrease GOGC (which provides a much cleaner trade-off than\n\t\tthrashing-mitigation does).\nLatency\nThe visualizations in this document have modeled the application as paused while\nthe GC is executing.\nGC implementations do exist that behave this way, and they're referred to as\n\"stop-the-world\" GCs.\nThe Go GC, however, is not fully stop-the-world and does most of its work\nconcurrently with the application.\nThis is primarily to reduce application\nlatencies\n.\nSpecifically, the end-to-end duration of a single unit of computation (e.g. a\nweb request).\nThus far, this document mainly considered application\nthroughput\n(e.g.\nweb requests handled per second).\nNote that each example in the\nGC cycle\nsection\nfocused on the total CPU duration of an executing program.\nHowever, such a duration is far less meaningful for say, a web service.\nWhile throughput is still important for a web service (i.e. queries per second),\noften the latency of each individual request matters even more.\nIn terms of latency, a stop-the-world GC may require a considerable length of\ntime to execute both its mark and sweep phases, during which the application,\nand in the context of a web service, any in-flight request, is unable to make\nfurther progress.\nInstead, the Go GC avoids making the length of any global application pauses\nproportional to the size of the heap, and that the core tracing algorithm is\nperformed while the application is actively executing.\n(The pauses are more strongly proportional to GOMAXPROCS algorithmically, but\nmost commonly are dominated by the time it takes to stop running goroutines.)\nCollecting concurrently is not without cost: in practice it often leads to a\ndesign with lower throughput than an equivalent stop-the-world garbage\ncollector.\nHowever,  it's important to note that\nlower latency does not inherently mean\nlower throughput\n, and the performance of the Go garbage collector has\nsteadily improved over time, in both latency and throughput.\nThe concurrent nature of Go's current GC does not invalidate anything discussed\nin this document so far: none of the statements relied on this design choice.\nGC frequency is still the primary way the GC trades off between CPU\ntime and memory for throughput, and in fact, it also takes on this role for\nlatency.\nThis is because most of the costs for the GC are incurred while the mark phase\nis active.\nThe key takeaway then, is that\nreducing GC frequency may also lead to latency\nimprovements\n.\nThis applies not only to reductions in GC frequency from modifying tuning\nparameters, like increasing GOGC and/or the memory limit, but also applies to\nthe optimizations described in the\noptimization guide\n.\nHowever, latency is often more complex to understand than throughput, because it\nis a product of the moment-to-moment execution of the program and not just an\naggregation of costs.\nAs a result, the connection between latency and GC frequency is less direct.\nBelow is a list of possible sources of latency for those inclined to dig\ndeeper.\nBrief stop-the-world pauses when the GC transitions between the mark\n\t\tand sweep phases,\nScheduling delays because the GC takes 25% of CPU resources when in the\n\t\tmark phase,\nUser goroutines assisting the GC in response to a high allocation rate,\nPointer writes requiring additional work while the GC is in the mark\n\t\tphase, and\nRunning goroutines must be suspended for their roots to be scanned.\nThese latency sources are visible in\nexecution traces\n, except for\npointer writes requiring additional work.\nFinalizers, cleanups, and weak pointers\nGarbage collection provides the illusion of infinite memory using only finite\nmemory.\nMemory is allocated but never explicitly freed, which enables simpler APIs and\nconcurrent algorithms compared to bare-bones manual memory management.\n(Some languages with manually managed memory use alternative approaches such\nas \"smart pointers\" and compile-time ownership tracking to ensure that objects\nare freed, but these features are deeply embedded into the API design\nconventions in these languages.)\nOnly the live objectsthose reachable from a global variable or a\ncomputation in some goroutinecan affect the behavior of the program.\nAny time after an object becomes unreachable (\"dead\"), it may be safely\nrecycled by the GC.\nThis allows for a wide variety of GC designs, such as the tracing design used\nby Go today.\nThe death of an object is not an observable event at the language level.\nHowever, Go's runtime library provides three features that break that illusion:\ncleanups\n,\nweak pointers\n, and\nfinalizers\n.\nEach of these features provides some way to observe and react to object death,\nand in the case of finalizers, even reverse it.\nThis of course complicates Go programs and adds an additional burden to the GC\nimplementation.\nNonetheless, these features exist because they are useful in a variety of\ncircumstances, and Go programs use them and benefit from them all the time.\nFor the details of each feature, refer to its package documentation\n(\nruntime.AddCleanup\n,\nweak.Pointer\n,\nruntime.SetFinalizer\n).\nBelow is some general advice for using these features, outlines of common\nissues you can run into with each feature, and advice for testing uses of these\nfeatures.\nGeneral advice\nWrite unit tests.\nThe exact timing of cleanups, weak pointers, and finalizers can be difficult\n\t\tto predict, and it's easy to convince yourself that everything works, even\n\t\tafter many consecutive executions.\n\t\tBut it's also easy to make subtle mistakes.\nWriting tests\nfor them can be tricky, but\n\t\tgiven that they're so subtle to use, testing is even more important usual.\nAvoid using these features directly in typical Go code.\nThese are low-level features with subtle restrictions and behaviors.\n\t\tFor instance, there's no guarantee cleanups or finalizers will be run\n\t\tat program exit, or at all for that matter.\n\t\tThe long comments in their API documentation should be seen as a warning.\n\t\tThe vast majority of Go code does not benefit from using these features\n\t\tdirectly, only indirectly.\nEncapsulate the use of these mechanisms within a package.\nWhere possible, do not allow the use of these mechanisms to leak into\n\t\tthe public API of your package; provide interfaces that make it hard or\n\t\timpossible for users to misuse them.\n\t\tFor example, instead of asking the user to set up a cleanup on some\n\t\tC-allocated memory to free it, write a wrapper package and hide that\n\t\tdetail inside.\nRestrict access to objects that have finalizers, cleanups, and weak\n\t\tpointers to the package that created and applied them.\nThis is related to the previous point, but is worth calling out\n\t\texplicitly, since it's a very powerful pattern for using these\n\t\tfeatures in a less error-prone way.\n\t\tFor example, the\nunique package\nuses\n\t\tweak pointers under the hood, but completely encasulates the objects\n\t\tthat are weakly pointed-to.\n\t\tThose values can never be mutated by the rest of the application,\n\t\tit can only be copied through the\nValue method\n, preserving\n\t\tthe illusion of infinite memory for package users.\nPrefer cleaning up non-memory resources deterministically when possible,\n\t\twith finalizers and cleanups as a fallback.\nCleanups and finalizers are a good fit for memory resources such as\n\t\tmemory allocated externally, like from C, or references to an\nmmap\nmapping.\n\t\tMemory allocated by C's malloc must eventually be freed by C's free.\n\t\tA finalizer that calls\nfree\n, attached to a wrapper object\n\t\tfor the C memory, is a reasonable way to ensure that C memory is\n\t\teventually reclaimed as a consequence of garbage collection.\nHowever, non-memory resources, like file descriptors, tend to be subject to\n\t\tsystem limits that the Go runtime is generally unaware of.\n\t\tIn addition, the timing of the garbage collector in a given Go program\n\t\tis usually something a package author has little control over (for instance,\n\t\thow often the GC runs is controlled by\nGOGC\n, which can\n\t\tbe set by operators to a variety of different values in practice).\n\t\tThese two facts conspire to make cleanups and finalizers a bad fit to use\n\t\tas the only mechanism for releasing non-memory resources.\nIf you're a package author exposing an API that wraps some non-memory\n\t\tresource, consider providing an explicit API for releasing the resource\n\t\tdeterministically (through a\nClose\nmethod, or something similar),\n\t\trather than relying on the garbage collector through cleanups or finalizers.\n\t\tInstead, prefer to use cleanups and finalizers as a best-effort handler for\n\t\tprogrammer mistakes, either by cleaning up the resource anyway like\nos.File\ndoes, or by reporting the failure to\n\t\tdeterministically clean up back to the user.\nPrefer cleanups to finalizers.\nHistorically, finalizers were added to simplify the interface between Go code\n\t\tand C code and to clean up non-memory resources.\n\t\tThe intended use was to apply them to wrapper objects that owned C memory or\n\t\tsome other non-memory resource, so that the resource could be released once\n\t\tGo code was done using it.\n\t\tThese reasons at least partially explain why finalizers are narrowly scoped,\n\t\twhy any given object can only have one finalizer, and why that finalizer must\n\t\tbe attached to the first byte of the object only.\n\t\tThis limitation already stifles some use-cases.\n\t\tFor example, any package that wishes to internally cache some information about\n\t\tan object passed to it cannot clean up that information once the object is gone.\nBut worse than that, finalizers are inefficient and error-prone due to the fact\n\t\tthat they\nresurrect\n\t\tthe object\nthey're attached to, so that it can be passed to the finalizer\n\t\tfunction (and even continue to live beyond that, too).\n\t\tThis simple fact means that if the object is part of a reference cycle it can\n\t\tnever be freed, and the memory backing the object cannot be reused until at\n\t\tleast until the following garbage collection cycle.\nBecause finalizers resurrect objects, though, they do have a better-defined\n\t\texection order than cleanups.\n\t\tFor this reason, finalizers are still potentially (but rarely) useful for\n\t\tcleaning up structures that have complex destruction ordering requirements.\nBut for all other uses in Go 1.24 and beyond, we recommend you use cleanups\n\t\tbecause they are more flexible, less error-prone, and more efficient than\n\t\tfinalizers.\nCommon cleanup issues\nObjects with attached cleanups must not be reachable from the cleanup\n\t\tfunction (for example, through a captured local variable).\n\t\tThis will prevent the object from being reclaimed and the cleanup from\n\t\tever running.\nf := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(fd int) {\n\tsyscall.Close(f.fd) // Mistake: We reference f, so this cleanup won't run!\n}, f.fd)\nObjects with attached cleanups must not be reachable from the argument\n\t\tto the cleanup function.\n\t\tThis will prevent the object from being reclaimed and the cleanup from\n\t\tever running.\nf := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(f *myFile) {\n\tsyscall.Close(f.fd)\n}, f) // Mistake: We reference f, so this cleanup wouldn't ever run. This specific case also panics.\nFinalizers have a well-defined execution order, but cleanups do not.\n\t\tCleanups can also run concurrently with one another.\nruntime.GC\nwill not wait until cleanups for unreachable\n\t\tobjects are executed, only until they are all queued.\nCommon weak pointer issues\nWeak pointers can begin returning\nnil\nfrom their\nValue\nmethod at unexpected times.\n\t\tAlways guard the call to\nValue\nwith a\nnil\ncheck and have a backup plan.\nWhen weak pointers are used as map keys, they do not affect the\n\t\treachability of map values.\n\t\tTherefore, if a weak pointer map key points to an object that is also\n\t\treachable from the map value, that object will still be considered\n\t\treachable.\nCommon finalizer issues\nObjects with attached finalizers must not be reachable from themselves\n\t\tby any path (in other words, they cannot be in a reference cycle).\n\t\tThis will prevent the object from being reclaimed and the finalizer from\n\t\tever running.\nf := new(myCycle)\nf.self = f // Mistake: f is reachable from f, so this finalizer would never run.\nruntime.SetFinalizer(f, func(f *myCycle) {\n\t...\n})\nObjects with attached finalizers must not be reachable from the finalizer\n\t\tfunction (for example, through a captured local variable).\n\t\tThis will prevent the object from being reclaimed and the finalizer from\n\t\tever running.\nf := new(myFile)\nf.fd = syscall.Open(...)\nruntime.SetFinalizer(f, func(_ *myFile) {\n\tsyscall.Close(f.fd) // Mistake: We reference the outer f, so this cleanup won't run!\n})\nReference chains of objects with attached finalizers (say, in a linked list)\n\t\ttake, at minimum, as many GC cycles as there are objects in the chain\n\t\tto clean them all up.\n\t\tKeep finalizers shallow!\n// Mistake: reclaiming this linked list will take at least 10 GC cycles.\nnode := new(linkedListNode)\nfor range 10 {\n\ttmp := new(linkedListNode)\n\ttmp.next = node\n\tnode = tmp\n\truntime.SetFinalizer(node, func(node *linkedListNode) {\n\t\t...\n\t})\n}\nAvoid placing finalizers on objects returned at package boundaries.\n\t\tThis makes it possible for users of your package to call\nruntime.SetFinalizer\nto mutate the finalizer on the object\n\t\tyou return, which can be an unexpected behavior that users of your package\n\t\tmay end up relying on.\nruntime.GC\nwill not wait until finalizers for unreachable\n\t\tobjects are executed, only until they are all queued.\nTesting object death\nWhen using these features, it can sometimes be tricky to write tests for code that\nuses them.\nHere are some tips for writing robust tests for code that uses these features.\nAvoid running such tests in parallel with other tests.\n\t\tIt helps a lot to increase determinism as much as possible and to have\n\t\ta good handle on the state of the world at any given time.\nUse\nruntime.GC\nto establish a baseline upon entering the\n\t\ttest.\n\t\tUse\nruntime.GC\nto force weak pointers to\nnil\n,\n\t\tand to queue up cleanups and finalizers to run.\nruntime.GC\ndoes not wait for cleanups and finalizers to run,\n\t\tit only queues them.\nTo write the most robust tests possible, inject a way to block on a cleanup\n\t\tor finalizer from your test (for example, pass an optional channel to the\n\t\tcleanup and/or finalizer from the test, and write to the channel once it\n\t\thas finished executing).\n\t\tIf this is too hard or impossible, an alternative is to spin on a particular\n\t\tpost-cleanup state to be true.\n\t\tFor example, the\nos\ntests call\nruntime.Gosched\nin\n\t\ta loop that checks whether a file has been closed, once it becomes\n\t\tunreachable.\nIf writing tests for using finalizers, and you have a chain of objects\n\t\tthat use finalizers, you will need at minimum the length of the deepest\n\t\tchain the test can create of\nruntime.GC\ncalls to ensure\n\t\tall the finalizers run.\nTest in race mode to discover races between concurrent cleanups, and\n\t\tbetween cleanup and finalizer code and the rest of the codebase.\nAdditional resources\nWhile the information presented above is accurate, it lacks the detail to\nfully understand costs and trade-offs in the Go GC's design.\nFor more information, see the following additional resources.\nThe GC Handbook\nAn\n\t\t\texcellent general resource and reference on garbage collector design.\nTCMalloc\nDesign\n\t\t\tdocument for the C/C++ memory allocator TCMalloc, which the Go memory allocator is based on.\nGo 1.5 GC announcement\nThe\n\t\t\tblog post announcing the Go 1.5 concurrent GC, which describes the algorithm in more detail.\nGetting to Go\nAn\n\t\t\tin-depth presentation about the evolution of Go's GC design up to 2018.\nGo 1.5 concurrent GC pacing\nDesign\n\t\t\tdocument for determining when to start a concurrent mark phase.\nSmarter scavenging\nDesign\n\t\t\tdocument for revising the way the Go runtime returns memory to the operating system.\nScalable page allocator\nDesign\n\t\t\tdocument for revising the way the Go runtime manages memory it gets from the operating system.\nGC pacer redesign (Go 1.18)\nDesign\n\t\t\tdocument for revising the algorithm to determine when to start a concurrent mark phase.\nSoft memory limit (Go 1.19)\nDesign\n\t\t\tdocument for the soft memory limit.\nA note about virtual memory\nThis guide has largely focused on the physical memory use of the GC, but a\nquestion that comes up regularly is what exactly that means and how it compares\nto virtual memory (typically presented in programs like\ntop\nas\n\"VSS\").\nPhysical memory is memory housed in the actual physical RAM chip in most\ncomputers.\nVirtual memory\nis an\nabstraction over physical memory provided by the operating system to isolate\nprograms from one another.\nIt's also typically acceptable for programs to reserve virtual address space\nthat doesn't map to any physical addresses at all.\nBecause virtual memory is just a mapping maintained by the operating system,\nit is typically very cheap to make large virtual memory reservations that don't\nmap to physical memory.\nThe Go runtime generally relies upon this view of the cost of virtual memory in\na few ways:\nThe Go runtime never deletes virtual memory that it maps.\n\t\tInstead, it uses special operations that most operating systems\n\t\tprovide to explicitly release any physical memory resources\n\t\tassociated with some virtual memory range.\nThis technique is used explicitly to manage the\nmemory limit\nand return memory to the\n\t\toperating system that the Go runtime no longer needs.\n\t\tThe Go runtime also releases memory it no longer needs continuously\n\t\tin the background.\n\t\tSee\nthe additional resources\nfor\n\t\tmore information.\nOn 32-bit platforms, the Go runtime reserves between 128 MiB and 512 MiB\n\t\tof address space up-front for the heap to limit fragmentation issues.\nThe Go runtime uses large virtual memory address space reservations\n\t\tin the implementation of several internal data structures.\n\t\tOn 64-bit platforms, these typically have a minimum virtual memory\n\t\tfootprint of about 700 MiB.\n\t\tOn 32-bit platforms, their footprint is negligible.\nAs a result, virtual memory metrics such as \"VSS\" in\ntop\nare\ntypically not very useful in understanding a Go program's memory footprint.\nInstead, focus on \"RSS\" and similar measurements, which more directly reflect\nphysical memory usage.\nOptimization guide\nIdentifying costs\nBefore trying to optimize how your Go application interacts with the GC, it's\nimportant to first identify that the GC is a major cost in the first place.\nThe Go ecosystem provides a number of tools for identifying costs and optimizing\nGo applications.\nFor a brief overview of these tools, see the\nguide on diagnostics\n.\nHere, we'll focus on a subset of these tools and a reasonable order to apply\nthem in in order to understand GC impact and behavior.\nCPU profiles\nA good place to start is with\nCPU profiling\n.\n\t\tCPU profiling provides an overview of where CPU time is spent, though to the\n\t\tuntrained eye it may be difficult to identify the magnitude of the role the\n\t\tGC plays in a particular application.\n\t\tLuckily, understanding how the GC fits in mostly boils down to knowing what\n\t\tdifferent functions in the `runtime` package mean.\n\t\tBelow is a useful subset of these functions for interpreting CPU profiles.\nNote that the functions listed below are not leaf functions, so they may not show\n\t\tup in the default the\npprof\ntool provides with the\ntop\ncommand.\n\t\tInstead, use the\ntop -cum\ncommand or use the\nlist\ncommand on these functions directly and focus on the cumulative percent column.\nruntime.gcBgMarkWorker\n: Entrypoint to the\n\t\t\tbackground mark worker goroutines.\n\t\t\tTime spent here scales with GC frequency and the complexity and\n\t\t\tsize of the object graph.\n\t\t\tIt represents a baseline for how much time the application spends\n\t\t\tmarking and scanning.\nNote that within these goroutines, you will find calls to\nruntime.gcDrainMarkWorkerDedicated\n,\nruntime.gcDrainMarkWorkerFractional\n, and\nruntime.gcDrainMarkWorkerIdle\n,\n\t\t\twhich indicate worker type.\n\t\t\tIn a largely idle Go application, the Go GC is going to use up\n\t\t\tadditional (idle) CPU resources to get its job done faster, which\n\t\t\tis indicated with the\nruntime.gcDrainMarkWorkerIdle\nsymbol.\n\t\t\tAs a result, time here may represent a large fraction of CPU\n\t\t\tsamples, which the Go GC believes are free.\n\t\t\tIf the application becomes more active, CPU time in idle workers\n\t\t\twill drop.\n\t\t\tOne common reason this can happen is if an application runs entirely\n\t\t\tin one goroutine but\nGOMAXPROCS\nis >1.\nruntime.mallocgc\n: Entrypoint to the memory\n\t\t\tallocator for heap memory.\n\t\t\tA large amount of cumulative time spent here (>15%)\n\t\t\ttypically indicates a lot of memory being allocated.\nruntime.gcAssistAlloc\n: Function goroutines\n\t\t\tenter to yield some of their time to assist the GC with scanning\n\t\t\tand marking.\n\t\t\tA large amount of cumulative time spent here (>5%) indicates\n\t\t\tthat the application is likely out-pacing the GC with respect to how\n\t\t\tfast it's allocating.\n\t\t\tIt indicates a particularly high degree of impact from the GC,\n\t\t\tand also represents time the application spend marking and scanning.\n\t\t\tNote that this is included in the\nruntime.mallocgc\ncall tree, so it will inflate that as well.\nExecution traces\nWhile CPU profiles are great for identifying where time is spent in\n\t\taggregate, they're less useful for indicating performance costs that\n\t\tare more subtle, rare, or related to latency specifically.\n\t\tExecution traces\non\n\t\tthe other hand provide a rich and deep view into a short window of\n\t\ta Go program's execution.\n\t\tThey contain a variety of events related to the Go GC and specific\n\t\texecution paths can be directly observed, along with how the application\n\t\tmight interact with the Go GC.\n\t\tAll the GC events tracked are conveniently labeled as such in the trace\n\t\tviewer.\nSee the\ndocumentation for the\nruntime/trace\npackage for how to get started with\n\t\texecution traces.\nGC traces\nWhen all else fails, the Go GC provides a few different specific traces\n\t\tthat provide much deeper insights into GC behavior.\n\t\tThese traces are always printed directly to STDERR, one line per GC cycle,\n\t\tand are configured through the\nGODEBUG\nenvironment variable\n\t\tthat all Go programs recognize.\n\t\tThey're mostly useful for debugging the Go GC itself since they require\n\t\tsome familiarity with the specifics of the GC's implementation, but\n\t\tnonetheless can occasionally be useful to gain a better understanding of\n\t\tGC behavior.\nThe core GC trace is enabled by setting\nGODEBUG=gctrace=1\n.\n\t\tThe output produced by this trace is documented in the\nenvironment\n\t\tvariables section in the documentation for the\nruntime\npackage.\nA supplementary GC trace called the \"pacer trace\" provides even deeper\n\t\tinsights and is enabled by setting\nGODEBUG=gcpacertrace=1\n.\n\t\tInterpreting this output requires an understanding of the GC's \"pacer\"\n\t\t(see\nadditional resources\n), which is\n\t\toutside the scope of this guide.\nEliminating heap allocations\nOne way to reduce costs from the GC is to have the GC manage fewer values to begin\nwith.\nThe techniques described below can produce some of the largest improvements in\nperformance, because as the\nGOGC section\ndemonstrated, the\nallocation rate of a Go program is a major factor in GC frequency, the key\ncost metric used by this guide.\nHeap profiling\nAfter\nidentifying that the GC is a source of\nsignificant costs\n, the next step in eliminating heap allocations is to\nfind out where most of them are coming from.\nFor this purpose, memory profiles (really, heap memory profiles) are very\nuseful.\nCheck out the\ndocumentation\nfor how to get started with them.\nMemory profiles describe where in the program heap allocations come from,\nidentifying them by the stack trace at the point they were allocated.\nEach memory profile can break down memory in four ways.\ninuse_objects\nBreaks down the number of objects that\n\tare live.\ninuse_space\nBreaks down live objects by how much\n\tmemory they use in bytes.\nalloc_objects\nBreaks down the number of objects\n\tthat have been allocated since the Go program began executing.\nalloc_space\nBreaks down the total amount of memory\n\tallocated since the Go program began executing.\nSwitching between these different views of heap memory may be done with either\nthe\n-sample_index\nflag to the\npprof\ntool, or via the\nsample_index\noption when the tool is used interactively.\nNote: memory profiles by default only sample a subset of heap objects so they\nwill not contain information about every single heap allocation.\nHowever, this is sufficient to find hot-spots.\nTo change the sampling rate, see\nruntime.MemProfileRate\n.\nFor the purposes of reducing GC costs,\nalloc_space\nis typically the\nmost useful view as it directly corresponds to the allocation rate.\nThis view will indicate allocation hot spots that would provide the most benefit.\nEscape analysis\nOnce candidate heap allocation sites have been identified with the help of\nheap profiles\n, how can they be eliminated?\nThe key is to leverage the Go compiler's escape analysis to have the Go compiler\nfind alternative, and more efficient storage for this memory, for example\nin the goroutine stack.\nLuckily, the Go compiler has the ability to describe why it decides to escape\na Go value to the heap.\nWith that knowledge, it becomes a matter of reorganizing your source code to\nchange the outcome of the analysis (which is often the hardest part, but outside\nthe scope of this guide).\nAs for how to access the information from the Go compiler's escape analysis, the\nsimplest way is through a debug flag supported by the Go compiler that describes\nall optimizations it applied or did not apply to some package in a text format.\nThis includes whether or not values escape.\nTry the following command, where\n[package]\nis some Go package path.\n$ go build -gcflags=-m=3 [package]\nThis information can also be visualized as an overlay in\nan LSP-capable editor; it is exposed as a code action.\n\nFor example, in VS Code, invoke the \"Source Action... > Show compiler\noptimization details\" command to enable diagnostics for the current package.\n(You can also run the \"Go: Toggle compiler optimization details\"\ncommand.)\n\nUse this configuration setting to control which annotations are displayed:\nEnable the overlay for escape analysis by\nsetting\nui.diagnostic.annotations\nto include\nescape\n.\nFinally, the Go compiler provides this information in a machine-readable (JSON)\nformat that may be used to build additional custom tooling.\nFor more information on that, see the\ndocumentation in the source Go code\n.\nImplementation-specific optimizations\nThe Go GC is sensitive to the demographics of live memory, because a complex\ngraph of objects and pointers both limits parallelism and generates more work\nfor the GC.\nAs a result, the GC contains a few optimizations for specific common structures.\nThe most directly useful ones for performance optimization are listed below.\nNote: Applying the optimizations below may reduce the readability of your code\nby obscuring intent, and may fail to hold up across Go releases.\nPrefer to apply these optimizations only in the places they matter most.\nSuch places may be identified by using the tools listed in the\nsection on identifying costs\n.\nPointer-free values are segregated from other values.\nAs a result, it may be advantageous to eliminate pointers from data\n\t\tstructures that do not strictly need them, as this reduces the cache\n\t\tpressure the GC exerts on the program.\n\t\tAs a result, data structures that rely on indices over pointer values,\n\t\twhile less well-typed, may perform better.\n\t\tThis is only worth doing if it's clear that the object graph is complex\n\t\tand the GC is spending a lot of time marking and scanning.\nThe GC will stop scanning values at the last pointer in the value.\nAs a result, it may be advantageous to group pointer fields in\n\t\tstruct-typed values at the beginning of the value.\n\t\tThis is only worth doing if it's clear the application spends a lot of its\n\t\ttime marking and scanning.\n\t\t(In theory the compiler can do this automatically, but it is not yet\n\t\timplemented, and struct fields are arranged as written in the source\n\t\tcode.)\nFurthermore, the GC must interact with nearly every pointer it sees, so using\nindices into an slice, for example, instead of pointers, can aid in reducing GC\ncosts.\nLinux transparent huge pages (THP)\nWhen a program accesses memory, the CPU needs to translate the\nvirtual memory\naddresses it uses\ninto physical memory addresses that refer to the data it was trying to access.\nTo do this, the CPU consults the \"page table,\" a data structure that represents\nthe mapping from virtual to physical memory, managed by the operating system.\nEach entry in the page table represents an indivisible block of physical memory\ncalled a page, hence the name.\nTransparent huge pages (THP) is a Linux feature that transparently replaces pages of\nphysical memory backing contiguous virtual memory regions with bigger blocks of memory\ncalled huge pages.\nBy using bigger blocks, fewer page table entries are needed to represent the same memory\nregion, improving page table lookup times.\nHowever, bigger blocks mean more waste if only a small part of the huge page is used\nby the system.\nWhen running Go programs in production, enabling transparent huge pages on Linux\ncan improve throughput and latency at the cost of additional memory use.\nApplications with small heaps tend not to benefit from THP and may end up using a\nsubstantial amount of additional memory (as high as 50%).\nHowever, applications with big heaps (1 GiB or more) tend to benefit quite a bit\n(up to 10% throughput) without very much additional memory overhead (1-2% or less).\nBeing aware of your THP settings in either case can be helpful, and experimentation\nis always recommended.\nOne can enable or disable transparent huge pages in a Linux environment by modifying\n/sys/kernel/mm/transparent_hugepage/enabled\n.\nSee the\nofficial\nLinux admin guide\nfor more details.\nIf you choose to have your Linux production environment enable transparent huge pages,\nwe recommend the following additional settings for Go programs.\nSet\n/sys/kernel/mm/transparent_hugepage/defrag\nto\ndefer\nor\ndefer+madvise\n.\nThis setting controls how aggressively a Linux kernel coalesces regular\n\t\tpages into huge pages.\ndefer\ntells the kernel to coalesce huge pages lazily\n\t\tand in the background.\n\t\tA more aggressive setting can induce stalls in memory constrained systems\n\t\tand can often hurt application latencies.\ndefer+madvise\nis like\ndefer\n, but is friendlier\n\t\tto other applications on the system that request huge pages explicitly and\n\t\trequire them for performance.\nSet\n/sys/kernel/mm/transparent_hugepage/khugepaged/max_ptes_none\nto\n0\n.\nThis setting controls how many additional pages the Linux kernel daemon\n\t\tcan allocate when trying to allocate a huge page.\n\t\tThe default setting is maximally aggressive, and can often\nundo work the Go\n\t\truntime does to return memory to the OS\n.\n\t\tBefore Go 1.21, the Go runtime tried to mitigate the negative effects of the\n\t\tdefault setting, but it came with a CPU cost.\n\t\tWith Go 1.21+ and Linux 6.2+, the Go runtime no longer mutates huge page\n\t\tstate.\nIf you experience an increase in memory usage when upgrading to Go 1.21.1 or\n\t\tlater, try applying this setting; it will likely resolve your issue.\n\t\tAs an additional workaround, you can call\nthe\nPrctl\nfunction\nwith\nPR_SET_THP_DISABLE\nto disable huge pages at\n\t\tthe process level, or you can set\nGODEBUG=disablethp=1\n(to be\n\t\tadded in Go 1.21.6 and Go 1.22) to disable huge pages for heap memory.\n\t\tNote that the\nGODEBUG\nsetting may be removed in a future release.\nAppendix\nAdditional notes on GOGC\nThe\nGOGC section\nclaimed that doubling GOGC doubles heap\nmemory overheads and halves GC CPU costs.\nTo see why, let's break it down mathematically.\nFirstly, the heap target sets a target for the total heap size.\nThis target, however, mainly influences the new heap memory, because the live\nheap is fundamental to the application.\nTarget heap memory = Live heap + (Live heap + GC roots) * GOGC / 100\nTotal heap memory = Live heap + New heap memory\n\nNew heap memory = (Live heap + GC roots) * GOGC / 100\nFrom this we can see that doubling GOGC would also double the amount of new heap\nmemory that application will allocate each cycle, which captures heap memory\noverheads.\nNote that\nLive heap + GC roots\nis an approximation of the amount of\nmemory the GC needs to scan.\nNext, let's look at GC CPU cost.\nTotal cost can be broken down as the cost per cycle, times GC frequency over\nsome time period T.\nTotal GC CPU cost = (GC CPU cost per cycle) * (GC frequency) * T\nGC CPU cost per cycle can be derived from the\nGC model\n:\nGC CPU cost per cycle = (Live heap + GC roots) * (Cost per byte) + Fixed cost\nNote that sweep phase costs are ignored here as mark and scan costs dominate.\nThe steady state is defined by a constant allocation rate and a constant cost\nper byte, so in the steady state we can derive a GC frequency from this new heap\nmemory:\nGC frequency = (Allocation rate) / (New heap memory) = (Allocation rate) / ((Live heap + GC roots) * GOGC / 100)\nPutting this together, we get the full equation for the total cost:\nTotal GC CPU cost = (Allocation rate) / ((Live heap + GC roots) * GOGC / 100) * ((Live heap + GC roots) * (Cost per byte) + Fixed cost) * T\nFor a sufficiently large heap (which represents most cases), the marginal costs\nof a GC cycle dominate the fixed costs.\nThis allows for a significant simplification of the total GC CPU cost formula.\nTotal GC CPU cost = (Allocation rate) / (GOGC / 100) * (Cost per byte) * T\nFrom this simplified formula, we can see that if we double GOGC, we halve total\nGC CPU cost.\n(Note that the visualizations in this guide do simulate fixed costs, so the GC\nCPU overheads reported by them will not exactly halve when GOGC doubles.)\nFurthermore, GC CPU costs are largely determined by allocation rate and the\ncost per byte to scan memory.\nFor more information on how to reduce these costs specifically, see the\noptimization guide\n.\nNote: there exists a discrepancy between the size of the live heap, and the\namount of that memory the GC actually needs to scan: the same size live heap but\nwith a different structure will result in a different CPU cost, but the same\nmemory cost, resulting a different trade-off.\nThis is why the structure of the heap is part of the definition of the\nsteady state.\nThe heap target should arguably only include the scannable live heap as a closer\napproximation of memory the GC needs to scan, but this leads to degenerate\nbehavior when there's a very small amount of scannable live heap but the live\nheap is otherwise large.",
      "code_examples": [
        {
          "language": "",
          "code": "SetGCPercent",
          "element": "<code>SetGCPercent</code>"
        },
        {
          "language": "",
          "code": "runtime/debug",
          "element": "<code>runtime/debug</code>"
        },
        {
          "language": "",
          "code": "SetGCPercent(-1)",
          "element": "<code>SetGCPercent(-1)</code>"
        },
        {
          "language": "",
          "code": "SetMemoryLimit",
          "element": "<code>SetMemoryLimit</code>"
        },
        {
          "language": "",
          "code": "runtime/debug",
          "element": "<code>runtime/debug</code>"
        },
        {
          "language": "",
          "code": "runtime.MemStats",
          "element": "<code>runtime.MemStats</code>"
        },
        {
          "language": "",
          "code": "HeapReleased",
          "element": "<code>HeapReleased</code>"
        },
        {
          "language": "",
          "code": "runtime/metrics",
          "element": "<code>runtime/metrics</code>"
        },
        {
          "language": "",
          "code": "/memory/classes/total:bytes",
          "element": "<code>/memory/classes/total:bytes</code>"
        },
        {
          "language": "",
          "code": "/memory/classes/heap/released:bytes",
          "element": "<code>/memory/classes/heap/released:bytes</code>"
        },
        {
          "language": "",
          "code": "2 * GOMAXPROCS",
          "element": "<code>2 * GOMAXPROCS</code>"
        },
        {
          "language": "",
          "code": "f := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(fd int) {\n\tsyscall.Close(f.fd) // Mistake: We reference f, so this cleanup won't run!\n}, f.fd)",
          "element": "<pre>\nf := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(fd int) {\n\tsyscall.Close(f.fd) // Mistake: We reference f, so this cleanup won't run!\n}, f.fd)\n</pre>"
        },
        {
          "language": "",
          "code": "f := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(f *myFile) {\n\tsyscall.Close(f.fd)\n}, f) // Mistake: We reference f, so this cleanup wouldn't ever run. This specific case also panics.",
          "element": "<pre>\nf := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(f *myFile) {\n\tsyscall.Close(f.fd)\n}, f) // Mistake: We reference f, so this cleanup wouldn't ever run. This specific case als..."
        },
        {
          "language": "",
          "code": "f := new(myCycle)\nf.self = f // Mistake: f is reachable from f, so this finalizer would never run.\nruntime.SetFinalizer(f, func(f *myCycle) {\n\t...\n})",
          "element": "<pre>\nf := new(myCycle)\nf.self = f // Mistake: f is reachable from f, so this finalizer would never run.\nruntime.SetFinalizer(f, func(f *myCycle) {\n\t...\n})\n</pre>"
        },
        {
          "language": "",
          "code": "f := new(myFile)\nf.fd = syscall.Open(...)\nruntime.SetFinalizer(f, func(_ *myFile) {\n\tsyscall.Close(f.fd) // Mistake: We reference the outer f, so this cleanup won't run!\n})",
          "element": "<pre>\nf := new(myFile)\nf.fd = syscall.Open(...)\nruntime.SetFinalizer(f, func(_ *myFile) {\n\tsyscall.Close(f.fd) // Mistake: We reference the outer f, so this cleanup won't run!\n})\n</pre>"
        },
        {
          "language": "",
          "code": "// Mistake: reclaiming this linked list will take at least 10 GC cycles.\nnode := new(linkedListNode)\nfor range 10 {\n\ttmp := new(linkedListNode)\n\ttmp.next = node\n\tnode = tmp\n\truntime.SetFinalizer(node, func(node *linkedListNode) {\n\t\t...\n\t})\n}",
          "element": "<pre>\n// Mistake: reclaiming this linked list will take at least 10 GC cycles.\nnode := new(linkedListNode)\nfor range 10 {\n\ttmp := new(linkedListNode)\n\ttmp.next = node\n\tnode = tmp\n\truntime.SetFinalizer..."
        },
        {
          "language": "",
          "code": "runtime.SetFinalizer",
          "element": "<code>runtime.SetFinalizer</code>"
        },
        {
          "language": "",
          "code": "runtime.Gosched",
          "element": "<code>runtime.Gosched</code>"
        },
        {
          "language": "",
          "code": "runtime.gcBgMarkWorker",
          "element": "<code>runtime.gcBgMarkWorker</code>"
        },
        {
          "language": "",
          "code": "runtime.gcDrainMarkWorkerDedicated",
          "element": "<code>runtime.gcDrainMarkWorkerDedicated</code>"
        },
        {
          "language": "",
          "code": "runtime.gcDrainMarkWorkerFractional",
          "element": "<code>runtime.gcDrainMarkWorkerFractional</code>"
        },
        {
          "language": "",
          "code": "runtime.gcDrainMarkWorkerIdle",
          "element": "<code>runtime.gcDrainMarkWorkerIdle</code>"
        },
        {
          "language": "",
          "code": "runtime.gcDrainMarkWorkerIdle",
          "element": "<code>runtime.gcDrainMarkWorkerIdle</code>"
        },
        {
          "language": "",
          "code": "runtime.mallocgc",
          "element": "<code>runtime.mallocgc</code>"
        },
        {
          "language": "",
          "code": "runtime.gcAssistAlloc",
          "element": "<code>runtime.gcAssistAlloc</code>"
        },
        {
          "language": "",
          "code": "runtime.mallocgc",
          "element": "<code>runtime.mallocgc</code>"
        },
        {
          "language": "",
          "code": "runtime/trace",
          "element": "<code>runtime/trace</code>"
        },
        {
          "language": "",
          "code": "GODEBUG=gctrace=1",
          "element": "<code>GODEBUG=gctrace=1</code>"
        },
        {
          "language": "",
          "code": "GODEBUG=gcpacertrace=1",
          "element": "<code>GODEBUG=gcpacertrace=1</code>"
        },
        {
          "language": "",
          "code": "inuse_objects",
          "element": "<code>inuse_objects</code>"
        },
        {
          "language": "",
          "code": "inuse_space",
          "element": "<code>inuse_space</code>"
        },
        {
          "language": "",
          "code": "alloc_objects",
          "element": "<code>alloc_objects</code>"
        },
        {
          "language": "",
          "code": "alloc_space",
          "element": "<code>alloc_space</code>"
        },
        {
          "language": "",
          "code": "-sample_index",
          "element": "<code>-sample_index</code>"
        },
        {
          "language": "",
          "code": "sample_index",
          "element": "<code>sample_index</code>"
        },
        {
          "language": "",
          "code": "runtime.MemProfileRate",
          "element": "<code>runtime.MemProfileRate</code>"
        },
        {
          "language": "",
          "code": "alloc_space",
          "element": "<code>alloc_space</code>"
        },
        {
          "language": "",
          "code": "$ go build -gcflags=-m=3 [package]",
          "element": "<pre>\n$ go build -gcflags=-m=3 [package]\n</pre>"
        },
        {
          "language": "",
          "code": "ui.diagnostic.annotations",
          "element": "<code>ui.diagnostic.annotations</code>"
        },
        {
          "language": "",
          "code": "/sys/kernel/mm/transparent_hugepage/enabled",
          "element": "<code>/sys/kernel/mm/transparent_hugepage/enabled</code>"
        },
        {
          "language": "",
          "code": "/sys/kernel/mm/transparent_hugepage/defrag",
          "element": "<code>/sys/kernel/mm/transparent_hugepage/defrag</code>"
        },
        {
          "language": "",
          "code": "defer+madvise",
          "element": "<code>defer+madvise</code>"
        },
        {
          "language": "",
          "code": "defer+madvise",
          "element": "<code>defer+madvise</code>"
        },
        {
          "language": "",
          "code": "/sys/kernel/mm/transparent_hugepage/khugepaged/max_ptes_none",
          "element": "<code>/sys/kernel/mm/transparent_hugepage/khugepaged/max_ptes_none</code>"
        },
        {
          "language": "",
          "code": "PR_SET_THP_DISABLE",
          "element": "<code>PR_SET_THP_DISABLE</code>"
        },
        {
          "language": "",
          "code": "GODEBUG=disablethp=1",
          "element": "<code>GODEBUG=disablethp=1</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "A Guide to the Go Garbage Collector",
          "id": ""
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "Introduction"
        },
        {
          "level": 2,
          "text": "The GC cycle",
          "id": "The_GC_cycle"
        },
        {
          "level": 2,
          "text": "A note about virtual memory",
          "id": "A_note_about_virtual_memory"
        },
        {
          "level": 2,
          "text": "Optimization guide",
          "id": "Optimization_guide"
        },
        {
          "level": 2,
          "text": "Appendix",
          "id": "Appendix"
        },
        {
          "level": 3,
          "text": "Where Go Values Live",
          "id": "Where_Go_Values_Live"
        },
        {
          "level": 3,
          "text": "Tracing Garbage Collection",
          "id": "Tracing_Garbage_Collection"
        },
        {
          "level": 3,
          "text": "Understanding costs",
          "id": "Understanding_costs"
        },
        {
          "level": 3,
          "text": "GOGC",
          "id": "GOGC"
        },
        {
          "level": 3,
          "text": "Memory limit",
          "id": "Memory_limit"
        },
        {
          "level": 3,
          "text": "Latency",
          "id": "Latency"
        },
        {
          "level": 3,
          "text": "Finalizers, cleanups, and weak pointersGarbage collection provides the illusion of infinite memory using only finite\nmemory.\nMemory is allocated but never explicitly freed, which enables simpler APIs and\nconcurrent algorithms compared to bare-bones manual memory management.\n(Some languages with manually managed memory use alternative approaches such\nas \"smart pointers\" and compile-time ownership tracking to ensure that objects\nare freed, but these features are deeply embedded into the API design\nconventions in these languages.)Only the live objectsthose reachable from a global variable or a\ncomputation in some goroutinecan affect the behavior of the program.\nAny time after an object becomes unreachable (\"dead\"), it may be safely\nrecycled by the GC.\nThis allows for a wide variety of GC designs, such as the tracing design used\nby Go today.\nThe death of an object is not an observable event at the language level.However, Go's runtime library provides three features that break that illusion:cleanups,weak pointers, andfinalizers.\nEach of these features provides some way to observe and react to object death,\nand in the case of finalizers, even reverse it.\nThis of course complicates Go programs and adds an additional burden to the GC\nimplementation.\nNonetheless, these features exist because they are useful in a variety of\ncircumstances, and Go programs use them and benefit from them all the time.For the details of each feature, refer to its package documentation\n(runtime.AddCleanup,weak.Pointer,runtime.SetFinalizer).\nBelow is some general advice for using these features, outlines of common\nissues you can run into with each feature, and advice for testing uses of these\nfeatures.General adviceWrite unit tests.The exact timing of cleanups, weak pointers, and finalizers can be difficult\n\t\tto predict, and it's easy to convince yourself that everything works, even\n\t\tafter many consecutive executions.\n\t\tBut it's also easy to make subtle mistakes.Writing testsfor them can be tricky, but\n\t\tgiven that they're so subtle to use, testing is even more important usual.Avoid using these features directly in typical Go code.These are low-level features with subtle restrictions and behaviors.\n\t\tFor instance, there's no guarantee cleanups or finalizers will be run\n\t\tat program exit, or at all for that matter.\n\t\tThe long comments in their API documentation should be seen as a warning.\n\t\tThe vast majority of Go code does not benefit from using these features\n\t\tdirectly, only indirectly.Encapsulate the use of these mechanisms within a package.Where possible, do not allow the use of these mechanisms to leak into\n\t\tthe public API of your package; provide interfaces that make it hard or\n\t\timpossible for users to misuse them.\n\t\tFor example, instead of asking the user to set up a cleanup on some\n\t\tC-allocated memory to free it, write a wrapper package and hide that\n\t\tdetail inside.Restrict access to objects that have finalizers, cleanups, and weak\n\t\tpointers to the package that created and applied them.This is related to the previous point, but is worth calling out\n\t\texplicitly, since it's a very powerful pattern for using these\n\t\tfeatures in a less error-prone way.\n\t\tFor example, theunique packageuses\n\t\tweak pointers under the hood, but completely encasulates the objects\n\t\tthat are weakly pointed-to.\n\t\tThose values can never be mutated by the rest of the application,\n\t\tit can only be copied through theValue method, preserving\n\t\tthe illusion of infinite memory for package users.Prefer cleaning up non-memory resources deterministically when possible,\n\t\twith finalizers and cleanups as a fallback.Cleanups and finalizers are a good fit for memory resources such as\n\t\tmemory allocated externally, like from C, or references to anmmapmapping.\n\t\tMemory allocated by C's malloc must eventually be freed by C's free.\n\t\tA finalizer that callsfree, attached to a wrapper object\n\t\tfor the C memory, is a reasonable way to ensure that C memory is\n\t\teventually reclaimed as a consequence of garbage collection.However, non-memory resources, like file descriptors, tend to be subject to\n\t\tsystem limits that the Go runtime is generally unaware of.\n\t\tIn addition, the timing of the garbage collector in a given Go program\n\t\tis usually something a package author has little control over (for instance,\n\t\thow often the GC runs is controlled byGOGC, which can\n\t\tbe set by operators to a variety of different values in practice).\n\t\tThese two facts conspire to make cleanups and finalizers a bad fit to use\n\t\tas the only mechanism for releasing non-memory resources.If you're a package author exposing an API that wraps some non-memory\n\t\tresource, consider providing an explicit API for releasing the resource\n\t\tdeterministically (through aClosemethod, or something similar),\n\t\trather than relying on the garbage collector through cleanups or finalizers.\n\t\tInstead, prefer to use cleanups and finalizers as a best-effort handler for\n\t\tprogrammer mistakes, either by cleaning up the resource anyway likeos.Filedoes, or by reporting the failure to\n\t\tdeterministically clean up back to the user.Prefer cleanups to finalizers.Historically, finalizers were added to simplify the interface between Go code\n\t\tand C code and to clean up non-memory resources.\n\t\tThe intended use was to apply them to wrapper objects that owned C memory or\n\t\tsome other non-memory resource, so that the resource could be released once\n\t\tGo code was done using it.\n\t\tThese reasons at least partially explain why finalizers are narrowly scoped,\n\t\twhy any given object can only have one finalizer, and why that finalizer must\n\t\tbe attached to the first byte of the object only.\n\t\tThis limitation already stifles some use-cases.\n\t\tFor example, any package that wishes to internally cache some information about\n\t\tan object passed to it cannot clean up that information once the object is gone.But worse than that, finalizers are inefficient and error-prone due to the fact\n\t\tthat theyresurrect\n\t\tthe objectthey're attached to, so that it can be passed to the finalizer\n\t\tfunction (and even continue to live beyond that, too).\n\t\tThis simple fact means that if the object is part of a reference cycle it can\n\t\tnever be freed, and the memory backing the object cannot be reused until at\n\t\tleast until the following garbage collection cycle.Because finalizers resurrect objects, though, they do have a better-defined\n\t\texection order than cleanups.\n\t\tFor this reason, finalizers are still potentially (but rarely) useful for\n\t\tcleaning up structures that have complex destruction ordering requirements.But for all other uses in Go 1.24 and beyond, we recommend you use cleanups\n\t\tbecause they are more flexible, less error-prone, and more efficient than\n\t\tfinalizers.Common cleanup issuesObjects with attached cleanups must not be reachable from the cleanup\n\t\tfunction (for example, through a captured local variable).\n\t\tThis will prevent the object from being reclaimed and the cleanup from\n\t\tever running.f := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(fd int) {\n\tsyscall.Close(f.fd) // Mistake: We reference f, so this cleanup won't run!\n}, f.fd)Objects with attached cleanups must not be reachable from the argument\n\t\tto the cleanup function.\n\t\tThis will prevent the object from being reclaimed and the cleanup from\n\t\tever running.f := new(myFile)\nf.fd = syscall.Open(...)\nruntime.AddCleanup(f, func(f *myFile) {\n\tsyscall.Close(f.fd)\n}, f) // Mistake: We reference f, so this cleanup wouldn't ever run. This specific case also panics.Finalizers have a well-defined execution order, but cleanups do not.\n\t\tCleanups can also run concurrently with one another.runtime.GCwill not wait until cleanups for unreachable\n\t\tobjects are executed, only until they are all queued.Common weak pointer issuesWeak pointers can begin returningnilfrom theirValuemethod at unexpected times.\n\t\tAlways guard the call toValuewith anilcheck and have a backup plan.When weak pointers are used as map keys, they do not affect the\n\t\treachability of map values.\n\t\tTherefore, if a weak pointer map key points to an object that is also\n\t\treachable from the map value, that object will still be considered\n\t\treachable.Common finalizer issuesObjects with attached finalizers must not be reachable from themselves\n\t\tby any path (in other words, they cannot be in a reference cycle).\n\t\tThis will prevent the object from being reclaimed and the finalizer from\n\t\tever running.f := new(myCycle)\nf.self = f // Mistake: f is reachable from f, so this finalizer would never run.\nruntime.SetFinalizer(f, func(f *myCycle) {\n\t...\n})Objects with attached finalizers must not be reachable from the finalizer\n\t\tfunction (for example, through a captured local variable).\n\t\tThis will prevent the object from being reclaimed and the finalizer from\n\t\tever running.f := new(myFile)\nf.fd = syscall.Open(...)\nruntime.SetFinalizer(f, func(_ *myFile) {\n\tsyscall.Close(f.fd) // Mistake: We reference the outer f, so this cleanup won't run!\n})Reference chains of objects with attached finalizers (say, in a linked list)\n\t\ttake, at minimum, as many GC cycles as there are objects in the chain\n\t\tto clean them all up.\n\t\tKeep finalizers shallow!// Mistake: reclaiming this linked list will take at least 10 GC cycles.\nnode := new(linkedListNode)\nfor range 10 {\n\ttmp := new(linkedListNode)\n\ttmp.next = node\n\tnode = tmp\n\truntime.SetFinalizer(node, func(node *linkedListNode) {\n\t\t...\n\t})\n}Avoid placing finalizers on objects returned at package boundaries.\n\t\tThis makes it possible for users of your package to callruntime.SetFinalizerto mutate the finalizer on the object\n\t\tyou return, which can be an unexpected behavior that users of your package\n\t\tmay end up relying on.runtime.GCwill not wait until finalizers for unreachable\n\t\tobjects are executed, only until they are all queued.Testing object deathWhen using these features, it can sometimes be tricky to write tests for code that\nuses them.\nHere are some tips for writing robust tests for code that uses these features.Avoid running such tests in parallel with other tests.\n\t\tIt helps a lot to increase determinism as much as possible and to have\n\t\ta good handle on the state of the world at any given time.Useruntime.GCto establish a baseline upon entering the\n\t\ttest.\n\t\tUseruntime.GCto force weak pointers tonil,\n\t\tand to queue up cleanups and finalizers to run.runtime.GCdoes not wait for cleanups and finalizers to run,\n\t\tit only queues them.To write the most robust tests possible, inject a way to block on a cleanup\n\t\tor finalizer from your test (for example, pass an optional channel to the\n\t\tcleanup and/or finalizer from the test, and write to the channel once it\n\t\thas finished executing).\n\t\tIf this is too hard or impossible, an alternative is to spin on a particular\n\t\tpost-cleanup state to be true.\n\t\tFor example, theostests callruntime.Goschedin\n\t\ta loop that checks whether a file has been closed, once it becomes\n\t\tunreachable.If writing tests for using finalizers, and you have a chain of objects\n\t\tthat use finalizers, you will need at minimum the length of the deepest\n\t\tchain the test can create ofruntime.GCcalls to ensure\n\t\tall the finalizers run.Test in race mode to discover races between concurrent cleanups, and\n\t\tbetween cleanup and finalizer code and the rest of the codebase.Additional resourcesWhile the information presented above is accurate, it lacks the detail to\nfully understand costs and trade-offs in the Go GC's design.\nFor more information, see the following additional resources.The GC HandbookAn\n\t\t\texcellent general resource and reference on garbage collector design.TCMallocDesign\n\t\t\tdocument for the C/C++ memory allocator TCMalloc, which the Go memory allocator is based on.Go 1.5 GC announcementThe\n\t\t\tblog post announcing the Go 1.5 concurrent GC, which describes the algorithm in more detail.Getting to GoAn\n\t\t\tin-depth presentation about the evolution of Go's GC design up to 2018.Go 1.5 concurrent GC pacingDesign\n\t\t\tdocument for determining when to start a concurrent mark phase.Smarter scavengingDesign\n\t\t\tdocument for revising the way the Go runtime returns memory to the operating system.Scalable page allocatorDesign\n\t\t\tdocument for revising the way the Go runtime manages memory it gets from the operating system.GC pacer redesign (Go 1.18)Design\n\t\t\tdocument for revising the algorithm to determine when to start a concurrent mark phase.Soft memory limit (Go 1.19)Design\n\t\t\tdocument for the soft memory limit.A note about virtual memoryThis guide has largely focused on the physical memory use of the GC, but a\nquestion that comes up regularly is what exactly that means and how it compares\nto virtual memory (typically presented in programs liketopas\n\"VSS\").Physical memory is memory housed in the actual physical RAM chip in most\ncomputers.Virtual memoryis an\nabstraction over physical memory provided by the operating system to isolate\nprograms from one another.\nIt's also typically acceptable for programs to reserve virtual address space\nthat doesn't map to any physical addresses at all.Because virtual memory is just a mapping maintained by the operating system,\nit is typically very cheap to make large virtual memory reservations that don't\nmap to physical memory.The Go runtime generally relies upon this view of the cost of virtual memory in\na few ways:The Go runtime never deletes virtual memory that it maps.\n\t\tInstead, it uses special operations that most operating systems\n\t\tprovide to explicitly release any physical memory resources\n\t\tassociated with some virtual memory range.This technique is used explicitly to manage thememory limitand return memory to the\n\t\toperating system that the Go runtime no longer needs.\n\t\tThe Go runtime also releases memory it no longer needs continuously\n\t\tin the background.\n\t\tSeethe additional resourcesfor\n\t\tmore information.On 32-bit platforms, the Go runtime reserves between 128 MiB and 512 MiB\n\t\tof address space up-front for the heap to limit fragmentation issues.The Go runtime uses large virtual memory address space reservations\n\t\tin the implementation of several internal data structures.\n\t\tOn 64-bit platforms, these typically have a minimum virtual memory\n\t\tfootprint of about 700 MiB.\n\t\tOn 32-bit platforms, their footprint is negligible.As a result, virtual memory metrics such as \"VSS\" intopare\ntypically not very useful in understanding a Go program's memory footprint.\nInstead, focus on \"RSS\" and similar measurements, which more directly reflect\nphysical memory usage.Optimization guideIdentifying costsBefore trying to optimize how your Go application interacts with the GC, it's\nimportant to first identify that the GC is a major cost in the first place.The Go ecosystem provides a number of tools for identifying costs and optimizing\nGo applications.\nFor a brief overview of these tools, see theguide on diagnostics.\nHere, we'll focus on a subset of these tools and a reasonable order to apply\nthem in in order to understand GC impact and behavior.CPU profilesA good place to start is withCPU profiling.\n\t\tCPU profiling provides an overview of where CPU time is spent, though to the\n\t\tuntrained eye it may be difficult to identify the magnitude of the role the\n\t\tGC plays in a particular application.\n\t\tLuckily, understanding how the GC fits in mostly boils down to knowing what\n\t\tdifferent functions in the `runtime` package mean.\n\t\tBelow is a useful subset of these functions for interpreting CPU profiles.Note that the functions listed below are not leaf functions, so they may not show\n\t\tup in the default thepproftool provides with thetopcommand.\n\t\tInstead, use thetop -cumcommand or use thelistcommand on these functions directly and focus on the cumulative percent column.runtime.gcBgMarkWorker: Entrypoint to the\n\t\t\tbackground mark worker goroutines.\n\t\t\tTime spent here scales with GC frequency and the complexity and\n\t\t\tsize of the object graph.\n\t\t\tIt represents a baseline for how much time the application spends\n\t\t\tmarking and scanning.Note that within these goroutines, you will find calls toruntime.gcDrainMarkWorkerDedicated,runtime.gcDrainMarkWorkerFractional, andruntime.gcDrainMarkWorkerIdle,\n\t\t\twhich indicate worker type.\n\t\t\tIn a largely idle Go application, the Go GC is going to use up\n\t\t\tadditional (idle) CPU resources to get its job done faster, which\n\t\t\tis indicated with theruntime.gcDrainMarkWorkerIdlesymbol.\n\t\t\tAs a result, time here may represent a large fraction of CPU\n\t\t\tsamples, which the Go GC believes are free.\n\t\t\tIf the application becomes more active, CPU time in idle workers\n\t\t\twill drop.\n\t\t\tOne common reason this can happen is if an application runs entirely\n\t\t\tin one goroutine butGOMAXPROCSis >1.runtime.mallocgc: Entrypoint to the memory\n\t\t\tallocator for heap memory.\n\t\t\tA large amount of cumulative time spent here (>15%)\n\t\t\ttypically indicates a lot of memory being allocated.runtime.gcAssistAlloc: Function goroutines\n\t\t\tenter to yield some of their time to assist the GC with scanning\n\t\t\tand marking.\n\t\t\tA large amount of cumulative time spent here (>5%) indicates\n\t\t\tthat the application is likely out-pacing the GC with respect to how\n\t\t\tfast it's allocating.\n\t\t\tIt indicates a particularly high degree of impact from the GC,\n\t\t\tand also represents time the application spend marking and scanning.\n\t\t\tNote that this is included in theruntime.mallocgccall tree, so it will inflate that as well.Execution tracesWhile CPU profiles are great for identifying where time is spent in\n\t\taggregate, they're less useful for indicating performance costs that\n\t\tare more subtle, rare, or related to latency specifically.\n\t\tExecution traceson\n\t\tthe other hand provide a rich and deep view into a short window of\n\t\ta Go program's execution.\n\t\tThey contain a variety of events related to the Go GC and specific\n\t\texecution paths can be directly observed, along with how the application\n\t\tmight interact with the Go GC.\n\t\tAll the GC events tracked are conveniently labeled as such in the trace\n\t\tviewer.See thedocumentation for theruntime/tracepackage for how to get started with\n\t\texecution traces.GC tracesWhen all else fails, the Go GC provides a few different specific traces\n\t\tthat provide much deeper insights into GC behavior.\n\t\tThese traces are always printed directly to STDERR, one line per GC cycle,\n\t\tand are configured through theGODEBUGenvironment variable\n\t\tthat all Go programs recognize.\n\t\tThey're mostly useful for debugging the Go GC itself since they require\n\t\tsome familiarity with the specifics of the GC's implementation, but\n\t\tnonetheless can occasionally be useful to gain a better understanding of\n\t\tGC behavior.The core GC trace is enabled by settingGODEBUG=gctrace=1.\n\t\tThe output produced by this trace is documented in theenvironment\n\t\tvariables section in the documentation for theruntimepackage.A supplementary GC trace called the \"pacer trace\" provides even deeper\n\t\tinsights and is enabled by settingGODEBUG=gcpacertrace=1.\n\t\tInterpreting this output requires an understanding of the GC's \"pacer\"\n\t\t(seeadditional resources), which is\n\t\toutside the scope of this guide.Eliminating heap allocationsOne way to reduce costs from the GC is to have the GC manage fewer values to begin\nwith.\nThe techniques described below can produce some of the largest improvements in\nperformance, because as theGOGC sectiondemonstrated, the\nallocation rate of a Go program is a major factor in GC frequency, the key\ncost metric used by this guide.Heap profilingAfteridentifying that the GC is a source of\nsignificant costs, the next step in eliminating heap allocations is to\nfind out where most of them are coming from.\nFor this purpose, memory profiles (really, heap memory profiles) are very\nuseful.\nCheck out thedocumentationfor how to get started with them.Memory profiles describe where in the program heap allocations come from,\nidentifying them by the stack trace at the point they were allocated.\nEach memory profile can break down memory in four ways.inuse_objectsBreaks down the number of objects that\n\tare live.inuse_spaceBreaks down live objects by how much\n\tmemory they use in bytes.alloc_objectsBreaks down the number of objects\n\tthat have been allocated since the Go program began executing.alloc_spaceBreaks down the total amount of memory\n\tallocated since the Go program began executing.Switching between these different views of heap memory may be done with either\nthe-sample_indexflag to thepproftool, or via thesample_indexoption when the tool is used interactively.Note: memory profiles by default only sample a subset of heap objects so they\nwill not contain information about every single heap allocation.\nHowever, this is sufficient to find hot-spots.\nTo change the sampling rate, seeruntime.MemProfileRate.For the purposes of reducing GC costs,alloc_spaceis typically the\nmost useful view as it directly corresponds to the allocation rate.\nThis view will indicate allocation hot spots that would provide the most benefit.Escape analysisOnce candidate heap allocation sites have been identified with the help ofheap profiles, how can they be eliminated?\nThe key is to leverage the Go compiler's escape analysis to have the Go compiler\nfind alternative, and more efficient storage for this memory, for example\nin the goroutine stack.\nLuckily, the Go compiler has the ability to describe why it decides to escape\na Go value to the heap.\nWith that knowledge, it becomes a matter of reorganizing your source code to\nchange the outcome of the analysis (which is often the hardest part, but outside\nthe scope of this guide).As for how to access the information from the Go compiler's escape analysis, the\nsimplest way is through a debug flag supported by the Go compiler that describes\nall optimizations it applied or did not apply to some package in a text format.\nThis includes whether or not values escape.\nTry the following command, where[package]is some Go package path.$ go build -gcflags=-m=3 [package]This information can also be visualized as an overlay in\nan LSP-capable editor; it is exposed as a code action.\n\nFor example, in VS Code, invoke the \"Source Action... > Show compiler\noptimization details\" command to enable diagnostics for the current package.\n(You can also run the \"Go: Toggle compiler optimization details\"\ncommand.)\n\nUse this configuration setting to control which annotations are displayed:Enable the overlay for escape analysis bysettingui.diagnostic.annotationsto includeescape.Finally, the Go compiler provides this information in a machine-readable (JSON)\nformat that may be used to build additional custom tooling.\nFor more information on that, see thedocumentation in the source Go code.Implementation-specific optimizationsThe Go GC is sensitive to the demographics of live memory, because a complex\ngraph of objects and pointers both limits parallelism and generates more work\nfor the GC.\nAs a result, the GC contains a few optimizations for specific common structures.\nThe most directly useful ones for performance optimization are listed below.Note: Applying the optimizations below may reduce the readability of your code\nby obscuring intent, and may fail to hold up across Go releases.\nPrefer to apply these optimizations only in the places they matter most.\nSuch places may be identified by using the tools listed in thesection on identifying costs.Pointer-free values are segregated from other values.As a result, it may be advantageous to eliminate pointers from data\n\t\tstructures that do not strictly need them, as this reduces the cache\n\t\tpressure the GC exerts on the program.\n\t\tAs a result, data structures that rely on indices over pointer values,\n\t\twhile less well-typed, may perform better.\n\t\tThis is only worth doing if it's clear that the object graph is complex\n\t\tand the GC is spending a lot of time marking and scanning.The GC will stop scanning values at the last pointer in the value.As a result, it may be advantageous to group pointer fields in\n\t\tstruct-typed values at the beginning of the value.\n\t\tThis is only worth doing if it's clear the application spends a lot of its\n\t\ttime marking and scanning.\n\t\t(In theory the compiler can do this automatically, but it is not yet\n\t\timplemented, and struct fields are arranged as written in the source\n\t\tcode.)Furthermore, the GC must interact with nearly every pointer it sees, so using\nindices into an slice, for example, instead of pointers, can aid in reducing GC\ncosts.Linux transparent huge pages (THP)When a program accesses memory, the CPU needs to translate thevirtual memoryaddresses it uses\ninto physical memory addresses that refer to the data it was trying to access.\nTo do this, the CPU consults the \"page table,\" a data structure that represents\nthe mapping from virtual to physical memory, managed by the operating system.\nEach entry in the page table represents an indivisible block of physical memory\ncalled a page, hence the name.Transparent huge pages (THP) is a Linux feature that transparently replaces pages of\nphysical memory backing contiguous virtual memory regions with bigger blocks of memory\ncalled huge pages.\nBy using bigger blocks, fewer page table entries are needed to represent the same memory\nregion, improving page table lookup times.\nHowever, bigger blocks mean more waste if only a small part of the huge page is used\nby the system.When running Go programs in production, enabling transparent huge pages on Linux\ncan improve throughput and latency at the cost of additional memory use.\nApplications with small heaps tend not to benefit from THP and may end up using a\nsubstantial amount of additional memory (as high as 50%).\nHowever, applications with big heaps (1 GiB or more) tend to benefit quite a bit\n(up to 10% throughput) without very much additional memory overhead (1-2% or less).\nBeing aware of your THP settings in either case can be helpful, and experimentation\nis always recommended.One can enable or disable transparent huge pages in a Linux environment by modifying/sys/kernel/mm/transparent_hugepage/enabled.\nSee theofficial\nLinux admin guidefor more details.\nIf you choose to have your Linux production environment enable transparent huge pages,\nwe recommend the following additional settings for Go programs.Set/sys/kernel/mm/transparent_hugepage/defragtodeferordefer+madvise.This setting controls how aggressively a Linux kernel coalesces regular\n\t\tpages into huge pages.defertells the kernel to coalesce huge pages lazily\n\t\tand in the background.\n\t\tA more aggressive setting can induce stalls in memory constrained systems\n\t\tand can often hurt application latencies.defer+madviseis likedefer, but is friendlier\n\t\tto other applications on the system that request huge pages explicitly and\n\t\trequire them for performance.Set/sys/kernel/mm/transparent_hugepage/khugepaged/max_ptes_noneto0.This setting controls how many additional pages the Linux kernel daemon\n\t\tcan allocate when trying to allocate a huge page.\n\t\tThe default setting is maximally aggressive, and can oftenundo work the Go\n\t\truntime does to return memory to the OS.\n\t\tBefore Go 1.21, the Go runtime tried to mitigate the negative effects of the\n\t\tdefault setting, but it came with a CPU cost.\n\t\tWith Go 1.21+ and Linux 6.2+, the Go runtime no longer mutates huge page\n\t\tstate.If you experience an increase in memory usage when upgrading to Go 1.21.1 or\n\t\tlater, try applying this setting; it will likely resolve your issue.\n\t\tAs an additional workaround, you can callthePrctlfunctionwithPR_SET_THP_DISABLEto disable huge pages at\n\t\tthe process level, or you can setGODEBUG=disablethp=1(to be\n\t\tadded in Go 1.21.6 and Go 1.22) to disable huge pages for heap memory.\n\t\tNote that theGODEBUGsetting may be removed in a future release.AppendixAdditional notes on GOGCTheGOGC sectionclaimed that doubling GOGC doubles heap\nmemory overheads and halves GC CPU costs.\nTo see why, let's break it down mathematically.Firstly, the heap target sets a target for the total heap size.\nThis target, however, mainly influences the new heap memory, because the live\nheap is fundamental to the application.Target heap memory = Live heap + (Live heap + GC roots) * GOGC / 100Total heap memory = Live heap + New heap memoryNew heap memory = (Live heap + GC roots) * GOGC / 100From this we can see that doubling GOGC would also double the amount of new heap\nmemory that application will allocate each cycle, which captures heap memory\noverheads.\nNote thatLive heap + GC rootsis an approximation of the amount of\nmemory the GC needs to scan.Next, let's look at GC CPU cost.\nTotal cost can be broken down as the cost per cycle, times GC frequency over\nsome time period T.Total GC CPU cost = (GC CPU cost per cycle) * (GC frequency) * TGC CPU cost per cycle can be derived from theGC model:GC CPU cost per cycle = (Live heap + GC roots) * (Cost per byte) + Fixed costNote that sweep phase costs are ignored here as mark and scan costs dominate.The steady state is defined by a constant allocation rate and a constant cost\nper byte, so in the steady state we can derive a GC frequency from this new heap\nmemory:GC frequency = (Allocation rate) / (New heap memory) = (Allocation rate) / ((Live heap + GC roots) * GOGC / 100)Putting this together, we get the full equation for the total cost:Total GC CPU cost = (Allocation rate) / ((Live heap + GC roots) * GOGC / 100) * ((Live heap + GC roots) * (Cost per byte) + Fixed cost) * TFor a sufficiently large heap (which represents most cases), the marginal costs\nof a GC cycle dominate the fixed costs.\nThis allows for a significant simplification of the total GC CPU cost formula.Total GC CPU cost = (Allocation rate) / (GOGC / 100) * (Cost per byte) * TFrom this simplified formula, we can see that if we double GOGC, we halve total\nGC CPU cost.\n(Note that the visualizations in this guide do simulate fixed costs, so the GC\nCPU overheads reported by them will not exactly halve when GOGC doubles.)\nFurthermore, GC CPU costs are largely determined by allocation rate and the\ncost per byte to scan memory.\nFor more information on how to reduce these costs specifically, see theoptimization guide.Note: there exists a discrepancy between the size of the live heap, and the\namount of that memory the GC actually needs to scan: the same size live heap but\nwith a different structure will result in a different CPU cost, but the same\nmemory cost, resulting a different trade-off.\nThis is why the structure of the heap is part of the definition of the\nsteady state.\nThe heap target should arguably only include the scannable live heap as a closer\napproximation of memory the GC needs to scan, but this leads to degenerate\nbehavior when there's a very small amount of scannable live heap but the live\nheap is otherwise large.",
          "id": "Finalizers_cleanups_and_weak_pointers"
        },
        {
          "level": 3,
          "text": "Additional resources",
          "id": "Additional_resources"
        },
        {
          "level": 3,
          "text": "Identifying costs",
          "id": "Identiying_costs"
        },
        {
          "level": 3,
          "text": "Eliminating heap allocations",
          "id": "Eliminating_heap_allocations"
        },
        {
          "level": 3,
          "text": "Implementation-specific optimizations",
          "id": "Implementation-specific_optimizations"
        },
        {
          "level": 3,
          "text": "Linux transparent huge pages (THP)",
          "id": "Linux_transparent_huge_pages"
        },
        {
          "level": 3,
          "text": "Additional notes on GOGC",
          "id": "Additional_notes_on_GOGC"
        },
        {
          "level": 4,
          "text": "Suggested uses",
          "id": "Suggested_uses"
        },
        {
          "level": 4,
          "text": "General advice",
          "id": "General_advice"
        },
        {
          "level": 4,
          "text": "Common cleanup issues",
          "id": "Common_cleanup_issues"
        },
        {
          "level": 4,
          "text": "Common weak pointer issues",
          "id": "Common_weak_pointer_issues"
        },
        {
          "level": 4,
          "text": "Common finalizer issues",
          "id": "Common_finalizer_issues"
        },
        {
          "level": 4,
          "text": "Testing object death",
          "id": "Testing_object_death"
        },
        {
          "level": 4,
          "text": "Heap profiling",
          "id": "Heap_profiling"
        },
        {
          "level": 4,
          "text": "Escape analysis",
          "id": "Escape_analysis"
        }
      ],
      "timestamp": 1750757609.60955
    },
    {
      "url": "https://golang.org/doc/modules/managing-dependencies",
      "title": "Managing dependencies - The Go Programming Language",
      "content": "Managing dependencies\nWhen your code uses external packages, those packages (distributed as modules)\nbecome dependencies. Over time, you may need to upgrade them or replace them. Go\nprovides dependency management tools that help you keep your Go applications\nsecure as you incorporate external dependencies.\nThis topic describes how to perform tasks to manage dependencies you take on in\nyour code. You can perform most of these with Go tools. This topic also\ndescribes how to perform a few other dependency-related tasks you might find\nuseful.\nSee also\nIf youre new to working with dependencies as modules, take a look at the\nGetting started tutorial\nfor a brief introduction.\nUsing the\ngo\ncommand to manage dependencies helps ensure that your\nrequirements remain consistent and the content of your go.mod file is valid.\nFor reference on the commands, see\nCommand go\n.\nYou can also get help from the command line by typing\ngo help\ncommand-name\n, as with\ngo help mod tidy\n.\nGo commands you use to make dependency changes edit your go.mod file. For\nmore about the contents of the file, see\ngo.mod file reference\n.\nMaking your editor or IDE aware of Go modules can make the work of managing\nthem easier. For more on editors that support Go, see\nEditor plugins and\nIDEs\n.\nThis topic doesnt describe how to develop, publish, and version modules for\nothers to use. For more on that, see\nDeveloping and publishing\nmodules\n.\nWorkflow for using and managing dependencies\nYou can get and use useful packages with Go tools. On\npkg.go.dev\n, you can search for packages you might find\nuseful, then use the\ngo\ncommand to import those packages into your own code to\ncall their functions.\nThe following lists the most common dependency management steps. For more about\neach, see the sections in this topic.\nLocate useful packages\non\npkg.go.dev\n.\nImport the packages\nyou want in your code.\nAdd your code to a module for dependency tracking (if it isnt in a module\nalready). See\nEnabling dependency tracking\nAdd external packages as dependencies\nso you can manage\nthem.\nUpgrade or downgrade dependency versions\nas needed over time.\nManaging dependencies as modules\nIn Go, you manage dependencies as modules that contain the packages you import.\nThis process is supported by:\nA\ndecentralized system for publishing\nmodules and retrieving their code.\nDevelopers make their modules available for other developers to use from\ntheir own repository and publish with a version number.\nA\npackage search engine\nand documentation browser (pkg.go.dev) at which\nyou can find modules. See\nLocating and importing useful packages\n.\nA module\nversion numbering convention\nto help you understand a modules\nstability and backward compatibility guarantees. See\nModule version\nnumbering\n.\nGo tools\nthat make it easier for you to manage dependencies, including\ngetting a modules source, upgrading, and so on. See sections of this topic\nfor more.\nLocating and importing useful packages\nYou can search\npkg.go.dev\nto find packages with functions\nyou might find useful.\nWhen youve found a package you want to use in your code, locate the package\npath at the top of the page and click the Copy path button to copy the path to\nyour clipboard. In your own code, paste the path into an import statement, as in\nthe following example:\nimport \"rsc.io/quote\"\nAfter your code imports the package, enable dependency tracking and get the\npackages code to compile with. For more, see\nEnabling dependency tracking in\nyour code\nand\nAdding a dependency\n.\nEnabling dependency tracking in your code\nTo track and manage the dependencies you add, you begin by putting your code in\nits own module. This creates a go.mod file at the root of your source tree.\nDependencies you add will be listed in that file.\nTo add your code to its own module, use the\ngo mod init\ncommand\n. For example, from the command\nline, change to your codes root directory, then run the command as in the\nfollowing example:\n$ go mod init example/mymodule\nThe\ngo mod init\ncommands argument is your modules module path. If possible,\nthe module path should be the repository location of your source code.\nIf at first you dont know the modules eventual repository location, use a\nsafe substitute. This might be the name of a domain you own or another name you\ncontrol (such as your company name), along with a path following from the\nmodules name or source directory. For more, see\nNaming a module\n.\nAs you use Go tools to manage dependencies, the tools update the go.mod file so\nthat it maintains a current list of your dependencies.\nWhen you add dependencies, Go tools also create a go.sum file that contains\nchecksums of modules you depend on. Go uses this to verify the integrity of\ndownloaded module files, especially for other developers working on your\nproject.\nInclude the go.mod and go.sum files in your repository with your code.\nSee the\ngo.mod reference\nfor more.\nNaming a module\nWhen you run\ngo mod init\nto create a module for tracking dependencies, you\nspecify a module path that serves as the modules name. The module path\nbecomes the import path prefix for packages in the module. Be sure to specify\na module path that wont conflict with the module path of other modules.\nAt a minimum, a module path need only indicate something about its origin, such\nas a company or author or owner name. But the path might also be more\ndescriptive about what the module is or does.\nThe module path is typically of the following form:\n<prefix>/<descriptive-text>\nThe\nprefix\nis typically a string that partially describes the module, such\nas a string that describes its origin. This might be:\nThe location of the repository where Go tools can find the modules source\ncode (required if youre publishing the module).\nFor example, it might be\ngithub.com/<project-name>/\n.\nUse this best practice if you think you might publish the module for\nothers to use. For more about publishing, see\nDeveloping and publishing modules\n.\nA name you control.\nIf youre not using a repository name, be sure to choose a prefix that\nyoure confident wont be used by others. A good choice is your\ncompanys name. Avoid common terms such as\nwidgets\n,\nutilities\n, or\napp\n.\nFor the\ndescriptive text\n, a good choice would be a project name. Remember\nthat package names carry most of the weight of describing functionality.\nThe module path creates a namespace for those package names.\nReserved module path prefixes\nGo guarantees that the following strings wont be used in package names.\ntest\n You can use\ntest\nas a module path prefix for a module whose code\nis designed to locally test functions in another module.\nUse the\ntest\npath prefix for modules that are created as part of a test.\nFor example, your test itself might run\ngo mod init test\nand then set up\nthat module in some particular way in order to test with a Go source code\nanalysis tool.\nexample\n Used as a module path prefix in some Go documentation, such as\nin tutorials where youre creating a module just to track dependencies.\nNote that Go documentation also uses\nexample.com\nto illustrate when the\nexample might be a published module.\nAdding a dependency\nOnce youre importing packages from a published module, you can add that module\nto manage as a dependency by using the\ngo get\ncommand\n.\nThe command does the following:\nIf needed, it adds\nrequire\ndirectives to your go.mod file for modules\nneeded to build packages named on the command line. A\nrequire\ndirective\ntracks the minimum version of a module that your module depends on. See the\ngo.mod reference\nfor more.\nIf needed, it downloads module source code so you can compile packages that\ndepend on them. It can download modules from a module proxy like\nproxy.golang.org or directly from version control repositories. The source\nis cached locally.\nYou can set the location from which Go tools download modules. For more, see\nSpecifying a module proxy server\n.\nThe following describes a few examples.\nTo add all dependencies for a package in your module, run a command like the\none below (\".\" refers to the package in the current directory):\n$ go get .\nTo add a specific dependency, specify its module path as an argument to the\ncommand.\n$ go get example.com/theirmodule\nThe command also authenticates each module it downloads. This ensures that its\nunchanged from when the module was published. If the module has changed since it\nwas published  for example, the developer changed the contents of the commit\n Go tools will present a security error. This authentication check protects\nyou from modules that might have been tampered with.\nGetting a specific dependency version\nYou can get a specific version of a dependency module by specifying its version\nin the\ngo get\ncommand. The command updates the\nrequire\ndirective in your\ngo.mod file (though you can also update that manually).\nYou might want to do this if:\nYou want to get a specific pre-release version of a module to try out.\nYouve discovered that the version youre currently requiring isnt working\nfor you, so you want to get a version you know you can rely on.\nYou want to upgrade or downgrade a module youre already requiring.\nHere are examples for using the\ngo get\ncommand\n:\nTo get a specific numbered version, append the module path with an @ sign\nfollowed by the version you want:\n$ go get example.com/theirmodule@v1.3.4\nTo get the latest version, append the module path with\n@latest\n:\n$ go get example.com/theirmodule@latest\nThe following go.mod file\nrequire\ndirective example (see the\ngo.mod\nreference\nfor more) illustrates how to require a specific version\nnumber:\nrequire example.com/theirmodule v1.3.4\nDiscovering available updates\nYou can check to see if there are newer versions of dependencies youre already\nusing in your current module. Use the\ngo list\ncommand to display a list of\nyour modules dependencies, along with the latest version available for that\nmodule. Once youve discovered available upgrades, you can try them out with your\ncode to decide whether or not to upgrade to new versions.\nFor more about the\ngo list\ncommand, see\ngo list -m\n.\nHere are a couple of examples.\nList all of the modules that are dependencies of your current module,\nalong with the latest version available for each:\n$ go list -m -u all\nDisplay the latest version available for a specific module:\n$ go list -m -u example.com/theirmodule\nUpgrading or downgrading a dependency\nYou can upgrade or downgrade a dependency module by using Go tools to discover\navailable versions, then add a different version as a dependency.\nTo discover new versions use the\ngo list\ncommand as described in\nDiscovering available updates\n.\nTo add a particular version as a dependency, use the\ngo get\ncommand as\ndescribed in\nGetting a specific dependency version\n.\nSynchronizing your codes dependencies\nYou can ensure that youre managing dependencies for all of your codes imported\npackages while also removing dependencies for packages youre no longer\nimporting.\nThis can be useful when youve been making changes to your code and\ndependencies, possibly creating a collection of managed dependencies and\ndownloaded modules that no longer match the collection specifically required by\nthe packages imported in your code.\nTo keep your managed dependency set tidy, use the\ngo mod tidy\ncommand. Using\nthe set of packages imported in your code, this command edits your go.mod file\nto add modules that are necessary but missing. It also removes unused modules\nthat dont provide any relevant packages.\nThe command has no arguments except for one flag, -v, that prints information\nabout removed modules.\n$ go mod tidy\nDeveloping and testing against unpublished module code\nYou can specify that your code should use dependency modules that may not be\npublished. The code for these modules might be in their respective repositories,\nin a fork of those repositories, or on a drive with the current module that\nconsumes them.\nYou might want to do this when:\nYou want to make your own changes to an external modules code, such as\nafter forking and/or cloning it. For example, you might want to prepare a\nfix to the module, then send it as a pull request to the modules developer.\nYoure building a new module and havent yet published it, so its\nunavailable on a repository where the\ngo get\ncommand can reach it.\nRequiring module code in a local directory\nYou can specify that the code for a required module is on the same local drive\nas the code that requires it. You might find this useful when you are:\nDeveloping your own separate module and want to test from the current module.\nFixing issues in or adding features to an external module and want to test\nfrom the current module. (Note that you can also require the external module\nfrom your own fork of its repository. For more, see\nRequiring external\nmodule code from your own repository fork\n.)\nTo tell Go commands to use the local copy of the modules code, use the\nreplace\ndirective in your go.mod file to replace the module path given in a\nrequire\ndirective. See the\ngo.mod reference\nfor\nmore about directives.\nIn the following go.mod file example, the current module requires the external\nmodule\nexample.com/theirmodule\n, with a nonexistent version number\n(\nv0.0.0-unpublished\n) used to ensure the replacement works correctly. The\nreplace\ndirective then replaces the original module path with\n../theirmodule\n, a directory that is at the same level as the current modules\ndirectory.\nmodule example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v0.0.0-unpublished\n\nreplace example.com/theirmodule v0.0.0-unpublished => ../theirmodule\nWhen setting up a\nrequire\n/\nreplace\npair, use the\ngo mod edit\nand\ngo get\ncommands\nto ensure that requirements described by the file remain consistent:\n$ go mod edit -replace=example.com/theirmodule@v0.0.0-unpublished=../theirmodule\n$ go get example.com/theirmodule@v0.0.0-unpublished\nNote:\nWhen you use the replace directive, Go tools dont authenticate\nexternal modules as described in\nAdding a dependency\n.\nFor more about version numbers, see\nModule version numbering\n.\nRequiring external module code from your own repository fork\nWhen you have forked an external modules repository (such as to fix an issue in\nthe modules code or to add a feature), you can have Go tools use your fork for\nthe modules source. This can be useful for testing changes from your own code.\n(Note that you can also require the module code in a directory thats on the\nlocal drive with the module that requires it. For more, see\nRequiring module\ncode in a local directory\n.)\nYou do this by using a\nreplace\ndirective in your go.mod file to replace the\nexternal modules original module path with a path to the fork in your\nrepository. This directs Go tools to use the replacement path (the forks\nlocation) when compiling, for example, while allowing you to leave\nimport\nstatements unchanged from the original module path.\nFor more about the\nreplace\ndirective, see the\ngo.mod file\nreference\n.\nIn the following go.mod file example, the current module requires the external\nmodule\nexample.com/theirmodule\n. The\nreplace\ndirective then replaces the\noriginal module path with\nexample.com/myfork/theirmodule\n, a fork of the\nmodules own repository.\nmodule example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v1.2.3\n\nreplace example.com/theirmodule v1.2.3 => example.com/myfork/theirmodule v1.2.3-fixed\nWhen setting up a\nrequire\n/\nreplace\npair, use Go tool commands to ensure that\nrequirements described by the file remain consistent. Use the\ngo list\ncommand to get the version in use by the current\nmodule. Then use the\ngo mod edit\ncommand to replace\nthe required module with the fork:\n$ go list -m example.com/theirmodule\nexample.com/theirmodule v1.2.3\n$ go mod edit -replace=example.com/theirmodule@v1.2.3=example.com/myfork/theirmodule@v1.2.3-fixed\nNote:\nWhen you use the\nreplace\ndirective, Go tools dont authenticate\nexternal modules as described in\nAdding a dependency\n.\nFor more about version numbers, see\nModule version numbering\n.\nGetting a specific commit using a repository identifier\nYou can use the\ngo get\ncommand to add unpublished code for a module from a\nspecific commit in its repository.\nTo do this, you use the\ngo get\ncommand, specifying the code you want with an\n@\nsign. When you use\ngo get\n, the command will add to your go.mod file a\nrequire\ndirective that requires the external module, using a pseudo-version\nnumber based on details about the commit.\nThe following examples provide a few illustrations. These are based on a module\nwhose source is in a git repository.\nTo get the module at a specific commit, append the form @\ncommithash\n:\n$ go get example.com/theirmodule@4cf76c2\nTo get the module at a specific branch, append the form @\nbranchname\n:\n$ go get example.com/theirmodule@bugfixes\nRemoving a dependency\nWhen your code no longer uses any packages in a module, you can stop tracking\nthe module as a dependency.\nTo stop tracking all unused modules, run the\ngo mod tidy\ncommand\n. This command may also add missing dependencies\nneeded to build packages in your module.\n$ go mod tidy\nTo remove a specific dependency, use the\ngo get\ncommand\n, specifying the modules module path and appending\n@none\n, as in the following example:\n$ go get example.com/theirmodule@none\nThe\ngo get\ncommand will also downgrade or remove other dependencies that\ndepend on the removed module.\nTool dependencies\nTool dependencies let you manage developer tools that are written in Go and used\nwhen working on your module. For example, you might use\nstringer\nwith\ngo generate\n, or a specific linter or formatter as part of\npreparing your change for submission.\nIn Go 1.24 and above, you can add a tool dependency with:\n$ go get -tool golang.org/x/tools/cmd/stringer\nThis will add a\ntool\ndirective\nto your\ngo.mod\nfile, and ensure the\nnecessary require directives are present. Once this directive is added you can\nrun the tool by passing the last\nnon-major-version\ncomponent of the tools import path to\ngo tool\n:\n$ go tool stringer\nIn the case that multiple tools share the last path fragment, or the path fragment\nmatches one of the tools shipped with the Go distribution, you must pass the full\npackage path instead:\n$ go tool golang.org/x/tools/cmd/stringer\nTo see a list of all tools currently available, run\ngo tool\nwith no arguments:\n$ go tool\nYou can manually add a\ntool\ndirective to your\ngo.mod\n, but you must ensure\nthat there is a\nrequire\ndirective for the module that defines the tool. The\neasiest way to add any missing\nrequire\ndirectives is to run:\n$ go mod tidy\nRequirements needed to satisfy tool dependencies behave like any other\nrequirements in your\nmodule graph\n. They\nparticipate in\nminimal version selection\nand respect\nrequire\n,\nreplace\nand\nexclude\ndirectives. Due to module\npruning, when you depend on a module that itself has a tool dependency,\nrequirements that exist just to satisfy that tool dependency do not usually\nbecome requirements of your module.\nThe\ntool\nmeta-pattern\nprovides a way to perform operations on all tools simultaneously. For example you can upgrade all tools with\ngo get -u tool\n, or install them all to $GOBIN with\ngo install tool\n.\nIn Go versions before 1.24, you can acheive something similar to a\ntool\ndirective by adding a blank import to a go file within the module that is\nexcluded from the build using\nbuild\nconstraints\n. If you do this, you can then\nuse\ngo run\nwith the full package path to run the tool.\nSpecifying a module proxy server\nWhen you use Go tools to work with modules, the tools by default download\nmodules from proxy.golang.org (a public Google-run module mirror) or directly\nfrom the modules repository. You can specify that Go tools should instead use\nanother proxy server for downloading and authenticating modules.\nYou might want to do this if you (or your team) have set up or chosen a\ndifferent module proxy server that you want to use. For example, some set up a\nmodule proxy server in order to have greater control over how dependencies are\nused.\nTo specify another module proxy server for Go tools use, set the\nGOPROXY\nenvironment variable to the URL of one or more servers. Go tools will try each\nURL in the order you specify. By default,\nGOPROXY\nspecifies a public\nGoogle-run module proxy first, then direct download from the modules repository\n(as specified in its module path):\nGOPROXY=\"https://proxy.golang.org,direct\"\nFor more about the\nGOPROXY\nenvironment variable, including values to support\nother behavior, see the\ngo\ncommand\nreference\n.\nYou can set the variable to URLs for other module proxy servers, separating URLs\nwith either a comma or a pipe.\nWhen you use a comma, Go tools will try the next URL in the list only if the\ncurrent URL returns an HTTP 404 or 410.\nGOPROXY=\"https://proxy.example.com,https://proxy2.example.com\"\nWhen you use a pipe, Go tools will try the next URL in the list regardless\nof the HTTP error code.\nGOPROXY=\"https://proxy.example.com|https://proxy2.example.com\"\nGo modules are frequently developed and distributed on version control servers\nand module proxies that arent available on the public internet. You can set the\nGOPRIVATE\nenvironment variable to configure the\ngo\ncommand\nto download and build modules from private sources.\nThen the go command can download and build modules from private sources.\nThe\nGOPRIVATE\nor\nGONOPROXY\nenvironment variables may be set to lists of glob\npatterns matching module prefixes that are private and should not be requested\nfrom any proxy. For example:\nGOPRIVATE=*.corp.example.com,*.research.example.com",
      "code_examples": [
        {
          "language": "",
          "code": "go help mod tidy",
          "element": "<code>go help mod tidy</code>"
        },
        {
          "language": "",
          "code": "import \"rsc.io/quote\"",
          "element": "<pre><code>import \"rsc.io/quote\"\n</code></pre>"
        },
        {
          "language": "",
          "code": "import \"rsc.io/quote\"",
          "element": "<code>import \"rsc.io/quote\"\n</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "$ go mod init example/mymodule",
          "element": "<pre><code>$ go mod init example/mymodule\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod init example/mymodule",
          "element": "<code>$ go mod init example/mymodule\n</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "go mod init",
          "element": "<code>go mod init</code>"
        },
        {
          "language": "",
          "code": "<prefix>/<descriptive-text>",
          "element": "<pre><code>&lt;prefix&gt;/&lt;descriptive-text&gt;\n</code></pre>"
        },
        {
          "language": "",
          "code": "<prefix>/<descriptive-text>",
          "element": "<code>&lt;prefix&gt;/&lt;descriptive-text&gt;\n</code>"
        },
        {
          "language": "",
          "code": "github.com/<project-name>/",
          "element": "<code>github.com/&lt;project-name&gt;/</code>"
        },
        {
          "language": "",
          "code": "go mod init test",
          "element": "<code>go mod init test</code>"
        },
        {
          "language": "",
          "code": "example.com",
          "element": "<code>example.com</code>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule",
          "element": "<pre><code>$ go get example.com/theirmodule\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule",
          "element": "<code>$ go get example.com/theirmodule\n</code>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@v1.3.4",
          "element": "<pre><code>$ go get example.com/theirmodule@v1.3.4\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@v1.3.4",
          "element": "<code>$ go get example.com/theirmodule@v1.3.4\n</code>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@latest",
          "element": "<pre><code>$ go get example.com/theirmodule@latest\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@latest",
          "element": "<code>$ go get example.com/theirmodule@latest\n</code>"
        },
        {
          "language": "",
          "code": "require example.com/theirmodule v1.3.4",
          "element": "<pre><code>require example.com/theirmodule v1.3.4\n</code></pre>"
        },
        {
          "language": "",
          "code": "require example.com/theirmodule v1.3.4",
          "element": "<code>require example.com/theirmodule v1.3.4\n</code>"
        },
        {
          "language": "",
          "code": "$ go list -m -u all",
          "element": "<pre><code>$ go list -m -u all\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go list -m -u all",
          "element": "<code>$ go list -m -u all\n</code>"
        },
        {
          "language": "",
          "code": "$ go list -m -u example.com/theirmodule",
          "element": "<pre><code>$ go list -m -u example.com/theirmodule\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go list -m -u example.com/theirmodule",
          "element": "<code>$ go list -m -u example.com/theirmodule\n</code>"
        },
        {
          "language": "",
          "code": "go mod tidy",
          "element": "<code>go mod tidy</code>"
        },
        {
          "language": "",
          "code": "$ go mod tidy",
          "element": "<pre><code>$ go mod tidy\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod tidy",
          "element": "<code>$ go mod tidy\n</code>"
        },
        {
          "language": "",
          "code": "example.com/theirmodule",
          "element": "<code>example.com/theirmodule</code>"
        },
        {
          "language": "",
          "code": "v0.0.0-unpublished",
          "element": "<code>v0.0.0-unpublished</code>"
        },
        {
          "language": "",
          "code": "../theirmodule",
          "element": "<code>../theirmodule</code>"
        },
        {
          "language": "",
          "code": "module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v0.0.0-unpublished\n\nreplace example.com/theirmodule v0.0.0-unpublished => ../theirmodule",
          "element": "<pre><code>module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v0.0.0-unpublished\n\nreplace example.com/theirmodule v0.0.0-unpublished =&gt; ../theirmodule\n</code></pre>"
        },
        {
          "language": "",
          "code": "module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v0.0.0-unpublished\n\nreplace example.com/theirmodule v0.0.0-unpublished => ../theirmodule",
          "element": "<code>module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v0.0.0-unpublished\n\nreplace example.com/theirmodule v0.0.0-unpublished =&gt; ../theirmodule\n</code>"
        },
        {
          "language": "",
          "code": "go mod edit",
          "element": "<code>go mod edit</code>"
        },
        {
          "language": "",
          "code": "$ go mod edit -replace=example.com/theirmodule@v0.0.0-unpublished=../theirmodule\n$ go get example.com/theirmodule@v0.0.0-unpublished",
          "element": "<pre><code>$ go mod edit -replace=example.com/theirmodule@v0.0.0-unpublished=../theirmodule\n$ go get example.com/theirmodule@v0.0.0-unpublished\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod edit -replace=example.com/theirmodule@v0.0.0-unpublished=../theirmodule\n$ go get example.com/theirmodule@v0.0.0-unpublished",
          "element": "<code>$ go mod edit -replace=example.com/theirmodule@v0.0.0-unpublished=../theirmodule\n$ go get example.com/theirmodule@v0.0.0-unpublished\n</code>"
        },
        {
          "language": "",
          "code": "example.com/theirmodule",
          "element": "<code>example.com/theirmodule</code>"
        },
        {
          "language": "",
          "code": "example.com/myfork/theirmodule",
          "element": "<code>example.com/myfork/theirmodule</code>"
        },
        {
          "language": "",
          "code": "module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v1.2.3\n\nreplace example.com/theirmodule v1.2.3 => example.com/myfork/theirmodule v1.2.3-fixed",
          "element": "<pre><code>module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v1.2.3\n\nreplace example.com/theirmodule v1.2.3 =&gt; example.com/myfork/theirmodule v1.2.3-fixed\n</code></pre>"
        },
        {
          "language": "",
          "code": "module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v1.2.3\n\nreplace example.com/theirmodule v1.2.3 => example.com/myfork/theirmodule v1.2.3-fixed",
          "element": "<code>module example.com/mymodule\n\ngo 1.23.0\n\nrequire example.com/theirmodule v1.2.3\n\nreplace example.com/theirmodule v1.2.3 =&gt; example.com/myfork/theirmodule v1.2.3-fixed\n</code>"
        },
        {
          "language": "",
          "code": "go mod edit",
          "element": "<code>go mod edit</code>"
        },
        {
          "language": "",
          "code": "$ go list -m example.com/theirmodule\nexample.com/theirmodule v1.2.3\n$ go mod edit -replace=example.com/theirmodule@v1.2.3=example.com/myfork/theirmodule@v1.2.3-fixed",
          "element": "<pre><code>$ go list -m example.com/theirmodule\nexample.com/theirmodule v1.2.3\n$ go mod edit -replace=example.com/theirmodule@v1.2.3=example.com/myfork/theirmodule@v1.2.3-fixed\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go list -m example.com/theirmodule\nexample.com/theirmodule v1.2.3\n$ go mod edit -replace=example.com/theirmodule@v1.2.3=example.com/myfork/theirmodule@v1.2.3-fixed",
          "element": "<code>$ go list -m example.com/theirmodule\nexample.com/theirmodule v1.2.3\n$ go mod edit -replace=example.com/theirmodule@v1.2.3=example.com/myfork/theirmodule@v1.2.3-fixed\n</code>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@4cf76c2",
          "element": "<pre><code>$ go get example.com/theirmodule@4cf76c2\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@4cf76c2",
          "element": "<code>$ go get example.com/theirmodule@4cf76c2\n</code>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@bugfixes",
          "element": "<pre><code>$ go get example.com/theirmodule@bugfixes\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@bugfixes",
          "element": "<code>$ go get example.com/theirmodule@bugfixes\n</code>"
        },
        {
          "language": "",
          "code": "go mod tidy",
          "element": "<code>go mod tidy</code>"
        },
        {
          "language": "",
          "code": "$ go mod tidy",
          "element": "<pre><code>$ go mod tidy\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod tidy",
          "element": "<code>$ go mod tidy\n</code>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@none",
          "element": "<pre><code>$ go get example.com/theirmodule@none\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get example.com/theirmodule@none",
          "element": "<code>$ go get example.com/theirmodule@none\n</code>"
        },
        {
          "language": "",
          "code": "go generate",
          "element": "<code>go generate</code>"
        },
        {
          "language": "",
          "code": "$ go get -tool golang.org/x/tools/cmd/stringer",
          "element": "<pre><code>$ go get -tool golang.org/x/tools/cmd/stringer\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go get -tool golang.org/x/tools/cmd/stringer",
          "element": "<code>$ go get -tool golang.org/x/tools/cmd/stringer\n</code>"
        },
        {
          "language": "",
          "code": "$ go tool stringer",
          "element": "<pre><code>$ go tool stringer\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go tool stringer",
          "element": "<code>$ go tool stringer\n</code>"
        },
        {
          "language": "",
          "code": "$ go tool golang.org/x/tools/cmd/stringer",
          "element": "<pre><code>$ go tool golang.org/x/tools/cmd/stringer\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go tool golang.org/x/tools/cmd/stringer",
          "element": "<code>$ go tool golang.org/x/tools/cmd/stringer\n</code>"
        },
        {
          "language": "",
          "code": "$ go mod tidy",
          "element": "<pre><code>$ go mod tidy\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go mod tidy",
          "element": "<code>$ go mod tidy\n</code>"
        },
        {
          "language": "",
          "code": "go get -u tool",
          "element": "<code>go get -u tool</code>"
        },
        {
          "language": "",
          "code": "go install tool",
          "element": "<code>go install tool</code>"
        },
        {
          "language": "",
          "code": "GOPROXY=\"https://proxy.golang.org,direct\"",
          "element": "<pre><code>GOPROXY=\"https://proxy.golang.org,direct\"\n</code></pre>"
        },
        {
          "language": "",
          "code": "GOPROXY=\"https://proxy.golang.org,direct\"",
          "element": "<code>GOPROXY=\"https://proxy.golang.org,direct\"\n</code>"
        },
        {
          "language": "",
          "code": "GOPROXY=\"https://proxy.example.com,https://proxy2.example.com\"",
          "element": "<pre><code>GOPROXY=\"https://proxy.example.com,https://proxy2.example.com\"\n</code></pre>"
        },
        {
          "language": "",
          "code": "GOPROXY=\"https://proxy.example.com,https://proxy2.example.com\"",
          "element": "<code>GOPROXY=\"https://proxy.example.com,https://proxy2.example.com\"\n</code>"
        },
        {
          "language": "",
          "code": "GOPROXY=\"https://proxy.example.com|https://proxy2.example.com\"",
          "element": "<pre><code>GOPROXY=\"https://proxy.example.com|https://proxy2.example.com\"\n</code></pre>"
        },
        {
          "language": "",
          "code": "GOPROXY=\"https://proxy.example.com|https://proxy2.example.com\"",
          "element": "<code>GOPROXY=\"https://proxy.example.com|https://proxy2.example.com\"\n</code>"
        },
        {
          "language": "",
          "code": "GOPRIVATE=*.corp.example.com,*.research.example.com",
          "element": "<pre><code>GOPRIVATE=*.corp.example.com,*.research.example.com\n</code></pre>"
        },
        {
          "language": "",
          "code": "GOPRIVATE=*.corp.example.com,*.research.example.com",
          "element": "<code>GOPRIVATE=*.corp.example.com,*.research.example.com\n</code>"
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Managing dependencies",
          "id": ""
        },
        {
          "level": 2,
          "text": "Workflow for using and managing dependencies",
          "id": "workflow"
        },
        {
          "level": 2,
          "text": "Managing dependencies as modules",
          "id": "modules"
        },
        {
          "level": 2,
          "text": "Locating and importing useful packages",
          "id": "locating_packages"
        },
        {
          "level": 2,
          "text": "Enabling dependency tracking in your code",
          "id": "enable_tracking"
        },
        {
          "level": 2,
          "text": "Naming a module",
          "id": "naming_module"
        },
        {
          "level": 2,
          "text": "Adding a dependency",
          "id": "adding_dependency"
        },
        {
          "level": 2,
          "text": "Getting a specific dependency version",
          "id": "getting_version"
        },
        {
          "level": 2,
          "text": "Discovering available updates",
          "id": "discovering_updates"
        },
        {
          "level": 2,
          "text": "Upgrading or downgrading a dependency",
          "id": "upgrading"
        },
        {
          "level": 2,
          "text": "Synchronizing your codes dependencies",
          "id": "synchronizing"
        },
        {
          "level": 2,
          "text": "Developing and testing against unpublished module code",
          "id": "unpublished"
        },
        {
          "level": 2,
          "text": "Getting a specific commit using a repository identifier",
          "id": "repo_identifier"
        },
        {
          "level": 2,
          "text": "Removing a dependency",
          "id": "removing_dependency"
        },
        {
          "level": 2,
          "text": "Tool dependencies",
          "id": "tools"
        },
        {
          "level": 2,
          "text": "Specifying a module proxy server",
          "id": "proxy_server"
        },
        {
          "level": 3,
          "text": "Requiring module code in a local directory",
          "id": "local_directory"
        },
        {
          "level": 3,
          "text": "Requiring external module code from your own repository fork",
          "id": "external_fork"
        }
      ],
      "timestamp": 1750757613.27216
    },
    {
      "url": "https://golang.org/doc/build-cover",
      "title": "Coverage profiling support for integration tests - The Go Programming Language",
      "content": "Coverage profiling support for integration tests\nTable of Contents:\nOverview\nBuilding a binary for coverage profiling\nRunning a coverage-instrumented binary\nWorking with coverage data files\nFrequently Asked Questions\nResources\nGlossary\nBeginning in Go 1.20, Go supports collection of coverage profiles from applications and from integration tests, larger and more complex tests for Go programs.\nOverview\nGo provides easy-to-use support for collecting coverage profiles at the level of package unit tests via the \ngo test -coverprofile=... <pkg_target>\n command.\nStarting with Go 1.20, users can now collect coverage profiles for larger\nintegration tests\n: more heavy-weight, complex tests that perform multiple runs of a given application binary.\nFor unit tests, collecting a coverage profile and generating a report requires two steps: a\ngo test -coverprofile=...\nrun, followed by an invocation of\ngo tool cover {-func,-html}\nto generate a report.\nFor integration tests, three steps are needed: a\nbuild\nstep, a\nrun\nstep (which may involve multiple invocations of the binary from the build step), and finally a\nreporting\nstep, as described below.\nBuilding a binary for coverage profiling\nTo build an application for collecting coverage profiles, pass the\n-cover\nflag when invoking\ngo build\non your application binary target. See the section\nbelow\nfor a sample\ngo build -cover\ninvocation.\nThe resulting binary can then be run using an environment variable setting to capture coverage profiles (see the next section on\nrunning\n).\nHow packages are selected for instrumentation\nDuring a given \ngo build -cover\n invocation, the Go command will select packages in the main module for coverage profiling; other packages that feed into the build (dependencies listed in go.mod, or packages that are part of the Go standard library) will not be included by default.\nFor example, here is a toy program containing a main package, a local main-module package\ngreetings\nand a set of packages imported from outside the module, including (among others)\nrsc.io/quote\nand\nfmt\n(\nlink to full program\n).\n$ cat go.mod\nmodule mydomain.com\n\ngo 1.20\n\nrequire rsc.io/quote v1.5.2\n\nrequire (\n    golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c // indirect\n    rsc.io/sampler v1.3.0 // indirect\n)\n\n$ cat myprogram.go\npackage main\n\nimport (\n    \"fmt\"\n    \"mydomain.com/greetings\"\n    \"rsc.io/quote\"\n)\n\nfunc main() {\n    fmt.Printf(\"I say %q and %q\\n\", quote.Hello(), greetings.Goodbye())\n}\n$ cat greetings/greetings.go\npackage greetings\n\nfunc Goodbye() string {\n    return \"see ya\"\n}\n$ go build -cover -o myprogram.exe .\n$\nIf you build this program with the \n-cover\n command line flag and run it, exactly two packages will be included in the profile:\nmain\nand\nmydomain.com/greetings\n; the other dependent packages will be excluded.\nUsers who want to have more control over which packages are included for coverage can build with the \n-coverpkg\n flag. Example:\n$ go build -cover -o myprogramMorePkgs.exe -coverpkg=io,mydomain.com,rsc.io/quote .\n$\nIn the build above, the main package from\nmydomain.com\nas well as the\nrsc.io/quote\nand\nio\npackages are selected for profiling; since\nmydomain.com/greetings\nisnt specifically listed, it will be excluded from the profile, even though it resides in the main module.\nRunning a coverage-instrumented binary\nBinaries built with \n-cover\n write out profile data files at the end of their execution to a directory specified via the environment variable\nGOCOVERDIR\n. Example:\n$ go build -cover -o myprogram.exe myprogram.go\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$\nNote the two files that were written to the directory\nsomedata\n: these (binary) files contain the coverage results.  See the following section on\nreporting\nfor more on how to produce human-readable results from these data files.\nIf the\nGOCOVERDIR\nenvironment variable is not set, a coverage-instrumented binary will still execute correctly, but will issue a warning.\nExample:\n$ ./myprogram.exe\nwarning: GOCOVERDIR not set, no coverage data emitted\nI say \"Hello, world.\" and \"see ya\"\n$\nTests involving multiple runs\nIntegration tests can in many cases involve multiple program runs; when the program is built with \n-cover\n, each run will produce a new data file. Example\n$ mkdir somedata2\n$ GOCOVERDIR=somedata2 ./myprogram.exe          // first run\nI say \"Hello, world.\" and \"see ya\"\n$ GOCOVERDIR=somedata2 ./myprogram.exe -flag    // second run\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata2\ncovcounters.890814fca98ac3a4d41b9bd2a7ec9f7f.2456041.1670259309405583534\ncovcounters.890814fca98ac3a4d41b9bd2a7ec9f7f.2456047.1670259309410891043\ncovmeta.890814fca98ac3a4d41b9bd2a7ec9f7f\n$\nCoverage data output files come in two flavors: meta-data files (containing the items that are invariant from run to run, such as source file names and function names), and counter data files (which record the parts of the program that executed).\nIn the example above, the first run produced two files (counter and meta), whereas the second run generated only a counter data file: since meta-data doesnt change from run to run, it only needs to be written once.\nWorking with coverage data files\nGo 1.20 introduces a new tool, \ncovdata\n, that can be used to read and manipulate coverage data files from a\nGOCOVERDIR\ndirectory.\nGos\ncovdata\ntool runs in a variety of modes. The general form of a\ncovdata\ntool invocation takes the form\n$ go tool covdata <mode> -i=<dir1,dir2,...> ...flags...\nwhere the \n-i\n flag provides a list of directories to read, where each directories is derived from an execution of a coverage-instrumented binary (via\nGOCOVERDIR\n).\nCreating coverage profile reports\nThis section discusses how to use \ngo tool covdata\n to produce human-readable reports from coverage data files.\nReporting percent statements covered\nTo report a percent statements covered metric for each instrumented package, use the command \ngo tool covdata percent -i=<directory>\n.\nUsing the example from the\nrunning\nsection above:\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata\n    main    coverage: 100.0% of statements\n    mydomain.com/greetings  coverage: 100.0% of statements\n$\nThe statements covered percentages here correspond directly to those reported by\ngo test -cover\n.\nConverting to legacy text format\nYou can convert binary coverage data files into the legacy textual format generated by \ngo test -coverprofile=<outfile>\n using the covdata\ntextfmt\nselector. The resulting text file can then be used with \ngo tool cover -func\n or \ngo tool cover -html\n to create additional reports. Example:\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata textfmt -i=somedata -o profile.txt\n$ cat profile.txt\nmode: set\nmydomain.com/myprogram.go:10.13,12.2 1 1\nmydomain.com/greetings/greetings.go:3.23,5.2 1 1\n$ go tool cover -func=profile.txt\nmydomain.com/greetings/greetings.go:3:  Goodbye     100.0%\nmydomain.com/myprogram.go:10:       main        100.0%\ntotal:                  (statements)    100.0%\n$\nMerging\nThe\nmerge\nsubcommand of \ngo tool covdata\n can be used to merge together profiles from multiple data directories.\nFor example, consider a program that runs on both macOS and on Windows.\nThe author of this program might want to combine coverage profiles from separate\nruns on each operating system into a single profile corpus, so as to produce a\ncross-platform coverage summary.\nFor example:\n$ ls windows_datadir\ncovcounters.f3833f80c91d8229544b25a855285890.1025623.1667481441036838252\ncovcounters.f3833f80c91d8229544b25a855285890.1025628.1667481441042785007\ncovmeta.f3833f80c91d8229544b25a855285890\n$ ls macos_datadir\ncovcounters.b245ad845b5068d116a4e25033b429fb.1025358.1667481440551734165\ncovcounters.b245ad845b5068d116a4e25033b429fb.1025364.1667481440557770197\ncovmeta.b245ad845b5068d116a4e25033b429fb\n$ ls macos_datadir\n$ mkdir merged\n$ go tool covdata merge -i=windows_datadir,macos_datadir -o merged\n$\nThe merge operation above will combine the data from the specified input directories and write a new set of merged data files to the directory merged.\nPackage selection\nMost \ngo tool covdata\n commands support a \n-pkg\n flag to perform package selection as part of the operation; the argument to \n-pkg\n takes the same form as that used by the Go commands \n-coverpkg\n flag.\nExample:\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata -pkg=mydomain.com/greetings\n    mydomain.com/greetings  coverage: 100.0% of statements\n$ go tool covdata percent -i=somedata -pkg=nonexistentpackage\n$\nThe \n-pkg\n flag can be used to select the specific subset of packages of interest for a given report.\nFrequently Asked Questions\nHow can I request coverage instrumentation for all imported packages mentioned in my\ngo.mod\nfile\nCan I use\ngo build -cover\nin GOPATH/GO111MODULE=off mode?\nIf my program panics, will coverage data be written?\nWill\n-coverpkg=main\nselect my main package for profiling?\nHow can I request coverage instrumentation for all imported packages mentioned in my\ngo.mod\nfile\nBy default,\ngo build -cover\nwill instrument all main module packages\nfor coverage, but will not instrument imports outside the main module\n(e.g. standard library packages or imports listed in\ngo.mod\n).\nOne way to request instrumentation for all non-stdlib dependencies\nis to feed the output of\ngo list\ninto\n-coverpkg\n.\nHere is an example, again using\nthe\nexample program\ncited above:\n$ go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}' -deps . | paste -sd \",\" > pkgs.txt\n$ go build -o myprogram.exe -coverpkg=`cat pkgs.txt` .\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\n$ go tool covdata percent -i=somedata\n    golang.org/x/text/internal/tag  coverage: 78.4% of statements\n    golang.org/x/text/language  coverage: 35.5% of statements\n    mydomain.com    coverage: 100.0% of statements\n    mydomain.com/greetings  coverage: 100.0% of statements\n    rsc.io/quote    coverage: 25.0% of statements\n    rsc.io/sampler  coverage: 86.7% of statements\n$\nCan I use\ngo build -cover\nin GO111MODULE=off mode?\nYes,\ngo build -cover\ndoes work with\nGO111MODULE=off\n.\nWhen building a program in GO111MODULE=off mode, only the package specifically named as the target on the command line will be instrumented for profiling. Use the\n-coverpkg\nflag to include additional packages in the profile.\nIf my program panics, will coverage data be written?\nPrograms built with\ngo build -cover\nwill only write out complete profile\ndata at the end of execution if the program invokes\nos.Exit()\nor returns\nnormally from\nmain.main\n.\nIf a program terminates in an unrecovered panic, or if the program hits a\nfatal exception (such as a segmentation violation, divide by zero, etc),\nprofile data from statements executed during the run will be lost.\nWill\n-coverpkg=main\nselect my main package for profiling?\nThe\n-coverpkg\nflag accepts a list of import paths, not a list of package names. If you want to select your\nmain\npackage for coverage instrumention, please identify it by import path, not by name. Example (using\nthis example program\n):\n$ go list -m\nmydomain.com\n$ go build -coverpkg=main -o oops.exe .\nwarning: no packages being built depend on matches for pattern main\n$ go build -coverpkg=mydomain.com -o myprogram.exe .\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ go tool covdata percent -i=somedata\n    mydomain.com    coverage: 100.0% of statements\n$\nResources\nBlog post introducing unit test coverage in Go 1.2\n:\nCoverage profiling for unit tests was introduced as part of the\nGo 1.2 release; see\nthis blog post\nfor details.\nDocumentation\n:\nThe\ncmd/go\npackage docs describe the\nbuild and test flags associated with coverage.\nTechnical details\n:\nDesign draft\nProposal\nGlossary\nunit test:\nTests within a\n*_test.go\nfile associated with a specific Go package, utilizing Gos\ntesting\npackage.\nintegration test:\nA more comprehensive, heavier weight test for a given application or binary. Integration tests typically involve building a program or set of programs, then performing a series of runs of the programs using multiple inputs and scenarios, under control of a test harness that may or may not be based on Gos\ntesting\npackage.",
      "code_examples": [
        {
          "language": "",
          "code": "go test -coverprofile=... <pkg_target>",
          "element": "<code>go test -coverprofile=... &lt;pkg_target&gt;</code>"
        },
        {
          "language": "",
          "code": "go test -coverprofile=...",
          "element": "<code>go test -coverprofile=...</code>"
        },
        {
          "language": "",
          "code": "go tool cover {-func,-html}",
          "element": "<code>go tool cover {-func,-html}</code>"
        },
        {
          "language": "",
          "code": "go build -cover",
          "element": "<code>go build -cover</code>"
        },
        {
          "language": "",
          "code": "go build -cover",
          "element": "<code>go build -cover</code>"
        },
        {
          "language": "",
          "code": "rsc.io/quote",
          "element": "<code>rsc.io/quote</code>"
        },
        {
          "language": "",
          "code": "$ cat go.mod\nmodule mydomain.com\n\ngo 1.20\n\nrequire rsc.io/quote v1.5.2\n\nrequire (\n    golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c // indirect\n    rsc.io/sampler v1.3.0 // indirect\n)\n\n$ cat myprogram.go\npackage main\n\nimport (\n    \"fmt\"\n    \"mydomain.com/greetings\"\n    \"rsc.io/quote\"\n)\n\nfunc main() {\n    fmt.Printf(\"I say %q and %q\\n\", quote.Hello(), greetings.Goodbye())\n}\n$ cat greetings/greetings.go\npackage greetings\n\nfunc Goodbye() string {\n    return \"see ya\"\n}\n$ go build -cover -o myprogram.exe .\n$",
          "element": "<pre><code>$ cat go.mod\nmodule mydomain.com\n\ngo 1.20\n\nrequire rsc.io/quote v1.5.2\n\nrequire (\n    golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c // indirect\n    rsc.io/sampler v1.3.0 // indirect\n..."
        },
        {
          "language": "",
          "code": "$ cat go.mod\nmodule mydomain.com\n\ngo 1.20\n\nrequire rsc.io/quote v1.5.2\n\nrequire (\n    golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c // indirect\n    rsc.io/sampler v1.3.0 // indirect\n)\n\n$ cat myprogram.go\npackage main\n\nimport (\n    \"fmt\"\n    \"mydomain.com/greetings\"\n    \"rsc.io/quote\"\n)\n\nfunc main() {\n    fmt.Printf(\"I say %q and %q\\n\", quote.Hello(), greetings.Goodbye())\n}\n$ cat greetings/greetings.go\npackage greetings\n\nfunc Goodbye() string {\n    return \"see ya\"\n}\n$ go build -cover -o myprogram.exe .\n$",
          "element": "<code>$ cat go.mod\nmodule mydomain.com\n\ngo 1.20\n\nrequire rsc.io/quote v1.5.2\n\nrequire (\n    golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c // indirect\n    rsc.io/sampler v1.3.0 // indirect\n)\n\n$ ..."
        },
        {
          "language": "",
          "code": "mydomain.com/greetings",
          "element": "<code>mydomain.com/greetings</code>"
        },
        {
          "language": "",
          "code": "$ go build -cover -o myprogramMorePkgs.exe -coverpkg=io,mydomain.com,rsc.io/quote .\n$",
          "element": "<pre><code>$ go build -cover -o myprogramMorePkgs.exe -coverpkg=io,mydomain.com,rsc.io/quote .\n$\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go build -cover -o myprogramMorePkgs.exe -coverpkg=io,mydomain.com,rsc.io/quote .\n$",
          "element": "<code>$ go build -cover -o myprogramMorePkgs.exe -coverpkg=io,mydomain.com,rsc.io/quote .\n$\n</code>"
        },
        {
          "language": "",
          "code": "mydomain.com",
          "element": "<code>mydomain.com</code>"
        },
        {
          "language": "",
          "code": "rsc.io/quote",
          "element": "<code>rsc.io/quote</code>"
        },
        {
          "language": "",
          "code": "mydomain.com/greetings",
          "element": "<code>mydomain.com/greetings</code>"
        },
        {
          "language": "",
          "code": "$ go build -cover -o myprogram.exe myprogram.go\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$",
          "element": "<pre><code>$ go build -cover -o myprogram.exe myprogram.go\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b..."
        },
        {
          "language": "",
          "code": "$ go build -cover -o myprogram.exe myprogram.go\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$",
          "element": "<code>$ go build -cover -o myprogram.exe myprogram.go\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4..."
        },
        {
          "language": "",
          "code": "$ ./myprogram.exe\nwarning: GOCOVERDIR not set, no coverage data emitted\nI say \"Hello, world.\" and \"see ya\"\n$",
          "element": "<pre><code>$ ./myprogram.exe\nwarning: GOCOVERDIR not set, no coverage data emitted\nI say \"Hello, world.\" and \"see ya\"\n$\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ ./myprogram.exe\nwarning: GOCOVERDIR not set, no coverage data emitted\nI say \"Hello, world.\" and \"see ya\"\n$",
          "element": "<code>$ ./myprogram.exe\nwarning: GOCOVERDIR not set, no coverage data emitted\nI say \"Hello, world.\" and \"see ya\"\n$\n</code>"
        },
        {
          "language": "",
          "code": "$ mkdir somedata2\n$ GOCOVERDIR=somedata2 ./myprogram.exe          // first run\nI say \"Hello, world.\" and \"see ya\"\n$ GOCOVERDIR=somedata2 ./myprogram.exe -flag    // second run\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata2\ncovcounters.890814fca98ac3a4d41b9bd2a7ec9f7f.2456041.1670259309405583534\ncovcounters.890814fca98ac3a4d41b9bd2a7ec9f7f.2456047.1670259309410891043\ncovmeta.890814fca98ac3a4d41b9bd2a7ec9f7f\n$",
          "element": "<pre><code>$ mkdir somedata2\n$ GOCOVERDIR=somedata2 ./myprogram.exe          // first run\nI say \"Hello, world.\" and \"see ya\"\n$ GOCOVERDIR=somedata2 ./myprogram.exe -flag    // second run\nI say \"Hello,..."
        },
        {
          "language": "",
          "code": "$ mkdir somedata2\n$ GOCOVERDIR=somedata2 ./myprogram.exe          // first run\nI say \"Hello, world.\" and \"see ya\"\n$ GOCOVERDIR=somedata2 ./myprogram.exe -flag    // second run\nI say \"Hello, world.\" and \"see ya\"\n$ ls somedata2\ncovcounters.890814fca98ac3a4d41b9bd2a7ec9f7f.2456041.1670259309405583534\ncovcounters.890814fca98ac3a4d41b9bd2a7ec9f7f.2456047.1670259309410891043\ncovmeta.890814fca98ac3a4d41b9bd2a7ec9f7f\n$",
          "element": "<code>$ mkdir somedata2\n$ GOCOVERDIR=somedata2 ./myprogram.exe          // first run\nI say \"Hello, world.\" and \"see ya\"\n$ GOCOVERDIR=somedata2 ./myprogram.exe -flag    // second run\nI say \"Hello, worl..."
        },
        {
          "language": "",
          "code": "$ go tool covdata <mode> -i=<dir1,dir2,...> ...flags...",
          "element": "<pre><code>$ go tool covdata &lt;mode&gt; -i=&lt;dir1,dir2,...&gt; ...flags...\n</code></pre>"
        },
        {
          "language": "",
          "code": "$ go tool covdata <mode> -i=<dir1,dir2,...> ...flags...",
          "element": "<code>$ go tool covdata &lt;mode&gt; -i=&lt;dir1,dir2,...&gt; ...flags...\n</code>"
        },
        {
          "language": "",
          "code": "go tool covdata",
          "element": "<code>go tool covdata</code>"
        },
        {
          "language": "",
          "code": "go tool covdata percent -i=<directory>",
          "element": "<code>go tool covdata percent -i=&lt;directory&gt;</code>"
        },
        {
          "language": "",
          "code": "$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata\n    main    coverage: 100.0% of statements\n    mydomain.com/greetings  coverage: 100.0% of statements\n$",
          "element": "<pre><code>$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata\n    main    coverage: 1..."
        },
        {
          "language": "",
          "code": "$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata\n    main    coverage: 100.0% of statements\n    mydomain.com/greetings  coverage: 100.0% of statements\n$",
          "element": "<code>$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata\n    main    coverage: 100.0%..."
        },
        {
          "language": "",
          "code": "go test -cover",
          "element": "<code>go test -cover</code>"
        },
        {
          "language": "",
          "code": "go test -coverprofile=<outfile>",
          "element": "<code>go test -coverprofile=&lt;outfile&gt;</code>"
        },
        {
          "language": "",
          "code": "go tool cover -func",
          "element": "<code>go tool cover -func</code>"
        },
        {
          "language": "",
          "code": "go tool cover -html",
          "element": "<code>go tool cover -html</code>"
        },
        {
          "language": "",
          "code": "$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata textfmt -i=somedata -o profile.txt\n$ cat profile.txt\nmode: set\nmydomain.com/myprogram.go:10.13,12.2 1 1\nmydomain.com/greetings/greetings.go:3.23,5.2 1 1\n$ go tool cover -func=profile.txt\nmydomain.com/greetings/greetings.go:3:  Goodbye     100.0%\nmydomain.com/myprogram.go:10:       main        100.0%\ntotal:                  (statements)    100.0%\n$",
          "element": "<pre><code>$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata textfmt -i=somedata -o profile.txt\n$ cat pr..."
        },
        {
          "language": "",
          "code": "$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata textfmt -i=somedata -o profile.txt\n$ cat profile.txt\nmode: set\nmydomain.com/myprogram.go:10.13,12.2 1 1\nmydomain.com/greetings/greetings.go:3.23,5.2 1 1\n$ go tool cover -func=profile.txt\nmydomain.com/greetings/greetings.go:3:  Goodbye     100.0%\nmydomain.com/myprogram.go:10:       main        100.0%\ntotal:                  (statements)    100.0%\n$",
          "element": "<code>$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata textfmt -i=somedata -o profile.txt\n$ cat profile..."
        },
        {
          "language": "",
          "code": "go tool covdata",
          "element": "<code>go tool covdata</code>"
        },
        {
          "language": "",
          "code": "$ ls windows_datadir\ncovcounters.f3833f80c91d8229544b25a855285890.1025623.1667481441036838252\ncovcounters.f3833f80c91d8229544b25a855285890.1025628.1667481441042785007\ncovmeta.f3833f80c91d8229544b25a855285890\n$ ls macos_datadir\ncovcounters.b245ad845b5068d116a4e25033b429fb.1025358.1667481440551734165\ncovcounters.b245ad845b5068d116a4e25033b429fb.1025364.1667481440557770197\ncovmeta.b245ad845b5068d116a4e25033b429fb\n$ ls macos_datadir\n$ mkdir merged\n$ go tool covdata merge -i=windows_datadir,macos_datadir -o merged\n$",
          "element": "<pre><code>$ ls windows_datadir\ncovcounters.f3833f80c91d8229544b25a855285890.1025623.1667481441036838252\ncovcounters.f3833f80c91d8229544b25a855285890.1025628.1667481441042785007\ncovmeta.f3833f80c91d82..."
        },
        {
          "language": "",
          "code": "$ ls windows_datadir\ncovcounters.f3833f80c91d8229544b25a855285890.1025623.1667481441036838252\ncovcounters.f3833f80c91d8229544b25a855285890.1025628.1667481441042785007\ncovmeta.f3833f80c91d8229544b25a855285890\n$ ls macos_datadir\ncovcounters.b245ad845b5068d116a4e25033b429fb.1025358.1667481440551734165\ncovcounters.b245ad845b5068d116a4e25033b429fb.1025364.1667481440557770197\ncovmeta.b245ad845b5068d116a4e25033b429fb\n$ ls macos_datadir\n$ mkdir merged\n$ go tool covdata merge -i=windows_datadir,macos_datadir -o merged\n$",
          "element": "<code>$ ls windows_datadir\ncovcounters.f3833f80c91d8229544b25a855285890.1025623.1667481441036838252\ncovcounters.f3833f80c91d8229544b25a855285890.1025628.1667481441042785007\ncovmeta.f3833f80c91d8229544..."
        },
        {
          "language": "",
          "code": "go tool covdata",
          "element": "<code>go tool covdata</code>"
        },
        {
          "language": "",
          "code": "$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata -pkg=mydomain.com/greetings\n    mydomain.com/greetings  coverage: 100.0% of statements\n$ go tool covdata percent -i=somedata -pkg=nonexistentpackage\n$",
          "element": "<pre><code>\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata -pkg=mydomain.com/gree..."
        },
        {
          "language": "",
          "code": "$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata -pkg=mydomain.com/greetings\n    mydomain.com/greetings  coverage: 100.0% of statements\n$ go tool covdata percent -i=somedata -pkg=nonexistentpackage\n$",
          "element": "<code>\n$ ls somedata\ncovcounters.c6de772f99010ef5925877a7b05db4cc.2424989.1670252383678349347\ncovmeta.c6de772f99010ef5925877a7b05db4cc\n$ go tool covdata percent -i=somedata -pkg=mydomain.com/greetings..."
        },
        {
          "language": "",
          "code": "go build -cover",
          "element": "<code>go build -cover</code>"
        },
        {
          "language": "",
          "code": "-coverpkg=main",
          "element": "<code>-coverpkg=main</code>"
        },
        {
          "language": "",
          "code": "go build -cover",
          "element": "<code>go build -cover</code>"
        },
        {
          "language": "",
          "code": "$ go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}' -deps . | paste -sd \",\" > pkgs.txt\n$ go build -o myprogram.exe -coverpkg=`cat pkgs.txt` .\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\n$ go tool covdata percent -i=somedata\n    golang.org/x/text/internal/tag  coverage: 78.4% of statements\n    golang.org/x/text/language  coverage: 35.5% of statements\n    mydomain.com    coverage: 100.0% of statements\n    mydomain.com/greetings  coverage: 100.0% of statements\n    rsc.io/quote    coverage: 25.0% of statements\n    rsc.io/sampler  coverage: 86.7% of statements\n$",
          "element": "<pre><code>$ go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}' -deps . | paste -sd \",\" &gt; pkgs.txt\n$ go build -o myprogram.exe -coverpkg=`cat pkgs.txt` .\n$ mkdir somedata\n$ GOCOVERDIR=somedata..."
        },
        {
          "language": "",
          "code": "$ go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}' -deps . | paste -sd \",\" > pkgs.txt\n$ go build -o myprogram.exe -coverpkg=`cat pkgs.txt` .\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\n$ go tool covdata percent -i=somedata\n    golang.org/x/text/internal/tag  coverage: 78.4% of statements\n    golang.org/x/text/language  coverage: 35.5% of statements\n    mydomain.com    coverage: 100.0% of statements\n    mydomain.com/greetings  coverage: 100.0% of statements\n    rsc.io/quote    coverage: 25.0% of statements\n    rsc.io/sampler  coverage: 86.7% of statements\n$",
          "element": "<code>$ go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}' -deps . | paste -sd \",\" &gt; pkgs.txt\n$ go build -o myprogram.exe -coverpkg=`cat pkgs.txt` .\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./my..."
        },
        {
          "language": "",
          "code": "go build -cover",
          "element": "<code>go build -cover</code>"
        },
        {
          "language": "",
          "code": "go build -cover",
          "element": "<code>go build -cover</code>"
        },
        {
          "language": "",
          "code": "GO111MODULE=off",
          "element": "<code>GO111MODULE=off</code>"
        },
        {
          "language": "",
          "code": "go build -cover",
          "element": "<code>go build -cover</code>"
        },
        {
          "language": "",
          "code": "-coverpkg=main",
          "element": "<code>-coverpkg=main</code>"
        },
        {
          "language": "",
          "code": "$ go list -m\nmydomain.com\n$ go build -coverpkg=main -o oops.exe .\nwarning: no packages being built depend on matches for pattern main\n$ go build -coverpkg=mydomain.com -o myprogram.exe .\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ go tool covdata percent -i=somedata\n    mydomain.com    coverage: 100.0% of statements\n$",
          "element": "<pre><code>$ go list -m\nmydomain.com\n$ go build -coverpkg=main -o oops.exe .\nwarning: no packages being built depend on matches for pattern main\n$ go build -coverpkg=mydomain.com -o myprogram.exe .\n$ ..."
        },
        {
          "language": "",
          "code": "$ go list -m\nmydomain.com\n$ go build -coverpkg=main -o oops.exe .\nwarning: no packages being built depend on matches for pattern main\n$ go build -coverpkg=mydomain.com -o myprogram.exe .\n$ mkdir somedata\n$ GOCOVERDIR=somedata ./myprogram.exe\nI say \"Hello, world.\" and \"see ya\"\n$ go tool covdata percent -i=somedata\n    mydomain.com    coverage: 100.0% of statements\n$",
          "element": "<code>$ go list -m\nmydomain.com\n$ go build -coverpkg=main -o oops.exe .\nwarning: no packages being built depend on matches for pattern main\n$ go build -coverpkg=mydomain.com -o myprogram.exe .\n$ mkdir..."
        }
      ],
      "headings": [
        {
          "level": 1,
          "text": "Coverage profiling support for integration tests",
          "id": ""
        },
        {
          "level": 1,
          "text": "Overview",
          "id": "overview"
        },
        {
          "level": 1,
          "text": "Building a binary for coverage profiling",
          "id": "building"
        },
        {
          "level": 1,
          "text": "Running a coverage-instrumented binary",
          "id": "running"
        },
        {
          "level": 1,
          "text": "Working with coverage data files",
          "id": "working"
        },
        {
          "level": 1,
          "text": "",
          "id": "heading"
        },
        {
          "level": 2,
          "text": "How packages are selected for instrumentation",
          "id": "packageselection"
        },
        {
          "level": 2,
          "text": "Tests involving multiple runs",
          "id": "tests-involving-multiple-runs"
        },
        {
          "level": 2,
          "text": "Creating coverage profile reports",
          "id": "reporting"
        },
        {
          "level": 2,
          "text": "Converting to legacy text format",
          "id": "converting-to-legacy-text-format"
        },
        {
          "level": 2,
          "text": "Merging",
          "id": "merging"
        },
        {
          "level": 2,
          "text": "Package selection",
          "id": "package-selection"
        },
        {
          "level": 2,
          "text": "Frequently Asked Questions",
          "id": "FAQ"
        },
        {
          "level": 2,
          "text": "Resources",
          "id": "resources"
        },
        {
          "level": 2,
          "text": "Glossary",
          "id": "glossary"
        },
        {
          "level": 3,
          "text": "Reporting percent statements covered",
          "id": "reporting-percent-statements-covered"
        },
        {
          "level": 4,
          "text": "How can I request coverage instrumentation for all imported packages mentioned in mygo.modfile",
          "id": "gomodselect"
        },
        {
          "level": 4,
          "text": "Can I usego build -coverin GO111MODULE=off mode?",
          "id": "gopathmode"
        },
        {
          "level": 4,
          "text": "If my program panics, will coverage data be written?",
          "id": "panicprof"
        },
        {
          "level": 4,
          "text": "Will-coverpkg=mainselect my main package for profiling?",
          "id": "mainpkg"
        }
      ],
      "timestamp": 1750757617.0587032
    }
  ],
  "total_pages": 15,
  "errors": []
}